// This code conforms with the UFC specification version 2018.1.0
// and was automatically generated by FFC version 2019.1.0.post0.
//
// This code was generated with the option '-l dolfin' and
// contains DOLFIN-specific wrappers that depend on DOLFIN.
//
// This code was generated with the following parameters:
//

//  add_tabulate_tensor_timing:     False
//  convert_exceptions_to_warnings: False
//  cpp_optimize:                   True
//  cpp_optimize_flags:             '-O2'
//  epsilon:                        1e-14
//  error_control:                  False
//  external_include_dirs:          ''
//  external_includes:              ''
//  external_libraries:             ''
//  external_library_dirs:          ''
//  form_postfix:                   True
//  format:                         'dolfin'
//  generate_dummy_tabulate_tensor: False
//  max_signature_length:           0
//  optimize:                       True
//  precision:                      None
//  quadrature_degree:              6
//  quadrature_rule:                None
//  representation:                 'auto'
//  split:                          True

#include "imt.h"

imt_finite_element_0::imt_finite_element_0() : ufc::finite_element()
{
    // Do nothing
}

imt_finite_element_0::~imt_finite_element_0()
{
    // Do nothing
}

const char * imt_finite_element_0::signature() const
{
    return "FiniteElement('Lagrange', triangle, 1)";
}

ufc::shape imt_finite_element_0::cell_shape() const
{
    return ufc::shape::triangle;
}

std::size_t imt_finite_element_0::topological_dimension() const
{
    return 2;
}

std::size_t imt_finite_element_0::geometric_dimension() const
{
    return 2;
}

std::size_t imt_finite_element_0::space_dimension() const
{
    return 3;
}

std::size_t imt_finite_element_0::value_rank() const
{
    return 0;
}

std::size_t imt_finite_element_0::value_dimension(std::size_t i) const
{
    return 1;
}

std::size_t imt_finite_element_0::value_size() const
{
    return 1;
}

std::size_t imt_finite_element_0::reference_value_rank() const
{
    return 0;
}

std::size_t imt_finite_element_0::reference_value_dimension(std::size_t i) const
{
    return 1;
}

std::size_t imt_finite_element_0::reference_value_size() const
{
    return 1;
}

std::size_t imt_finite_element_0::degree() const
{
    return 1;
}

const char * imt_finite_element_0::family() const
{
    return "Lagrange";
}

void imt_finite_element_0::evaluate_reference_basis(double * reference_values,
                                             std::size_t num_points,
                                             const double * X) const
{
    static const double coefficients0[1][3] = { { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients1[1][3] = { { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients2[1][3] = { { 0.4714045207910316, 0.0, 0.3333333333333333 } };
    for (std::size_t k = 0; k < num_points * 3; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[3] = {};
        basisvalues1[0] = 1.0;
        const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues1[1] = tmp1_1;
        basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
        basisvalues1[0] *= std::sqrt(0.5);
        basisvalues1[2] *= std::sqrt(1.0);
        basisvalues1[1] *= std::sqrt(3.0);
        // Accumulate products of coefficients and basisvalues
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[3 * ip] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[3 * ip + 1] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[3 * ip + 2] += coefficients2[0][r] * basisvalues1[r];
    }
}

void imt_finite_element_0::evaluate_reference_basis_derivatives(double * reference_values,
                                                         std::size_t order,
                                                         std::size_t num_points,
                                                         const double * X) const
{
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(2, order);
    std::fill_n(reference_values, num_points * 3 * num_derivatives, 0.0);
    if (order > 1)
        return;
    // Tables of derivatives of the polynomial base (transpose).
    alignas(32) static const double dmats0[2][3][3] =
        { { { 0.0, 0.0, 0.0 },
            { 4.8989794855663495, 0.0, 0.0 },
            { 0.0, 0.0, 0.0 } },
          { { 0.0, 0.0, 0.0 },
            { 2.449489742783182, 0.0, 0.0 },
            { 4.242640687119285, 0.0, 0.0 } } };
    static const double coefficients0[1][3] = { { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients1[1][3] = { { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients2[1][3] = { { 0.4714045207910316, 0.0, 0.3333333333333333 } };
    const std::size_t reference_offset[3] = {};
    const std::size_t num_components[3] = { 1, 1, 1 };
    // Precomputed combinations
    const std::size_t combinations[1][2][1] =
        { { { 0 },
            { 1 } } };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[3] = {};
        basisvalues1[0] = 1.0;
        const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues1[1] = tmp1_1;
        basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
        basisvalues1[0] *= std::sqrt(0.5);
        basisvalues1[2] *= std::sqrt(1.0);
        basisvalues1[1] *= std::sqrt(3.0);
        // Loop over all dofs
        for (std::size_t i = 0; i < 3; ++i)
        {
            double derivatives[2] = {};
            switch (i)
            {
            case 0:
                // Compute reference derivatives for dof 0.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 1:
                // Compute reference derivatives for dof 1.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 2:
                // Compute reference derivatives for dof 2.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            }
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t c = 0; c < num_components[i]; ++c)
                    reference_values[3 * num_derivatives * ip + num_derivatives * i + r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
        }
    }
}

void imt_finite_element_0::transform_reference_basis_derivatives(double * values,
                                                          std::size_t order,
                                                          std::size_t num_points,
                                                          const double * reference_values,
                                                          const double * X,
                                                          const double * J,
                                                          const double * detJ,
                                                          const double * K,
                                                          int cell_orientation) const
{
    const std::size_t num_derivatives = std::pow(2, order);
    // Precomputed combinations
    const std::size_t combinations[1][2][1] =
        { { { 0 },
            { 1 } } };
    std::fill_n(values, num_points * 3 * num_derivatives, 0.0);
    const std::size_t reference_offsets[3] = {};
    const std::size_t physical_offsets[3] = {};
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[2][2];
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                transform[r][s] = 1.0;
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                for (std::size_t k = 0; k < order; ++k)
                    transform[r][s] *= K[2 * 2 * ip + 2 * combinations[order - 1][s][k] + combinations[order - 1][r][k]];
        for (std::size_t d = 0; d < 3; ++d)
        {
            for (std::size_t s = 0; s < num_derivatives; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[3 * num_derivatives * ip + num_derivatives * d + s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < num_derivatives; ++r)
                        values[3 * num_derivatives * ip + num_derivatives * d + r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
}

void imt_finite_element_0::evaluate_basis(std::size_t i,
                                   double * values,
                                   const double * x,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    double X[2] = {};
    double J[4];
    double detJ;
    double K[4];
    if (cm)
    {
        cm->compute_reference_geometry(X, J, &detJ, K, 1, x, coordinate_dofs, cell_orientation);
    }
    else
    {
        compute_jacobian_triangle_2d(J, coordinate_dofs);
        compute_jacobian_inverse_triangle_2d(K, detJ, J);
        // Compute constants
        const double C0 = coordinate_dofs[2] + coordinate_dofs[4];
        const double C1 = coordinate_dofs[3] + coordinate_dofs[5];
        // Get coordinates and map to the reference (FIAT) element
        double Y[2] = { (J[1] * (C1 - 2.0 * x[1]) + J[3] * (2.0 * x[0] - C0)) / detJ, (J[0] * (2.0 * x[1] - C1) + J[2] * (C0 - 2.0 * x[0])) / detJ };
        // Map to FFC reference coordinate
        for (std::size_t k = 0; k < 2; ++k)
            X[k] = (Y[k] + 1.0) / 2.0;
    }
    // Evaluate basis on reference element
    double ref_values[3];
    evaluate_reference_basis(ref_values, 1, X);
    // Push forward
    double physical_values[3];
    transform_reference_basis_derivatives(physical_values, 0, 1, ref_values, X, J, &detJ, K, cell_orientation);
    for (std::size_t k = 0; k < 1; ++k)
        values[k] = physical_values[i + k];
}

void imt_finite_element_0::evaluate_basis_all(double * values,
                                       const double * x,
                                       const double * coordinate_dofs,
                                       int cell_orientation,
                                       const ufc::coordinate_mapping * cm
                                       ) const
{
    // Helper variable to hold value of a single dof.
    double dof_values = 0.0;
    // Loop dofs and call evaluate_basis
    for (std::size_t r = 0; r < 3; ++r)
    {
        evaluate_basis(r, &dof_values, x, coordinate_dofs, cell_orientation);
        values[r] = dof_values;
    }
}

void imt_finite_element_0::evaluate_basis_derivatives(std::size_t i,
                                               std::size_t n,
                                               double * values,
                                               const double * x,
                                               const double * coordinate_dofs,
                                               int cell_orientation,
                                               const ufc::coordinate_mapping * cm
                                               ) const
{
    std::size_t num_derivatives = std::pow(2, n);
    std::fill_n(values, num_derivatives, 0.0);
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
        return;
    }
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
        return;
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, coordinate_dofs);
    // Compute Inverse Jacobian and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    // Compute constants
    const double C0 = coordinate_dofs[2] + coordinate_dofs[4];
    const double C1 = coordinate_dofs[3] + coordinate_dofs[5];
    // Get coordinates and map to the reference (FIAT) element
    double Y[2] = { (J[1] * (C1 - 2.0 * x[1]) + J[3] * (2.0 * x[0] - C0)) / detJ, (J[0] * (2.0 * x[1] - C1) + J[2] * (C0 - 2.0 * x[0])) / detJ };
    // Precomputed combinations
    const std::size_t combinations[1][2][1] =
        { { { 0 },
            { 1 } } };
    // Declare transformation matrix
    double transform[2][2] =
        { { 1.0, 1.0 },
          { 1.0, 1.0 } };
    // Construct transformation matrix
    for (std::size_t row = 0; row < num_derivatives; ++row)
        for (std::size_t col = 0; col < num_derivatives; ++col)
            for (std::size_t k = 0; k < n; ++k)
                transform[row][col] *= K[2 * combinations[n - 1][col][k] + combinations[n - 1][row][k]];
    switch (i)
    {
    case 0:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 1:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 2:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, 0.0, 0.3333333333333333 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    }
}

void imt_finite_element_0::evaluate_basis_derivatives_all(std::size_t n,
                                                   double * values,
                                                   const double * x,
                                                   const double * coordinate_dofs,
                                                   int cell_orientation,
                                                   const ufc::coordinate_mapping * cm
                                                   ) const
{
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
        return;
    }
    unsigned int num_derivatives = std::pow(2, n);
    // Set values equal to zero.
    std::fill_n(values, num_derivatives * 3, 0.0);
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
        return;
    // Helper variable to hold values of a single dof.
    double dof_values[2] = {};
    // Loop dofs and call evaluate_basis_derivatives.
    for (std::size_t r = 0; r < 3; ++r)
    {
        evaluate_basis_derivatives(r, n, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < num_derivatives; ++s)
            values[num_derivatives * r + s] = dof_values[s];
    }
}

double imt_finite_element_0::evaluate_dof(std::size_t i,
                                   const ufc::function& f,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::cell& c,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 1:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 2:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    }
    return 0.0;
}

void imt_finite_element_0::evaluate_dofs(double * values,
                                  const ufc::function& f,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::cell& c,
                                  const ufc::coordinate_mapping * cm
                                  ) const
{
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[2];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
}

void imt_finite_element_0::interpolate_vertex_values(double * vertex_values,
                                              const double * dof_values,
                                              const double * coordinate_dofs,
                                              int cell_orientation,
                                              const ufc::coordinate_mapping * cm
                                              ) const
{
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
}

void imt_finite_element_0::tabulate_dof_coordinates(double * dof_coordinates,
                                             const double * coordinate_dofs,
                                             const ufc::coordinate_mapping * cm
                                             ) const
{
    dof_coordinates[0] = coordinate_dofs[0];
    dof_coordinates[1] = coordinate_dofs[1];
    dof_coordinates[2] = coordinate_dofs[2];
    dof_coordinates[2 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 2] = coordinate_dofs[4];
    dof_coordinates[2 * 2 + 1] = coordinate_dofs[5];
}

void imt_finite_element_0::tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const
{
    static const double dof_X[6] = { 0.0, 0.0, 1.0, 0.0, 0.0, 1.0 };
    std::copy_n(dof_X, 6, reference_dof_coordinates);
}

std::size_t imt_finite_element_0::num_sub_elements() const
{
    return 0;
}

ufc::finite_element * imt_finite_element_0::create_sub_element(std::size_t i) const
{
    return nullptr;
}

ufc::finite_element * imt_finite_element_0::create() const
{
    return new imt_finite_element_0();
}


imt_finite_element_1::imt_finite_element_1() : ufc::finite_element()
{
    // Do nothing
}

imt_finite_element_1::~imt_finite_element_1()
{
    // Do nothing
}

const char * imt_finite_element_1::signature() const
{
    return "VectorElement(FiniteElement('Lagrange', triangle, 1), dim=2)";
}

ufc::shape imt_finite_element_1::cell_shape() const
{
    return ufc::shape::triangle;
}

std::size_t imt_finite_element_1::topological_dimension() const
{
    return 2;
}

std::size_t imt_finite_element_1::geometric_dimension() const
{
    return 2;
}

std::size_t imt_finite_element_1::space_dimension() const
{
    return 6;
}

std::size_t imt_finite_element_1::value_rank() const
{
    return 1;
}

std::size_t imt_finite_element_1::value_dimension(std::size_t i) const
{
    static const int return_values[1] = { 2 };
    if (i >= 1)
        return 1;
    return return_values[i];
}

std::size_t imt_finite_element_1::value_size() const
{
    return 2;
}

std::size_t imt_finite_element_1::reference_value_rank() const
{
    return 1;
}

std::size_t imt_finite_element_1::reference_value_dimension(std::size_t i) const
{
    static const int return_values[1] = { 2 };
    if (i >= 1)
        return 1;
    return return_values[i];
}

std::size_t imt_finite_element_1::reference_value_size() const
{
    return 2;
}

std::size_t imt_finite_element_1::degree() const
{
    return 1;
}

const char * imt_finite_element_1::family() const
{
    return "Lagrange";
}

void imt_finite_element_1::evaluate_reference_basis(double * reference_values,
                                             std::size_t num_points,
                                             const double * X) const
{
    static const double coefficients0[1][3] = { { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients1[1][3] = { { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients2[1][3] = { { 0.4714045207910316, 0.0, 0.3333333333333333 } };
    for (std::size_t k = 0; k < num_points * 6 * 2; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[3] = {};
        basisvalues1[0] = 1.0;
        const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues1[1] = tmp1_1;
        basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
        basisvalues1[0] *= std::sqrt(0.5);
        basisvalues1[2] *= std::sqrt(1.0);
        basisvalues1[1] *= std::sqrt(3.0);
        // Accumulate products of coefficients and basisvalues
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[6 * 2 * ip] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[6 * 2 * ip + 2] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[6 * 2 * ip + 2 * 2] += coefficients2[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[6 * 2 * ip + 2 * 3 + 1] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[6 * 2 * ip + 2 * 4 + 1] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[6 * 2 * ip + 2 * 5 + 1] += coefficients2[0][r] * basisvalues1[r];
    }
}

void imt_finite_element_1::evaluate_reference_basis_derivatives(double * reference_values,
                                                         std::size_t order,
                                                         std::size_t num_points,
                                                         const double * X) const
{
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(2, order);
    std::fill_n(reference_values, num_points * 6 * num_derivatives * 2, 0.0);
    if (order > 1)
        return;
    // Tables of derivatives of the polynomial base (transpose).
    alignas(32) static const double dmats0[2][3][3] =
        { { { 0.0, 0.0, 0.0 },
            { 4.8989794855663495, 0.0, 0.0 },
            { 0.0, 0.0, 0.0 } },
          { { 0.0, 0.0, 0.0 },
            { 2.449489742783182, 0.0, 0.0 },
            { 4.242640687119285, 0.0, 0.0 } } };
    static const double coefficients0[1][3] = { { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients1[1][3] = { { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients2[1][3] = { { 0.4714045207910316, 0.0, 0.3333333333333333 } };
    const std::size_t reference_offset[6] = { 0, 0, 0, 1, 1, 1 };
    const std::size_t num_components[6] = { 1, 1, 1, 1, 1, 1 };
    // Precomputed combinations
    const std::size_t combinations[1][2][1] =
        { { { 0 },
            { 1 } } };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[3] = {};
        basisvalues1[0] = 1.0;
        const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues1[1] = tmp1_1;
        basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
        basisvalues1[0] *= std::sqrt(0.5);
        basisvalues1[2] *= std::sqrt(1.0);
        basisvalues1[1] *= std::sqrt(3.0);
        // Loop over all dofs
        for (std::size_t i = 0; i < 6; ++i)
        {
            double derivatives[2] = {};
            switch (i)
            {
            case 0:
                // Compute reference derivatives for dof 0.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 1:
                // Compute reference derivatives for dof 1.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 2:
                // Compute reference derivatives for dof 2.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 3:
                // Compute reference derivatives for dof 3.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 4:
                // Compute reference derivatives for dof 4.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 5:
                // Compute reference derivatives for dof 5.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            }
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t c = 0; c < num_components[i]; ++c)
                    reference_values[6 * (num_derivatives * 2) * ip + num_derivatives * 2 * i + 2 * r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
        }
    }
}

void imt_finite_element_1::transform_reference_basis_derivatives(double * values,
                                                          std::size_t order,
                                                          std::size_t num_points,
                                                          const double * reference_values,
                                                          const double * X,
                                                          const double * J,
                                                          const double * detJ,
                                                          const double * K,
                                                          int cell_orientation) const
{
    const std::size_t num_derivatives = std::pow(2, order);
    // Precomputed combinations
    const std::size_t combinations[1][2][1] =
        { { { 0 },
            { 1 } } };
    std::fill_n(values, num_points * 6 * num_derivatives * 2, 0.0);
    const std::size_t reference_offsets[6] = { 0, 0, 0, 1, 1, 1 };
    const std::size_t physical_offsets[6] = { 0, 0, 0, 1, 1, 1 };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[2][2];
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                transform[r][s] = 1.0;
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                for (std::size_t k = 0; k < order; ++k)
                    transform[r][s] *= K[2 * 2 * ip + 2 * combinations[order - 1][s][k] + combinations[order - 1][r][k]];
        for (std::size_t d = 0; d < 6; ++d)
        {
            for (std::size_t s = 0; s < num_derivatives; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[6 * (num_derivatives * 2) * ip + num_derivatives * 2 * d + 2 * s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < num_derivatives; ++r)
                        values[6 * (num_derivatives * 2) * ip + num_derivatives * 2 * d + 2 * r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
}

void imt_finite_element_1::evaluate_basis(std::size_t i,
                                   double * values,
                                   const double * x,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    double X[2] = {};
    double J[4];
    double detJ;
    double K[4];
    if (cm)
    {
        cm->compute_reference_geometry(X, J, &detJ, K, 1, x, coordinate_dofs, cell_orientation);
    }
    else
    {
        compute_jacobian_triangle_2d(J, coordinate_dofs);
        compute_jacobian_inverse_triangle_2d(K, detJ, J);
        // Compute constants
        const double C0 = coordinate_dofs[2] + coordinate_dofs[4];
        const double C1 = coordinate_dofs[3] + coordinate_dofs[5];
        // Get coordinates and map to the reference (FIAT) element
        double Y[2] = { (J[1] * (C1 - 2.0 * x[1]) + J[3] * (2.0 * x[0] - C0)) / detJ, (J[0] * (2.0 * x[1] - C1) + J[2] * (C0 - 2.0 * x[0])) / detJ };
        // Map to FFC reference coordinate
        for (std::size_t k = 0; k < 2; ++k)
            X[k] = (Y[k] + 1.0) / 2.0;
    }
    // Evaluate basis on reference element
    double ref_values[12];
    evaluate_reference_basis(ref_values, 1, X);
    // Push forward
    double physical_values[12];
    transform_reference_basis_derivatives(physical_values, 0, 1, ref_values, X, J, &detJ, K, cell_orientation);
    for (std::size_t k = 0; k < 2; ++k)
        values[k] = physical_values[2 * i + k];
}

void imt_finite_element_1::evaluate_basis_all(double * values,
                                       const double * x,
                                       const double * coordinate_dofs,
                                       int cell_orientation,
                                       const ufc::coordinate_mapping * cm
                                       ) const
{
    // Helper variable to hold values of a single dof.
    double dof_values[2] = {};
    // Loop dofs and call evaluate_basis
    for (std::size_t r = 0; r < 6; ++r)
    {
        evaluate_basis(r, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < 2; ++s)
            values[r * 2 + s] = dof_values[s];
    }
}

void imt_finite_element_1::evaluate_basis_derivatives(std::size_t i,
                                               std::size_t n,
                                               double * values,
                                               const double * x,
                                               const double * coordinate_dofs,
                                               int cell_orientation,
                                               const ufc::coordinate_mapping * cm
                                               ) const
{
    std::size_t num_derivatives = std::pow(2, n);
    std::fill_n(values, 2 * num_derivatives, 0.0);
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
        return;
    }
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
        return;
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, coordinate_dofs);
    // Compute Inverse Jacobian and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    // Compute constants
    const double C0 = coordinate_dofs[2] + coordinate_dofs[4];
    const double C1 = coordinate_dofs[3] + coordinate_dofs[5];
    // Get coordinates and map to the reference (FIAT) element
    double Y[2] = { (J[1] * (C1 - 2.0 * x[1]) + J[3] * (2.0 * x[0] - C0)) / detJ, (J[0] * (2.0 * x[1] - C1) + J[2] * (C0 - 2.0 * x[0])) / detJ };
    // Precomputed combinations
    const std::size_t combinations[1][2][1] =
        { { { 0 },
            { 1 } } };
    // Declare transformation matrix
    double transform[2][2] =
        { { 1.0, 1.0 },
          { 1.0, 1.0 } };
    // Construct transformation matrix
    for (std::size_t row = 0; row < num_derivatives; ++row)
        for (std::size_t col = 0; col < num_derivatives; ++col)
            for (std::size_t k = 0; k < n; ++k)
                transform[row][col] *= K[2 * combinations[n - 1][col][k] + combinations[n - 1][row][k]];
    switch (i)
    {
    case 0:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 1:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 2:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, 0.0, 0.3333333333333333 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 3:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 4:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 5:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, 0.0, 0.3333333333333333 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    }
}

void imt_finite_element_1::evaluate_basis_derivatives_all(std::size_t n,
                                                   double * values,
                                                   const double * x,
                                                   const double * coordinate_dofs,
                                                   int cell_orientation,
                                                   const ufc::coordinate_mapping * cm
                                                   ) const
{
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
        return;
    }
    unsigned int num_derivatives = std::pow(2, n);
    // Set values equal to zero.
    std::fill_n(values, 2 * num_derivatives * 6, 0.0);
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
        return;
    // Helper variable to hold values of a single dof.
    double dof_values[4] = {};
    // Loop dofs and call evaluate_basis_derivatives.
    for (std::size_t r = 0; r < 6; ++r)
    {
        evaluate_basis_derivatives(r, n, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < 2 * num_derivatives; ++s)
            values[2 * num_derivatives * r + s] = dof_values[s];
    }
}

double imt_finite_element_1::evaluate_dof(std::size_t i,
                                   const ufc::function& f,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::cell& c,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    // Declare variables for result of evaluation
    double vals[2];
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 1:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 2:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 3:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 4:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 5:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    }
    return 0.0;
}

void imt_finite_element_1::evaluate_dofs(double * values,
                                  const ufc::function& f,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::cell& c,
                                  const ufc::coordinate_mapping * cm
                                  ) const
{
    // Declare variables for result of evaluation
    double vals[2];
    // Declare variable for physical coordinates
    double y[2];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[3] = vals[1];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[4] = vals[1];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[5] = vals[1];
}

void imt_finite_element_1::interpolate_vertex_values(double * vertex_values,
                                              const double * dof_values,
                                              const double * coordinate_dofs,
                                              int cell_orientation,
                                              const ufc::coordinate_mapping * cm
                                              ) const
{
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[2] = dof_values[1];
    vertex_values[4] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[3];
    vertex_values[3] = dof_values[4];
    vertex_values[5] = dof_values[5];
}

void imt_finite_element_1::tabulate_dof_coordinates(double * dof_coordinates,
                                             const double * coordinate_dofs,
                                             const ufc::coordinate_mapping * cm
                                             ) const
{
    dof_coordinates[0] = coordinate_dofs[0];
    dof_coordinates[1] = coordinate_dofs[1];
    dof_coordinates[2] = coordinate_dofs[2];
    dof_coordinates[2 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 2] = coordinate_dofs[4];
    dof_coordinates[2 * 2 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 3] = coordinate_dofs[0];
    dof_coordinates[2 * 3 + 1] = coordinate_dofs[1];
    dof_coordinates[2 * 4] = coordinate_dofs[2];
    dof_coordinates[2 * 4 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 5] = coordinate_dofs[4];
    dof_coordinates[2 * 5 + 1] = coordinate_dofs[5];
}

void imt_finite_element_1::tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const
{
    static const double dof_X[12] = { 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0 };
    std::copy_n(dof_X, 12, reference_dof_coordinates);
}

std::size_t imt_finite_element_1::num_sub_elements() const
{
    return 2;
}

ufc::finite_element * imt_finite_element_1::create_sub_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new imt_finite_element_0();
    case 1:
        return new imt_finite_element_0();
    default:
        return nullptr;
    }
}

ufc::finite_element * imt_finite_element_1::create() const
{
    return new imt_finite_element_1();
}


imt_finite_element_2::imt_finite_element_2() : ufc::finite_element()
{
    // Do nothing
}

imt_finite_element_2::~imt_finite_element_2()
{
    // Do nothing
}

const char * imt_finite_element_2::signature() const
{
    return "FiniteElement('Real', triangle, 0)";
}

ufc::shape imt_finite_element_2::cell_shape() const
{
    return ufc::shape::triangle;
}

std::size_t imt_finite_element_2::topological_dimension() const
{
    return 2;
}

std::size_t imt_finite_element_2::geometric_dimension() const
{
    return 2;
}

std::size_t imt_finite_element_2::space_dimension() const
{
    return 1;
}

std::size_t imt_finite_element_2::value_rank() const
{
    return 0;
}

std::size_t imt_finite_element_2::value_dimension(std::size_t i) const
{
    return 1;
}

std::size_t imt_finite_element_2::value_size() const
{
    return 1;
}

std::size_t imt_finite_element_2::reference_value_rank() const
{
    return 0;
}

std::size_t imt_finite_element_2::reference_value_dimension(std::size_t i) const
{
    return 1;
}

std::size_t imt_finite_element_2::reference_value_size() const
{
    return 1;
}

std::size_t imt_finite_element_2::degree() const
{
    return 0;
}

const char * imt_finite_element_2::family() const
{
    return "Real";
}

void imt_finite_element_2::evaluate_reference_basis(double * reference_values,
                                             std::size_t num_points,
                                             const double * X) const
{
    static const double coefficients0[1][1] = { { 1.0 } };
    for (std::size_t k = 0; k < num_points; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Compute basisvalues for each relevant embedded degree
        double basisvalues0[1] = {};
        basisvalues0[0] = 1.0;
        // Accumulate products of coefficients and basisvalues
        reference_values[ip] += coefficients0[0][0] * basisvalues0[0];
    }
}

void imt_finite_element_2::evaluate_reference_basis_derivatives(double * reference_values,
                                                         std::size_t order,
                                                         std::size_t num_points,
                                                         const double * X) const
{
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(2, order);
    std::fill_n(reference_values, num_points * num_derivatives, 0.0);
    if (order > 0)
        return;
}

void imt_finite_element_2::transform_reference_basis_derivatives(double * values,
                                                          std::size_t order,
                                                          std::size_t num_points,
                                                          const double * reference_values,
                                                          const double * X,
                                                          const double * J,
                                                          const double * detJ,
                                                          const double * K,
                                                          int cell_orientation) const
{
    std::fill_n(values, num_points, 0.0);
    const std::size_t reference_offsets[1] = {};
    const std::size_t physical_offsets[1] = {};
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[1][1];
        for (std::size_t r = 0; r < 1; ++r)
            for (std::size_t s = 0; s < 1; ++s)
                transform[r][s] = 1.0;
        for (std::size_t d = 0; d < 1; ++d)
        {
            for (std::size_t s = 0; s < 1; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[ip + d + s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < 1; ++r)
                        values[ip + d + r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
}

void imt_finite_element_2::evaluate_basis(std::size_t i,
                                   double * values,
                                   const double * x,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    double X[2] = {};
    double J[4];
    double detJ;
    double K[4];
    if (cm)
    {
        cm->compute_reference_geometry(X, J, &detJ, K, 1, x, coordinate_dofs, cell_orientation);
    }
    else
    {
        compute_jacobian_triangle_2d(J, coordinate_dofs);
        compute_jacobian_inverse_triangle_2d(K, detJ, J);
    }
    // Evaluate basis on reference element
    double ref_values[1];
    evaluate_reference_basis(ref_values, 1, X);
    // Push forward
    double physical_values[1];
    transform_reference_basis_derivatives(physical_values, 0, 1, ref_values, X, J, &detJ, K, cell_orientation);
    for (std::size_t k = 0; k < 1; ++k)
        values[k] = physical_values[i + k];
}

void imt_finite_element_2::evaluate_basis_all(double * values,
                                       const double * x,
                                       const double * coordinate_dofs,
                                       int cell_orientation,
                                       const ufc::coordinate_mapping * cm
                                       ) const
{
    // Element is constant, calling evaluate_basis.
    evaluate_basis(0, values, x, coordinate_dofs, cell_orientation);
}

void imt_finite_element_2::evaluate_basis_derivatives(std::size_t i,
                                               std::size_t n,
                                               double * values,
                                               const double * x,
                                               const double * coordinate_dofs,
                                               int cell_orientation,
                                               const ufc::coordinate_mapping * cm
                                               ) const
{
    std::size_t num_derivatives = std::pow(2, n);
    std::fill_n(values, num_derivatives, 0.0);
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
        return;
    }
}

void imt_finite_element_2::evaluate_basis_derivatives_all(std::size_t n,
                                                   double * values,
                                                   const double * x,
                                                   const double * coordinate_dofs,
                                                   int cell_orientation,
                                                   const ufc::coordinate_mapping * cm
                                                   ) const
{
    // Element is constant, calling evaluate_basis_derivatives.
    evaluate_basis_derivatives(0, n, values, x, coordinate_dofs, cell_orientation);
}

double imt_finite_element_2::evaluate_dof(std::size_t i,
                                   const ufc::function& f,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::cell& c,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
        {
            y[0] = 0.3333333333333334 * coordinate_dofs[0] + 0.3333333333333333 * coordinate_dofs[2] + 0.3333333333333333 * coordinate_dofs[4];
            y[1] = 0.3333333333333334 * coordinate_dofs[1] + 0.3333333333333333 * coordinate_dofs[3] + 0.3333333333333333 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    }
    return 0.0;
}

void imt_finite_element_2::evaluate_dofs(double * values,
                                  const ufc::function& f,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::cell& c,
                                  const ufc::coordinate_mapping * cm
                                  ) const
{
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[2];
    y[0] = 0.3333333333333334 * coordinate_dofs[0] + 0.3333333333333333 * coordinate_dofs[2] + 0.3333333333333333 * coordinate_dofs[4];
    y[1] = 0.3333333333333334 * coordinate_dofs[1] + 0.3333333333333333 * coordinate_dofs[3] + 0.3333333333333333 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
}

void imt_finite_element_2::interpolate_vertex_values(double * vertex_values,
                                              const double * dof_values,
                                              const double * coordinate_dofs,
                                              int cell_orientation,
                                              const ufc::coordinate_mapping * cm
                                              ) const
{
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[0];
    vertex_values[2] = dof_values[0];
}

void imt_finite_element_2::tabulate_dof_coordinates(double * dof_coordinates,
                                             const double * coordinate_dofs,
                                             const ufc::coordinate_mapping * cm
                                             ) const
{
    dof_coordinates[0] = 0.3333333333333334 * coordinate_dofs[0] + 0.3333333333333333 * coordinate_dofs[2] + 0.3333333333333333 * coordinate_dofs[4];
    dof_coordinates[1] = 0.3333333333333334 * coordinate_dofs[1] + 0.3333333333333333 * coordinate_dofs[3] + 0.3333333333333333 * coordinate_dofs[5];
}

void imt_finite_element_2::tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const
{
    static const double dof_X[2] = { 0.3333333333333333, 0.3333333333333333 };
    std::copy_n(dof_X, 2, reference_dof_coordinates);
}

std::size_t imt_finite_element_2::num_sub_elements() const
{
    return 0;
}

ufc::finite_element * imt_finite_element_2::create_sub_element(std::size_t i) const
{
    return nullptr;
}

ufc::finite_element * imt_finite_element_2::create() const
{
    return new imt_finite_element_2();
}


imt_finite_element_3::imt_finite_element_3() : ufc::finite_element()
{
    // Do nothing
}

imt_finite_element_3::~imt_finite_element_3()
{
    // Do nothing
}

const char * imt_finite_element_3::signature() const
{
    return "MixedElement(FiniteElement('Lagrange', triangle, 1), FiniteElement('Lagrange', triangle, 1), FiniteElement('Lagrange', triangle, 1), FiniteElement('Lagrange', triangle, 1), FiniteElement('Lagrange', triangle, 1), FiniteElement('Lagrange', triangle, 1), FiniteElement('Real', triangle, 0))";
}

ufc::shape imt_finite_element_3::cell_shape() const
{
    return ufc::shape::triangle;
}

std::size_t imt_finite_element_3::topological_dimension() const
{
    return 2;
}

std::size_t imt_finite_element_3::geometric_dimension() const
{
    return 2;
}

std::size_t imt_finite_element_3::space_dimension() const
{
    return 19;
}

std::size_t imt_finite_element_3::value_rank() const
{
    return 1;
}

std::size_t imt_finite_element_3::value_dimension(std::size_t i) const
{
    static const int return_values[1] = { 7 };
    if (i >= 1)
        return 1;
    return return_values[i];
}

std::size_t imt_finite_element_3::value_size() const
{
    return 7;
}

std::size_t imt_finite_element_3::reference_value_rank() const
{
    return 1;
}

std::size_t imt_finite_element_3::reference_value_dimension(std::size_t i) const
{
    static const int return_values[1] = { 7 };
    if (i >= 1)
        return 1;
    return return_values[i];
}

std::size_t imt_finite_element_3::reference_value_size() const
{
    return 7;
}

std::size_t imt_finite_element_3::degree() const
{
    return 1;
}

const char * imt_finite_element_3::family() const
{
    return "Mixed";
}

void imt_finite_element_3::evaluate_reference_basis(double * reference_values,
                                             std::size_t num_points,
                                             const double * X) const
{
    static const double coefficients0[1][3] = { { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients1[1][3] = { { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients2[1][3] = { { 0.4714045207910316, 0.0, 0.3333333333333333 } };
    static const double coefficients18[1][1] = { { 1.0 } };
    for (std::size_t k = 0; k < num_points * 19 * 7; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[3] = {};
        basisvalues1[0] = 1.0;
        const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues1[1] = tmp1_1;
        basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
        basisvalues1[0] *= std::sqrt(0.5);
        basisvalues1[2] *= std::sqrt(1.0);
        basisvalues1[1] *= std::sqrt(3.0);
        double basisvalues0[1] = {};
        basisvalues0[0] = 1.0;
        // Accumulate products of coefficients and basisvalues
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[19 * 7 * ip] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[19 * 7 * ip + 7] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[19 * 7 * ip + 7 * 2] += coefficients2[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[19 * 7 * ip + 7 * 3 + 1] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[19 * 7 * ip + 7 * 4 + 1] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[19 * 7 * ip + 7 * 5 + 1] += coefficients2[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[19 * 7 * ip + 7 * 6 + 2] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[19 * 7 * ip + 7 * 7 + 2] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[19 * 7 * ip + 7 * 8 + 2] += coefficients2[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[19 * 7 * ip + 7 * 9 + 3] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[19 * 7 * ip + 7 * 10 + 3] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[19 * 7 * ip + 7 * 11 + 3] += coefficients2[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[19 * 7 * ip + 7 * 12 + 4] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[19 * 7 * ip + 7 * 13 + 4] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[19 * 7 * ip + 7 * 14 + 4] += coefficients2[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[19 * 7 * ip + 7 * 15 + 5] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[19 * 7 * ip + 7 * 16 + 5] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[19 * 7 * ip + 7 * 17 + 5] += coefficients2[0][r] * basisvalues1[r];
        reference_values[19 * 7 * ip + 7 * 18 + 6] += coefficients18[0][0] * basisvalues0[0];
    }
}

void imt_finite_element_3::evaluate_reference_basis_derivatives(double * reference_values,
                                                         std::size_t order,
                                                         std::size_t num_points,
                                                         const double * X) const
{
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(2, order);
    std::fill_n(reference_values, num_points * 19 * num_derivatives * 7, 0.0);
    if (order > 1)
        return;
    // Tables of derivatives of the polynomial base (transpose).
    alignas(32) static const double dmats0[2][3][3] =
        { { { 0.0, 0.0, 0.0 },
            { 4.8989794855663495, 0.0, 0.0 },
            { 0.0, 0.0, 0.0 } },
          { { 0.0, 0.0, 0.0 },
            { 2.449489742783182, 0.0, 0.0 },
            { 4.242640687119285, 0.0, 0.0 } } };
    alignas(32) static const double dmats18[2][1][1] = {};
    static const double coefficients0[1][3] = { { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients1[1][3] = { { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients2[1][3] = { { 0.4714045207910316, 0.0, 0.3333333333333333 } };
    static const double coefficients18[1][1] = { { 1.0 } };
    const std::size_t reference_offset[19] = { 0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6 };
    const std::size_t num_components[19] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
    // Precomputed combinations
    const std::size_t combinations[1][2][1] =
        { { { 0 },
            { 1 } } };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[3] = {};
        basisvalues1[0] = 1.0;
        const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues1[1] = tmp1_1;
        basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
        basisvalues1[0] *= std::sqrt(0.5);
        basisvalues1[2] *= std::sqrt(1.0);
        basisvalues1[1] *= std::sqrt(3.0);
        double basisvalues0[1] = {};
        basisvalues0[0] = 1.0;
        // Loop over all dofs
        for (std::size_t i = 0; i < 19; ++i)
        {
            double derivatives[2] = {};
            switch (i)
            {
            case 0:
                // Compute reference derivatives for dof 0.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 1:
                // Compute reference derivatives for dof 1.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 2:
                // Compute reference derivatives for dof 2.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 3:
                // Compute reference derivatives for dof 3.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 4:
                // Compute reference derivatives for dof 4.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 5:
                // Compute reference derivatives for dof 5.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 6:
                // Compute reference derivatives for dof 6.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 7:
                // Compute reference derivatives for dof 7.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 8:
                // Compute reference derivatives for dof 8.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 9:
                // Compute reference derivatives for dof 9.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 10:
                // Compute reference derivatives for dof 10.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 11:
                // Compute reference derivatives for dof 11.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 12:
                // Compute reference derivatives for dof 12.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 13:
                // Compute reference derivatives for dof 13.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 14:
                // Compute reference derivatives for dof 14.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 15:
                // Compute reference derivatives for dof 15.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 16:
                // Compute reference derivatives for dof 16.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 17:
                // Compute reference derivatives for dof 17.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 18:
                // Compute reference derivatives for dof 18.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[1] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[1][1] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats18[comb][0][0], 1, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[1][1];
                        std::copy_n(&dmats[0][0], 1, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 1, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 1; ++t)
                            for (std::size_t u = 0; u < 1; ++u)
                                for (std::size_t tu = 0; tu < 1; ++tu)
                                    dmats[t][u] += dmats18[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 1; ++s)
                        for (std::size_t t = 0; t < 1; ++t)
                            aux[s] += dmats[s][t] * basisvalues0[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 1; ++s)
                        derivatives[r] += coefficients18[0][s] * aux[s];
                }
                break;
            }
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t c = 0; c < num_components[i]; ++c)
                    reference_values[19 * (num_derivatives * 7) * ip + num_derivatives * 7 * i + 7 * r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
        }
    }
}

void imt_finite_element_3::transform_reference_basis_derivatives(double * values,
                                                          std::size_t order,
                                                          std::size_t num_points,
                                                          const double * reference_values,
                                                          const double * X,
                                                          const double * J,
                                                          const double * detJ,
                                                          const double * K,
                                                          int cell_orientation) const
{
    const std::size_t num_derivatives = std::pow(2, order);
    // Precomputed combinations
    const std::size_t combinations[1][2][1] =
        { { { 0 },
            { 1 } } };
    std::fill_n(values, num_points * 19 * num_derivatives * 7, 0.0);
    const std::size_t reference_offsets[19] = { 0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6 };
    const std::size_t physical_offsets[19] = { 0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6 };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[2][2];
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                transform[r][s] = 1.0;
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                for (std::size_t k = 0; k < order; ++k)
                    transform[r][s] *= K[2 * 2 * ip + 2 * combinations[order - 1][s][k] + combinations[order - 1][r][k]];
        for (std::size_t d = 0; d < 19; ++d)
        {
            for (std::size_t s = 0; s < num_derivatives; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[19 * (num_derivatives * 7) * ip + num_derivatives * 7 * d + 7 * s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < num_derivatives; ++r)
                        values[19 * (num_derivatives * 7) * ip + num_derivatives * 7 * d + 7 * r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
}

void imt_finite_element_3::evaluate_basis(std::size_t i,
                                   double * values,
                                   const double * x,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    double X[2] = {};
    double J[4];
    double detJ;
    double K[4];
    if (cm)
    {
        cm->compute_reference_geometry(X, J, &detJ, K, 1, x, coordinate_dofs, cell_orientation);
    }
    else
    {
        compute_jacobian_triangle_2d(J, coordinate_dofs);
        compute_jacobian_inverse_triangle_2d(K, detJ, J);
        // Compute constants
        const double C0 = coordinate_dofs[2] + coordinate_dofs[4];
        const double C1 = coordinate_dofs[3] + coordinate_dofs[5];
        // Get coordinates and map to the reference (FIAT) element
        double Y[2] = { (J[1] * (C1 - 2.0 * x[1]) + J[3] * (2.0 * x[0] - C0)) / detJ, (J[0] * (2.0 * x[1] - C1) + J[2] * (C0 - 2.0 * x[0])) / detJ };
        // Map to FFC reference coordinate
        for (std::size_t k = 0; k < 2; ++k)
            X[k] = (Y[k] + 1.0) / 2.0;
    }
    // Evaluate basis on reference element
    double ref_values[133];
    evaluate_reference_basis(ref_values, 1, X);
    // Push forward
    double physical_values[133];
    transform_reference_basis_derivatives(physical_values, 0, 1, ref_values, X, J, &detJ, K, cell_orientation);
    for (std::size_t k = 0; k < 7; ++k)
        values[k] = physical_values[7 * i + k];
}

void imt_finite_element_3::evaluate_basis_all(double * values,
                                       const double * x,
                                       const double * coordinate_dofs,
                                       int cell_orientation,
                                       const ufc::coordinate_mapping * cm
                                       ) const
{
    // Helper variable to hold values of a single dof.
    double dof_values[7] = {};
    // Loop dofs and call evaluate_basis
    for (std::size_t r = 0; r < 19; ++r)
    {
        evaluate_basis(r, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < 7; ++s)
            values[r * 7 + s] = dof_values[s];
    }
}

void imt_finite_element_3::evaluate_basis_derivatives(std::size_t i,
                                               std::size_t n,
                                               double * values,
                                               const double * x,
                                               const double * coordinate_dofs,
                                               int cell_orientation,
                                               const ufc::coordinate_mapping * cm
                                               ) const
{
    std::size_t num_derivatives = std::pow(2, n);
    std::fill_n(values, 7 * num_derivatives, 0.0);
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
        return;
    }
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
        return;
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, coordinate_dofs);
    // Compute Inverse Jacobian and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    // Compute constants
    const double C0 = coordinate_dofs[2] + coordinate_dofs[4];
    const double C1 = coordinate_dofs[3] + coordinate_dofs[5];
    // Get coordinates and map to the reference (FIAT) element
    double Y[2] = { (J[1] * (C1 - 2.0 * x[1]) + J[3] * (2.0 * x[0] - C0)) / detJ, (J[0] * (2.0 * x[1] - C1) + J[2] * (C0 - 2.0 * x[0])) / detJ };
    // Precomputed combinations
    const std::size_t combinations[1][2][1] =
        { { { 0 },
            { 1 } } };
    // Declare transformation matrix
    double transform[2][2] =
        { { 1.0, 1.0 },
          { 1.0, 1.0 } };
    // Construct transformation matrix
    for (std::size_t row = 0; row < num_derivatives; ++row)
        for (std::size_t col = 0; col < num_derivatives; ++col)
            for (std::size_t k = 0; k < n; ++k)
                transform[row][col] *= K[2 * combinations[n - 1][col][k] + combinations[n - 1][row][k]];
    switch (i)
    {
    case 0:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 1:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 2:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, 0.0, 0.3333333333333333 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 3:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 4:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 5:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, 0.0, 0.3333333333333333 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 6:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[2 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 7:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[2 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 8:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, 0.0, 0.3333333333333333 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[2 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 9:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[3 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 10:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[3 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 11:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, 0.0, 0.3333333333333333 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[3 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 12:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[4 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 13:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[4 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 14:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, 0.0, 0.3333333333333333 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[4 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 15:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[5 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 16:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[5 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 17:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, 0.0, 0.3333333333333333 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[5 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 18:
        {
            double basisvalues[1] = {};
            basisvalues[0] = 1.0;
            // Table(s) of coefficients
            static const double coefficients0[1] = { 1.0 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[1][1] = {};
            static const double dmats1[1][1] = {};
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[1][1] = { { 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[1][1] = { { 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 1, 0.0);
                for (std::size_t t = 0; t < 1; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 1, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 1, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 1; ++t)
                            for (std::size_t u = 0; u < 1; ++u)
                                for (std::size_t tu = 0; tu < 1; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 1; ++t)
                            for (std::size_t u = 0; u < 1; ++u)
                                for (std::size_t tu = 0; tu < 1; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 1; ++s)
                    for (std::size_t t = 0; t < 1; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[6 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    }
}

void imt_finite_element_3::evaluate_basis_derivatives_all(std::size_t n,
                                                   double * values,
                                                   const double * x,
                                                   const double * coordinate_dofs,
                                                   int cell_orientation,
                                                   const ufc::coordinate_mapping * cm
                                                   ) const
{
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
        return;
    }
    unsigned int num_derivatives = std::pow(2, n);
    // Set values equal to zero.
    std::fill_n(values, 7 * num_derivatives * 19, 0.0);
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
        return;
    // Helper variable to hold values of a single dof.
    double dof_values[14] = {};
    // Loop dofs and call evaluate_basis_derivatives.
    for (std::size_t r = 0; r < 19; ++r)
    {
        evaluate_basis_derivatives(r, n, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < 7 * num_derivatives; ++s)
            values[7 * num_derivatives * r + s] = dof_values[s];
    }
}

double imt_finite_element_3::evaluate_dof(std::size_t i,
                                   const ufc::function& f,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::cell& c,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    // Declare variables for result of evaluation
    double vals[7];
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 1:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 2:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 3:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 4:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 5:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 6:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 7:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 8:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 9:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[3];
        }
        break;
    case 10:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[3];
        }
        break;
    case 11:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[3];
        }
        break;
    case 12:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[4];
        }
        break;
    case 13:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[4];
        }
        break;
    case 14:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[4];
        }
        break;
    case 15:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[5];
        }
        break;
    case 16:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[5];
        }
        break;
    case 17:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[5];
        }
        break;
    case 18:
        {
            y[0] = 0.3333333333333334 * coordinate_dofs[0] + 0.3333333333333333 * coordinate_dofs[2] + 0.3333333333333333 * coordinate_dofs[4];
            y[1] = 0.3333333333333334 * coordinate_dofs[1] + 0.3333333333333333 * coordinate_dofs[3] + 0.3333333333333333 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[6];
        }
        break;
    }
    return 0.0;
}

void imt_finite_element_3::evaluate_dofs(double * values,
                                  const ufc::function& f,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::cell& c,
                                  const ufc::coordinate_mapping * cm
                                  ) const
{
    // Declare variables for result of evaluation
    double vals[7];
    // Declare variable for physical coordinates
    double y[2];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[3] = vals[1];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[4] = vals[1];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[5] = vals[1];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[6] = vals[2];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[7] = vals[2];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[8] = vals[2];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[9] = vals[3];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[10] = vals[3];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[11] = vals[3];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[12] = vals[4];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[13] = vals[4];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[14] = vals[4];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[15] = vals[5];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[16] = vals[5];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[17] = vals[5];
    y[0] = 0.3333333333333334 * coordinate_dofs[0] + 0.3333333333333333 * coordinate_dofs[2] + 0.3333333333333333 * coordinate_dofs[4];
    y[1] = 0.3333333333333334 * coordinate_dofs[1] + 0.3333333333333333 * coordinate_dofs[3] + 0.3333333333333333 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[18] = vals[6];
}

void imt_finite_element_3::interpolate_vertex_values(double * vertex_values,
                                              const double * dof_values,
                                              const double * coordinate_dofs,
                                              int cell_orientation,
                                              const ufc::coordinate_mapping * cm
                                              ) const
{
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[7] = dof_values[1];
    vertex_values[14] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[3];
    vertex_values[8] = dof_values[4];
    vertex_values[15] = dof_values[5];
    // Evaluate function and change variables
    vertex_values[2] = dof_values[6];
    vertex_values[9] = dof_values[7];
    vertex_values[16] = dof_values[8];
    // Evaluate function and change variables
    vertex_values[3] = dof_values[9];
    vertex_values[10] = dof_values[10];
    vertex_values[17] = dof_values[11];
    // Evaluate function and change variables
    vertex_values[4] = dof_values[12];
    vertex_values[11] = dof_values[13];
    vertex_values[18] = dof_values[14];
    // Evaluate function and change variables
    vertex_values[5] = dof_values[15];
    vertex_values[12] = dof_values[16];
    vertex_values[19] = dof_values[17];
    // Evaluate function and change variables
    vertex_values[6] = dof_values[18];
    vertex_values[13] = dof_values[18];
    vertex_values[20] = dof_values[18];
}

void imt_finite_element_3::tabulate_dof_coordinates(double * dof_coordinates,
                                             const double * coordinate_dofs,
                                             const ufc::coordinate_mapping * cm
                                             ) const
{
    dof_coordinates[0] = coordinate_dofs[0];
    dof_coordinates[1] = coordinate_dofs[1];
    dof_coordinates[2] = coordinate_dofs[2];
    dof_coordinates[2 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 2] = coordinate_dofs[4];
    dof_coordinates[2 * 2 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 3] = coordinate_dofs[0];
    dof_coordinates[2 * 3 + 1] = coordinate_dofs[1];
    dof_coordinates[2 * 4] = coordinate_dofs[2];
    dof_coordinates[2 * 4 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 5] = coordinate_dofs[4];
    dof_coordinates[2 * 5 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 6] = coordinate_dofs[0];
    dof_coordinates[2 * 6 + 1] = coordinate_dofs[1];
    dof_coordinates[2 * 7] = coordinate_dofs[2];
    dof_coordinates[2 * 7 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 8] = coordinate_dofs[4];
    dof_coordinates[2 * 8 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 9] = coordinate_dofs[0];
    dof_coordinates[2 * 9 + 1] = coordinate_dofs[1];
    dof_coordinates[2 * 10] = coordinate_dofs[2];
    dof_coordinates[2 * 10 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 11] = coordinate_dofs[4];
    dof_coordinates[2 * 11 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 12] = coordinate_dofs[0];
    dof_coordinates[2 * 12 + 1] = coordinate_dofs[1];
    dof_coordinates[2 * 13] = coordinate_dofs[2];
    dof_coordinates[2 * 13 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 14] = coordinate_dofs[4];
    dof_coordinates[2 * 14 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 15] = coordinate_dofs[0];
    dof_coordinates[2 * 15 + 1] = coordinate_dofs[1];
    dof_coordinates[2 * 16] = coordinate_dofs[2];
    dof_coordinates[2 * 16 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 17] = coordinate_dofs[4];
    dof_coordinates[2 * 17 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 18] = 0.3333333333333334 * coordinate_dofs[0] + 0.3333333333333333 * coordinate_dofs[2] + 0.3333333333333333 * coordinate_dofs[4];
    dof_coordinates[2 * 18 + 1] = 0.3333333333333334 * coordinate_dofs[1] + 0.3333333333333333 * coordinate_dofs[3] + 0.3333333333333333 * coordinate_dofs[5];
}

void imt_finite_element_3::tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const
{
    static const double dof_X[38] = { 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.3333333333333333, 0.3333333333333333 };
    std::copy_n(dof_X, 38, reference_dof_coordinates);
}

std::size_t imt_finite_element_3::num_sub_elements() const
{
    return 7;
}

ufc::finite_element * imt_finite_element_3::create_sub_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new imt_finite_element_0();
    case 1:
        return new imt_finite_element_0();
    case 2:
        return new imt_finite_element_0();
    case 3:
        return new imt_finite_element_0();
    case 4:
        return new imt_finite_element_0();
    case 5:
        return new imt_finite_element_0();
    case 6:
        return new imt_finite_element_2();
    default:
        return nullptr;
    }
}

ufc::finite_element * imt_finite_element_3::create() const
{
    return new imt_finite_element_3();
}


imt_dofmap_0::imt_dofmap_0() : ufc::dofmap()
{
    // Do nothing
}

imt_dofmap_0::~imt_dofmap_0()
{
    // Do nothing
}

const char * imt_dofmap_0::signature() const
{
    return "FFC dofmap for FiniteElement('Lagrange', triangle, 1)";
}

bool imt_dofmap_0::needs_mesh_entities(std::size_t d) const
{
    static const bool return_values[3] = { true, false, false };
    if (d >= 3)
        return false;
    return return_values[d];
}

std::size_t imt_dofmap_0::topological_dimension() const
{
    return 2;
}

std::size_t imt_dofmap_0::global_dimension(const std::vector<std::size_t>&
                                            num_global_entities) const
{
    return num_global_entities[0];
}

std::size_t imt_dofmap_0::num_global_support_dofs() const
{
    return 0;
}

std::size_t imt_dofmap_0::num_element_support_dofs() const
{
    return 3;
}

std::size_t imt_dofmap_0::num_element_dofs() const
{
    return 3;
}

std::size_t imt_dofmap_0::num_facet_dofs() const
{
    return 2;
}

std::size_t imt_dofmap_0::num_entity_dofs(std::size_t d) const
{
    static const std::size_t return_values[3] = { 1, 0, 0 };
    if (d >= 3)
        return 0;
    return return_values[d];
}

std::size_t imt_dofmap_0::num_entity_closure_dofs(std::size_t d) const
{
    static const std::size_t return_values[3] = { 1, 2, 3 };
    if (d >= 3)
        return 0;
    return return_values[d];
}

void imt_dofmap_0::tabulate_dofs(std::size_t * dofs,
                                  const std::vector<std::size_t>& num_global_entities,
                                  const std::vector<std::vector<std::size_t>>& entity_indices) const
{
    dofs[0] = entity_indices[0][0];
    dofs[1] = entity_indices[0][1];
    dofs[2] = entity_indices[0][2];
}

void imt_dofmap_0::tabulate_facet_dofs(std::size_t * dofs,
                                        std::size_t facet) const
{
    switch (facet)
    {
    case 0:
        dofs[0] = 1;
        dofs[1] = 2;
        break;
    case 1:
        dofs[0] = 0;
        dofs[1] = 2;
        break;
    case 2:
        dofs[0] = 0;
        dofs[1] = 1;
        break;
    }
}

void imt_dofmap_0::tabulate_entity_dofs(std::size_t * dofs,
                                         std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        case 1:
            dofs[0] = 1;
            break;
        case 2:
            dofs[0] = 2;
            break;
        }
        break;
    }
}

void imt_dofmap_0::tabulate_entity_closure_dofs(std::size_t * dofs,
                                             std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        case 1:
            dofs[0] = 1;
            break;
        case 2:
            dofs[0] = 2;
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 1;
            dofs[1] = 2;
            break;
        case 1:
            dofs[0] = 0;
            dofs[1] = 2;
            break;
        case 2:
            dofs[0] = 0;
            dofs[1] = 1;
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            break;
        }
        break;
    }
}

std::size_t imt_dofmap_0::num_sub_dofmaps() const
{
    return 0;
}

ufc::dofmap * imt_dofmap_0::create_sub_dofmap(std::size_t i) const
{
    return nullptr;
}

ufc::dofmap * imt_dofmap_0::create() const
{
    return new imt_dofmap_0();
}


imt_dofmap_1::imt_dofmap_1() : ufc::dofmap()
{
    // Do nothing
}

imt_dofmap_1::~imt_dofmap_1()
{
    // Do nothing
}

const char * imt_dofmap_1::signature() const
{
    return "FFC dofmap for VectorElement(FiniteElement('Lagrange', triangle, 1), dim=2)";
}

bool imt_dofmap_1::needs_mesh_entities(std::size_t d) const
{
    static const bool return_values[3] = { true, false, false };
    if (d >= 3)
        return false;
    return return_values[d];
}

std::size_t imt_dofmap_1::topological_dimension() const
{
    return 2;
}

std::size_t imt_dofmap_1::global_dimension(const std::vector<std::size_t>&
                                            num_global_entities) const
{
    return 2 * num_global_entities[0];
}

std::size_t imt_dofmap_1::num_global_support_dofs() const
{
    return 0;
}

std::size_t imt_dofmap_1::num_element_support_dofs() const
{
    return 6;
}

std::size_t imt_dofmap_1::num_element_dofs() const
{
    return 6;
}

std::size_t imt_dofmap_1::num_facet_dofs() const
{
    return 4;
}

std::size_t imt_dofmap_1::num_entity_dofs(std::size_t d) const
{
    static const std::size_t return_values[3] = { 2, 0, 0 };
    if (d >= 3)
        return 0;
    return return_values[d];
}

std::size_t imt_dofmap_1::num_entity_closure_dofs(std::size_t d) const
{
    static const std::size_t return_values[3] = { 2, 4, 6 };
    if (d >= 3)
        return 0;
    return return_values[d];
}

void imt_dofmap_1::tabulate_dofs(std::size_t * dofs,
                                  const std::vector<std::size_t>& num_global_entities,
                                  const std::vector<std::vector<std::size_t>>& entity_indices) const
{
    std::size_t offset = 0;
    dofs[0] = offset + entity_indices[0][0];
    dofs[1] = offset + entity_indices[0][1];
    dofs[2] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[3] = offset + entity_indices[0][0];
    dofs[4] = offset + entity_indices[0][1];
    dofs[5] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
}

void imt_dofmap_1::tabulate_facet_dofs(std::size_t * dofs,
                                        std::size_t facet) const
{
    switch (facet)
    {
    case 0:
        dofs[0] = 1;
        dofs[1] = 2;
        dofs[2] = 4;
        dofs[3] = 5;
        break;
    case 1:
        dofs[0] = 0;
        dofs[1] = 2;
        dofs[2] = 3;
        dofs[3] = 5;
        break;
    case 2:
        dofs[0] = 0;
        dofs[1] = 1;
        dofs[2] = 3;
        dofs[3] = 4;
        break;
    }
}

void imt_dofmap_1::tabulate_entity_dofs(std::size_t * dofs,
                                         std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 3;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 4;
            break;
        case 2:
            dofs[0] = 2;
            dofs[1] = 5;
            break;
        }
        break;
    }
}

void imt_dofmap_1::tabulate_entity_closure_dofs(std::size_t * dofs,
                                             std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 3;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 4;
            break;
        case 2:
            dofs[0] = 2;
            dofs[1] = 5;
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 1;
            dofs[1] = 2;
            dofs[2] = 4;
            dofs[3] = 5;
            break;
        case 1:
            dofs[0] = 0;
            dofs[1] = 2;
            dofs[2] = 3;
            dofs[3] = 5;
            break;
        case 2:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 3;
            dofs[3] = 4;
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            dofs[4] = 4;
            dofs[5] = 5;
            break;
        }
        break;
    }
}

std::size_t imt_dofmap_1::num_sub_dofmaps() const
{
    return 2;
}

ufc::dofmap * imt_dofmap_1::create_sub_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new imt_dofmap_0();
    case 1:
        return new imt_dofmap_0();
    default:
        return nullptr;
    }
}

ufc::dofmap * imt_dofmap_1::create() const
{
    return new imt_dofmap_1();
}


imt_dofmap_2::imt_dofmap_2() : ufc::dofmap()
{
    // Do nothing
}

imt_dofmap_2::~imt_dofmap_2()
{
    // Do nothing
}

const char * imt_dofmap_2::signature() const
{
    return "FFC dofmap for FiniteElement('Real', triangle, 0)";
}

bool imt_dofmap_2::needs_mesh_entities(std::size_t d) const
{
    static const bool return_values[3] = {};
    if (d >= 3)
        return false;
    return return_values[d];
}

std::size_t imt_dofmap_2::topological_dimension() const
{
    return 2;
}

std::size_t imt_dofmap_2::global_dimension(const std::vector<std::size_t>&
                                            num_global_entities) const
{
    return 1;
}

std::size_t imt_dofmap_2::num_global_support_dofs() const
{
    return 1;
}

std::size_t imt_dofmap_2::num_element_support_dofs() const
{
    return 0;
}

std::size_t imt_dofmap_2::num_element_dofs() const
{
    return 1;
}

std::size_t imt_dofmap_2::num_facet_dofs() const
{
    return 0;
}

std::size_t imt_dofmap_2::num_entity_dofs(std::size_t d) const
{
    static const std::size_t return_values[3] = { 0, 0, 1 };
    if (d >= 3)
        return 0;
    return return_values[d];
}

std::size_t imt_dofmap_2::num_entity_closure_dofs(std::size_t d) const
{
    static const std::size_t return_values[3] = { 0, 0, 1 };
    if (d >= 3)
        return 0;
    return return_values[d];
}

void imt_dofmap_2::tabulate_dofs(std::size_t * dofs,
                                  const std::vector<std::size_t>& num_global_entities,
                                  const std::vector<std::vector<std::size_t>>& entity_indices) const
{
    dofs[0] = 0;
}

void imt_dofmap_2::tabulate_facet_dofs(std::size_t * dofs,
                                        std::size_t facet) const
{
    // Do nothing
}

void imt_dofmap_2::tabulate_entity_dofs(std::size_t * dofs,
                                         std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        }
        break;
    }
}

void imt_dofmap_2::tabulate_entity_closure_dofs(std::size_t * dofs,
                                             std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            break;
        case 1:
            break;
        case 2:
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            break;
        case 1:
            break;
        case 2:
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        }
        break;
    }
}

std::size_t imt_dofmap_2::num_sub_dofmaps() const
{
    return 0;
}

ufc::dofmap * imt_dofmap_2::create_sub_dofmap(std::size_t i) const
{
    return nullptr;
}

ufc::dofmap * imt_dofmap_2::create() const
{
    return new imt_dofmap_2();
}


imt_dofmap_3::imt_dofmap_3() : ufc::dofmap()
{
    // Do nothing
}

imt_dofmap_3::~imt_dofmap_3()
{
    // Do nothing
}

const char * imt_dofmap_3::signature() const
{
    return "FFC dofmap for MixedElement(FiniteElement('Lagrange', triangle, 1), FiniteElement('Lagrange', triangle, 1), FiniteElement('Lagrange', triangle, 1), FiniteElement('Lagrange', triangle, 1), FiniteElement('Lagrange', triangle, 1), FiniteElement('Lagrange', triangle, 1), FiniteElement('Real', triangle, 0))";
}

bool imt_dofmap_3::needs_mesh_entities(std::size_t d) const
{
    static const bool return_values[3] = { true, false, true };
    if (d >= 3)
        return false;
    return return_values[d];
}

std::size_t imt_dofmap_3::topological_dimension() const
{
    return 2;
}

std::size_t imt_dofmap_3::global_dimension(const std::vector<std::size_t>&
                                            num_global_entities) const
{
    return 6 * num_global_entities[0] + 1;
}

std::size_t imt_dofmap_3::num_global_support_dofs() const
{
    return 1;
}

std::size_t imt_dofmap_3::num_element_support_dofs() const
{
    return 18;
}

std::size_t imt_dofmap_3::num_element_dofs() const
{
    return 19;
}

std::size_t imt_dofmap_3::num_facet_dofs() const
{
    return 12;
}

std::size_t imt_dofmap_3::num_entity_dofs(std::size_t d) const
{
    static const std::size_t return_values[3] = { 6, 0, 1 };
    if (d >= 3)
        return 0;
    return return_values[d];
}

std::size_t imt_dofmap_3::num_entity_closure_dofs(std::size_t d) const
{
    static const std::size_t return_values[3] = { 6, 12, 19 };
    if (d >= 3)
        return 0;
    return return_values[d];
}

void imt_dofmap_3::tabulate_dofs(std::size_t * dofs,
                                  const std::vector<std::size_t>& num_global_entities,
                                  const std::vector<std::vector<std::size_t>>& entity_indices) const
{
    std::size_t offset = 0;
    dofs[0] = offset + entity_indices[0][0];
    dofs[1] = offset + entity_indices[0][1];
    dofs[2] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[3] = offset + entity_indices[0][0];
    dofs[4] = offset + entity_indices[0][1];
    dofs[5] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[6] = offset + entity_indices[0][0];
    dofs[7] = offset + entity_indices[0][1];
    dofs[8] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[9] = offset + entity_indices[0][0];
    dofs[10] = offset + entity_indices[0][1];
    dofs[11] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[12] = offset + entity_indices[0][0];
    dofs[13] = offset + entity_indices[0][1];
    dofs[14] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[15] = offset + entity_indices[0][0];
    dofs[16] = offset + entity_indices[0][1];
    dofs[17] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[18] = offset;
    offset += 1;
}

void imt_dofmap_3::tabulate_facet_dofs(std::size_t * dofs,
                                        std::size_t facet) const
{
    switch (facet)
    {
    case 0:
        dofs[0] = 1;
        dofs[1] = 2;
        dofs[2] = 4;
        dofs[3] = 5;
        dofs[4] = 7;
        dofs[5] = 8;
        dofs[6] = 10;
        dofs[7] = 11;
        dofs[8] = 13;
        dofs[9] = 14;
        dofs[10] = 16;
        dofs[11] = 17;
        break;
    case 1:
        dofs[0] = 0;
        dofs[1] = 2;
        dofs[2] = 3;
        dofs[3] = 5;
        dofs[4] = 6;
        dofs[5] = 8;
        dofs[6] = 9;
        dofs[7] = 11;
        dofs[8] = 12;
        dofs[9] = 14;
        dofs[10] = 15;
        dofs[11] = 17;
        break;
    case 2:
        dofs[0] = 0;
        dofs[1] = 1;
        dofs[2] = 3;
        dofs[3] = 4;
        dofs[4] = 6;
        dofs[5] = 7;
        dofs[6] = 9;
        dofs[7] = 10;
        dofs[8] = 12;
        dofs[9] = 13;
        dofs[10] = 15;
        dofs[11] = 16;
        break;
    }
}

void imt_dofmap_3::tabulate_entity_dofs(std::size_t * dofs,
                                         std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 3;
            dofs[2] = 6;
            dofs[3] = 9;
            dofs[4] = 12;
            dofs[5] = 15;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 4;
            dofs[2] = 7;
            dofs[3] = 10;
            dofs[4] = 13;
            dofs[5] = 16;
            break;
        case 2:
            dofs[0] = 2;
            dofs[1] = 5;
            dofs[2] = 8;
            dofs[3] = 11;
            dofs[4] = 14;
            dofs[5] = 17;
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 18;
            break;
        }
        break;
    }
}

void imt_dofmap_3::tabulate_entity_closure_dofs(std::size_t * dofs,
                                             std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 3;
            dofs[2] = 6;
            dofs[3] = 9;
            dofs[4] = 12;
            dofs[5] = 15;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 4;
            dofs[2] = 7;
            dofs[3] = 10;
            dofs[4] = 13;
            dofs[5] = 16;
            break;
        case 2:
            dofs[0] = 2;
            dofs[1] = 5;
            dofs[2] = 8;
            dofs[3] = 11;
            dofs[4] = 14;
            dofs[5] = 17;
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 1;
            dofs[1] = 2;
            dofs[2] = 4;
            dofs[3] = 5;
            dofs[4] = 7;
            dofs[5] = 8;
            dofs[6] = 10;
            dofs[7] = 11;
            dofs[8] = 13;
            dofs[9] = 14;
            dofs[10] = 16;
            dofs[11] = 17;
            break;
        case 1:
            dofs[0] = 0;
            dofs[1] = 2;
            dofs[2] = 3;
            dofs[3] = 5;
            dofs[4] = 6;
            dofs[5] = 8;
            dofs[6] = 9;
            dofs[7] = 11;
            dofs[8] = 12;
            dofs[9] = 14;
            dofs[10] = 15;
            dofs[11] = 17;
            break;
        case 2:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 3;
            dofs[3] = 4;
            dofs[4] = 6;
            dofs[5] = 7;
            dofs[6] = 9;
            dofs[7] = 10;
            dofs[8] = 12;
            dofs[9] = 13;
            dofs[10] = 15;
            dofs[11] = 16;
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            dofs[4] = 4;
            dofs[5] = 5;
            dofs[6] = 6;
            dofs[7] = 7;
            dofs[8] = 8;
            dofs[9] = 9;
            dofs[10] = 10;
            dofs[11] = 11;
            dofs[12] = 12;
            dofs[13] = 13;
            dofs[14] = 14;
            dofs[15] = 15;
            dofs[16] = 16;
            dofs[17] = 17;
            dofs[18] = 18;
            break;
        }
        break;
    }
}

std::size_t imt_dofmap_3::num_sub_dofmaps() const
{
    return 7;
}

ufc::dofmap * imt_dofmap_3::create_sub_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new imt_dofmap_0();
    case 1:
        return new imt_dofmap_0();
    case 2:
        return new imt_dofmap_0();
    case 3:
        return new imt_dofmap_0();
    case 4:
        return new imt_dofmap_0();
    case 5:
        return new imt_dofmap_0();
    case 6:
        return new imt_dofmap_2();
    default:
        return nullptr;
    }
}

ufc::dofmap * imt_dofmap_3::create() const
{
    return new imt_dofmap_3();
}


imt_coordinate_mapping_1::imt_coordinate_mapping_1() : ufc::coordinate_mapping()
{
    // Do nothing
}

imt_coordinate_mapping_1::~imt_coordinate_mapping_1()
{
    // Do nothing
}

const char * imt_coordinate_mapping_1::signature() const
{
    return "FFC coordinate_mapping from VectorElement(FiniteElement('Lagrange', triangle, 1), dim=2)";
}

ufc::coordinate_mapping * imt_coordinate_mapping_1::create() const
{
    return new imt_coordinate_mapping_1();
}

std::size_t imt_coordinate_mapping_1::geometric_dimension() const
{
    return 2;
}

std::size_t imt_coordinate_mapping_1::topological_dimension() const
{
    return 2;
}

ufc::shape imt_coordinate_mapping_1::cell_shape() const
{
    return ufc::shape::triangle;
}

ufc::finite_element * imt_coordinate_mapping_1::create_coordinate_finite_element() const
{
    return new imt_finite_element_1();
}

ufc::dofmap * imt_coordinate_mapping_1::create_coordinate_dofmap() const
{
    return new imt_dofmap_1();
}

void imt_coordinate_mapping_1::compute_physical_coordinates(
    double * x, std::size_t num_points,
    const double * X,
    const double * coordinate_dofs) const
{
    imt_finite_element_0 xelement;
    double phi[3];
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Compute basis values of coordinate element
        xelement.evaluate_reference_basis(phi, 1, &X[2 * ip]);
        // Compute x
        for (std::size_t i = 0; i < 2; ++i)
            for (std::size_t d = 0; d < 3; ++d)
                x[2 * ip + i] += coordinate_dofs[2 * d + i] * phi[d];
    }
}

void imt_coordinate_mapping_1::compute_reference_coordinates(
    double * X, std::size_t num_points,
    const double * x,
    const double * coordinate_dofs, int cell_orientation) const
{
    const double phi_X0[3] = { 1.0, 0.0, 0.0 };
    const double dphi_X0[2][3] =
        { { -1.0, 1.0, 0.0 },
          { -1.0, 0.0, 1.0 } };
    double J[4];
    double detJ[1];
    double K[4];
    double x0[2] = {};
    for (std::size_t i = 0; i < 2; ++i)
        for (std::size_t k = 0; k < 3; ++k)
            x0[i] += coordinate_dofs[2 * k + i] * phi_X0[k];
    for (std::size_t i = 0; i < 2; ++i)
    {
        for (std::size_t j = 0; j < 2; ++j)
        {
            J[2 * i + j] = 0.0;
            for (std::size_t k = 0; k < 3; ++k)
                J[2 * i + j] += coordinate_dofs[2 * k + i] * dphi_X0[j][k];
        }
    }
    compute_jacobian_determinants(detJ, 1, J, cell_orientation);
    compute_jacobian_inverses(K, 1, J, detJ);
    for (std::size_t ip = 0; ip < num_points; ++ip)
        for (std::size_t j = 0; j < 2; ++j)
            for (std::size_t i = 0; i < 2; ++i)
                X[2 * ip + j] += K[2 * j + i] * (x[2 * ip + i] - x0[i]);
}

void imt_coordinate_mapping_1::compute_reference_geometry(
    double * X, double * J, double * detJ, double * K, std::size_t num_points,
    const double * x,
    const double * coordinate_dofs, int cell_orientation) const
{
    const double phi_X0[3] = { 1.0, 0.0, 0.0 };
    const double dphi_X0[2][3] =
        { { -1.0, 1.0, 0.0 },
          { -1.0, 0.0, 1.0 } };
    double x0[2] = {};
    for (std::size_t i = 0; i < 2; ++i)
        for (std::size_t k = 0; k < 3; ++k)
            x0[i] += coordinate_dofs[2 * k + i] * phi_X0[k];
    for (std::size_t i = 0; i < 2; ++i)
    {
        for (std::size_t j = 0; j < 2; ++j)
        {
            J[2 * i + j] = 0.0;
            for (std::size_t k = 0; k < 3; ++k)
                J[2 * i + j] += coordinate_dofs[2 * k + i] * dphi_X0[j][k];
        }
    }
    compute_jacobian_determinants(detJ, 1, J, cell_orientation);
    compute_jacobian_inverses(K, 1, J, detJ);
    for (std::size_t ip = 0; ip < num_points; ++ip)
        for (std::size_t j = 0; j < 2; ++j)
            for (std::size_t i = 0; i < 2; ++i)
                X[2 * ip + j] += K[2 * j + i] * (x[2 * ip + i] - x0[i]);
}

void imt_coordinate_mapping_1::compute_jacobians(
    double * J, std::size_t num_points,
    const double * X,
    const double * coordinate_dofs) const
{
    imt_finite_element_0 xelement;
    double dphi[6];
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Compute basis derivatives of coordinate element
        xelement.evaluate_reference_basis_derivatives(dphi, 1, 1, &X[2 * ip]);
        // Compute J
        for (std::size_t i = 0; i < 2; ++i)
            for (std::size_t j = 0; j < 2; ++j)
                for (std::size_t d = 0; d < 3; ++d)
                    J[2 * 2 * ip + 2 * i + j] += coordinate_dofs[2 * d + i] * dphi[2 * d + j];
    }
}

void imt_coordinate_mapping_1::compute_jacobian_determinants(
    double * detJ, std::size_t num_points,
    const double * J,
    int cell_orientation) const
{
    for (std::size_t ip = 0; ip < num_points; ++ip)
        detJ[ip] = J[2 * 2 * ip] * J[2 * 2 * ip + 2 + 1] - J[2 * 2 * ip + 1] * J[2 * 2 * ip + 2];
}

void imt_coordinate_mapping_1::compute_jacobian_inverses(
    double * K, std::size_t num_points,
    const double * J, const double * detJ) const
{
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        K[2 * 2 * ip] = J[2 * 2 * ip + 2 + 1] / detJ[ip];
        K[2 * 2 * ip + 1] = -J[2 * 2 * ip + 1] / detJ[ip];
        K[2 * 2 * ip + 2] = -J[2 * 2 * ip + 2] / detJ[ip];
        K[2 * 2 * ip + 2 + 1] = J[2 * 2 * ip] / detJ[ip];
    }
}

void imt_coordinate_mapping_1::compute_geometry(
    double * x, double * J, double * detJ, double * K, std::size_t num_points,
    const double * X,
    const double * coordinate_dofs, int cell_orientation) const
{
    compute_physical_coordinates(x, num_points, X, coordinate_dofs);
    compute_jacobians(J, num_points, X, coordinate_dofs);
    compute_jacobian_determinants(detJ, num_points, J, cell_orientation);
    compute_jacobian_inverses(K, num_points, J, detJ);
}

void imt_coordinate_mapping_1::compute_midpoint_geometry(
    double * x, double * J,
    const double * coordinate_dofs) const
{
    const double phi_Xm[3] = { 0.33333333333333337, 0.33333333333333337, 0.3333333333333333 };
    const double dphi_Xm[2][3] =
        { { -1.0, 1.0, 0.0 },
          { -1.0, 0.0, 1.0 } };
    // Compute x
    for (std::size_t i = 0; i < 2; ++i)
        for (std::size_t d = 0; d < 3; ++d)
            x[i] += coordinate_dofs[2 * d + i] * phi_Xm[d];
    // Compute J
    for (std::size_t i = 0; i < 2; ++i)
        for (std::size_t j = 0; j < 2; ++j)
            for (std::size_t d = 0; d < 3; ++d)
                J[2 * i + j] += coordinate_dofs[2 * d + i] * dphi_Xm[j][d];
}


imt_cell_integral_0_otherwise::imt_cell_integral_0_otherwise() : ufc::cell_integral()
{

}

imt_cell_integral_0_otherwise::~imt_cell_integral_0_otherwise()
{

}

const std::vector<bool> & imt_cell_integral_0_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, true, true, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false, false, false, true});
return enabled;
}

void imt_cell_integral_0_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 6
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 19
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           6
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Quadrature rules
    alignas(32) static const double weights12[12] = { 0.0254224531851035, 0.0254224531851035, 0.0254224531851035, 0.0583931378631895, 0.0583931378631895, 0.0583931378631895, 0.041425537809187, 0.041425537809187, 0.041425537809187, 0.041425537809187, 0.041425537809187, 0.041425537809187 };
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE3_C0_D01_Q12[1][1][2] = { { { -1.0, 1.0 } } };
    alignas(32) static const double FE3_C0_Q12[1][12][3] =
        { { { 0.06308901449150202, 0.873821971016996, 0.06308901449150202 },
            { 0.06308901449150207, 0.06308901449150207, 0.8738219710169959 },
            { 0.873821971016996, 0.06308901449150202, 0.06308901449150202 },
            { 0.249286745170911, 0.501426509658179, 0.24928674517091 },
            { 0.249286745170911, 0.24928674517091, 0.501426509658179 },
            { 0.50142650965818, 0.24928674517091, 0.24928674517091 },
            { 0.053145049844816, 0.636502499121399, 0.310352451033785 },
            { 0.310352451033785, 0.6365024991213991, 0.05314504984481597 },
            { 0.05314504984481604, 0.3103524510337851, 0.636502499121399 },
            { 0.6365024991213991, 0.310352451033785, 0.05314504984481597 },
            { 0.3103524510337851, 0.05314504984481604, 0.636502499121399 },
            { 0.636502499121399, 0.053145049844816, 0.310352451033785 } } };
    // Unstructured piecewise computations
    const double w0_d1_c5 = w[0][15] * FE3_C0_D01_Q12[0][0][0] + w[0][17] * FE3_C0_D01_Q12[0][0][1];
    const double J_c0 = coordinate_dofs[0] * FE3_C0_D01_Q12[0][0][0] + coordinate_dofs[2] * FE3_C0_D01_Q12[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE3_C0_D01_Q12[0][0][0] + coordinate_dofs[5] * FE3_C0_D01_Q12[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE3_C0_D01_Q12[0][0][0] + coordinate_dofs[4] * FE3_C0_D01_Q12[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE3_C0_D01_Q12[0][0][0] + coordinate_dofs[3] * FE3_C0_D01_Q12[0][0][1];
    double w0_d0_c5 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c5 += w[0][ic + 15] * FE3_C0_D01_Q12[0][0][ic];
    const double w0_d1_c2 = w[0][6] * FE3_C0_D01_Q12[0][0][0] + w[0][8] * FE3_C0_D01_Q12[0][0][1];
    double w0_d0_c2 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c2 += w[0][ic + 6] * FE3_C0_D01_Q12[0][0][ic];
    const double w0_d1_c1 = w[0][3] * FE3_C0_D01_Q12[0][0][0] + w[0][5] * FE3_C0_D01_Q12[0][0][1];
    double w0_d0_c1 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c1 += w[0][ic + 3] * FE3_C0_D01_Q12[0][0][ic];
    const double w0_d1_c4 = w[0][12] * FE3_C0_D01_Q12[0][0][0] + w[0][14] * FE3_C0_D01_Q12[0][0][1];
    double w0_d0_c4 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c4 += w[0][ic + 12] * FE3_C0_D01_Q12[0][0][ic];
    const double w0_d1_c3 = w[0][9] * FE3_C0_D01_Q12[0][0][0] + w[0][11] * FE3_C0_D01_Q12[0][0][1];
    double w0_d0_c3 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c3 += w[0][ic + 9] * FE3_C0_D01_Q12[0][0][ic];
    const double w0_d1_c0 = w[0][0] * FE3_C0_D01_Q12[0][0][0] + w[0][2] * FE3_C0_D01_Q12[0][0][1];
    double w0_d0_c0 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c0 += w[0][ic] * FE3_C0_D01_Q12[0][0][ic];
    alignas(32) double sp[92];
    sp[0] = J_c0 * J_c3;
    sp[1] = J_c1 * J_c2;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = J_c0 / sp[2];
    sp[4] = w0_d1_c5 * sp[3];
    sp[5] = -1 * J_c1 / sp[2];
    sp[6] = w0_d0_c5 * sp[5];
    sp[7] = sp[4] + sp[6];
    sp[8] = w0_d1_c2 * sp[3];
    sp[9] = w0_d0_c2 * sp[5];
    sp[10] = sp[8] + sp[9];
    sp[11] = w0_d1_c1 * sp[3];
    sp[12] = w0_d0_c1 * sp[5];
    sp[13] = sp[11] + sp[12];
    sp[14] = w0_d1_c4 * sp[3];
    sp[15] = w0_d0_c4 * sp[5];
    sp[16] = sp[14] + sp[15];
    sp[17] = sp[16] * w[6][0];
    sp[18] = w[26][0] / w[6][0];
    sp[19] = w0_d1_c3 * sp[3];
    sp[20] = w0_d0_c3 * sp[5];
    sp[21] = sp[19] + sp[20];
    sp[22] = w[28][0] / w[6][0];
    sp[23] = J_c3 / sp[2];
    sp[24] = w0_d0_c5 * sp[23];
    sp[25] = -1 * J_c2 / sp[2];
    sp[26] = w0_d1_c5 * sp[25];
    sp[27] = sp[24] + sp[26];
    sp[28] = w0_d0_c2 * sp[23];
    sp[29] = w0_d1_c2 * sp[25];
    sp[30] = sp[28] + sp[29];
    sp[31] = w0_d0_c1 * sp[23];
    sp[32] = w0_d1_c1 * sp[25];
    sp[33] = sp[31] + sp[32];
    sp[34] = w0_d0_c4 * sp[23];
    sp[35] = w0_d1_c4 * sp[25];
    sp[36] = sp[34] + sp[35];
    sp[37] = sp[36] * w[6][0];
    sp[38] = w[27][0] / w[6][0];
    sp[39] = w0_d0_c3 * sp[23];
    sp[40] = w0_d1_c3 * sp[25];
    sp[41] = sp[39] + sp[40];
    sp[42] = w[29][0] / w[6][0];
    sp[43] = w[34][0] / w[4][0];
    sp[44] = w[6][0] / w[31][0];
    sp[45] = w0_d1_c0 * sp[3];
    sp[46] = w0_d0_c0 * sp[5];
    sp[47] = sp[45] + sp[46];
    sp[48] = sp[47] * sp[3];
    sp[49] = sp[47] * sp[5];
    sp[50] = w0_d0_c0 * sp[23];
    sp[51] = w0_d1_c0 * sp[25];
    sp[52] = sp[50] + sp[51];
    sp[53] = sp[52] * sp[25];
    sp[54] = sp[52] * sp[23];
    sp[55] = sp[48] + sp[53];
    sp[56] = sp[54] + sp[49];
    sp[57] = w[20][0] * w[21][0];
    sp[58] = sp[55] * sp[57];
    sp[59] = sp[56] * sp[57];
    sp[60] = sp[13] * sp[3];
    sp[61] = sp[13] * sp[5];
    sp[62] = sp[33] * sp[25];
    sp[63] = sp[33] * sp[23];
    sp[64] = sp[60] + sp[62];
    sp[65] = sp[63] + sp[61];
    sp[66] = w[22][0] * w[23][0];
    sp[67] = sp[64] * sp[66];
    sp[68] = sp[65] * sp[66];
    sp[69] = sp[7] * sp[3];
    sp[70] = sp[7] * sp[5];
    sp[71] = sp[27] * sp[25];
    sp[72] = sp[27] * sp[23];
    sp[73] = sp[69] + sp[71];
    sp[74] = sp[72] + sp[70];
    sp[75] = sp[73] * w[33][0];
    sp[76] = sp[74] * w[33][0];
    sp[77] = sp[16] * sp[3];
    sp[78] = sp[16] * sp[5];
    sp[79] = sp[36] * sp[25];
    sp[80] = sp[36] * sp[23];
    sp[81] = sp[77] + sp[79];
    sp[82] = sp[80] + sp[78];
    sp[83] = std::abs(sp[2]);
    sp[84] = sp[58] * sp[83];
    sp[85] = sp[59] * sp[83];
    sp[86] = sp[67] * sp[83];
    sp[87] = sp[68] * sp[83];
    sp[88] = sp[75] * sp[83];
    sp[89] = sp[76] * sp[83];
    sp[90] = sp[81] * sp[83];
    sp[91] = sp[82] * sp[83];
    alignas(32) double BF0[3] = {};
    alignas(32) double BF1[3] = {};
    alignas(32) double BF2[2] = {};
    alignas(32) double BF3[3] = {};
    alignas(32) double BF4[2] = {};
    alignas(32) double BF5[2] = {};
    alignas(32) double BF6[3] = {};
    alignas(32) double BF7[2] = {};
    alignas(32) double BF8[3] = {};
    alignas(32) double BF9[3] = {};
    for (int iq = 0; iq < 12; ++iq)
    {
        // Quadrature loop body setup (num_points=12)
        // Unstructured varying computations for num_points=12
        double w0_c0 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c0 += w[0][ic] * FE3_C0_Q12[0][iq][ic];
        double w1_c0 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w1_c0 += w[1][ic] * FE3_C0_Q12[0][iq][ic];
        double w44 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w44 += w[44][ic] * FE3_C0_Q12[0][iq][ic];
        double w0_c1 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c1 += w[0][ic + 3] * FE3_C0_Q12[0][iq][ic];
        double w1_c1 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w1_c1 += w[1][ic + 3] * FE3_C0_Q12[0][iq][ic];
        double w0_c2 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c2 += w[0][ic + 6] * FE3_C0_Q12[0][iq][ic];
        double w0_c5 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c5 += w[0][ic + 15] * FE3_C0_Q12[0][iq][ic];
        double w0_c3 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c3 += w[0][ic + 9] * FE3_C0_Q12[0][iq][ic];
        double w1_c5 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w1_c5 += w[1][ic + 15] * FE3_C0_Q12[0][iq][ic];
        double w0_c4 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c4 += w[0][ic + 12] * FE3_C0_Q12[0][iq][ic];
        double w1_c2 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w1_c2 += w[1][ic + 6] * FE3_C0_Q12[0][iq][ic];
        double w1_c3 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w1_c3 += w[1][ic + 9] * FE3_C0_Q12[0][iq][ic];
        alignas(32) double sv12[192];
        sv12[0] = w0_c0 + -1 * w1_c0;
        sv12[1] = -1 * w[8][0] + -1 * w44;
        sv12[2] = sv12[1] * w[9][0];
        sv12[3] = sv12[2] / w[7][0];
        sv12[4] = w0_c0 * sv12[3];
        sv12[5] = std::pow(w0_c0, 3) * w[10][0];
        sv12[6] = sv12[4] + sv12[5];
        sv12[7] = std::pow(w0_c0, 5) * w[11][0];
        sv12[8] = sv12[6] + sv12[7];
        sv12[9] = w0_c1 * w[16][0];
        sv12[10] = sv12[8] + sv12[9];
        sv12[11] = w0_c0 * w[17][0];
        sv12[12] = sv12[11] * std::pow(w0_c1, 2);
        sv12[13] = sv12[10] + -1 * sv12[12];
        sv12[14] = 1.5 * w[18][0] * std::pow(w0_c0, 2);
        sv12[15] = w0_c1 * sv12[14];
        sv12[16] = sv12[13] + sv12[15];
        sv12[17] = sv12[0] * sv12[16];
        sv12[18] = sv12[17] / w[2][0];
        sv12[19] = w0_c1 + -1 * w1_c1;
        sv12[20] = -1 * w[12][0] + -1 * w44;
        sv12[21] = sv12[20] * w[13][0];
        sv12[22] = sv12[21] / w[7][0];
        sv12[23] = w0_c1 * sv12[22];
        sv12[24] = std::pow(w0_c1, 3) * w[14][0];
        sv12[25] = sv12[23] + sv12[24];
        sv12[26] = std::pow(w0_c1, 5) * w[15][0];
        sv12[27] = sv12[25] + sv12[26];
        sv12[28] = w0_c0 * w[16][0];
        sv12[29] = sv12[27] + sv12[28];
        sv12[30] = std::pow(w0_c0, 2) * w[17][0];
        sv12[31] = w0_c1 * sv12[30];
        sv12[32] = sv12[29] + -1 * sv12[31];
        sv12[33] = 0.5 * w[18][0] * std::pow(w0_c0, 3);
        sv12[34] = sv12[32] + sv12[33];
        sv12[35] = sv12[19] * sv12[34];
        sv12[36] = sv12[35] / w[2][0];
        sv12[37] = sv12[18] + sv12[36];
        sv12[38] = w0_c2 * w[5][0];
        sv12[39] = sp[7] * sv12[38];
        sv12[40] = w0_c5 * w[5][0];
        sv12[41] = sp[10] * sv12[40];
        sv12[42] = sv12[39] + sv12[41];
        sv12[43] = w0_c1 * w[19][0];
        sv12[44] = sp[13] * sv12[43];
        sv12[45] = sv12[42] + sv12[44];
        sv12[46] = sv12[45] + -1 * sp[17];
        sv12[47] = std::exp(-1 * w0_c2);
        sv12[48] = 1.32934038825 * std::pow(4 + std::pow(w0_c2, 2), -0.75) + sv12[47];
        sv12[49] = 1 / sv12[48] * w[24][0];
        sv12[50] = -1 * sv12[49] * sp[18];
        sv12[51] = sv12[46] * sv12[50];
        sv12[52] = w0_c3 * w[5][0];
        sv12[53] = sp[7] * sv12[52];
        sv12[54] = sp[21] * sv12[40];
        sv12[55] = sv12[53] + sv12[54];
        sv12[56] = sv12[55] + sv12[44];
        sv12[57] = sv12[56] + sp[17];
        sv12[58] = std::exp(-1 * w0_c3);
        sv12[59] = 1.32934038825 * std::pow(4 + std::pow(w0_c3, 2), -0.75) + sv12[58];
        sv12[60] = 1 / sv12[59] * w[25][0];
        sv12[61] = -1 * sv12[60] * sp[22];
        sv12[62] = sv12[57] * sv12[61];
        sv12[63] = -1 * sv12[51] + sv12[62];
        sv12[64] = sv12[49] * w[26][0];
        sv12[65] = sv12[60] * w[28][0];
        sv12[66] = sv12[64] + sv12[65];
        sv12[67] = std::pow(sv12[63], 2) / sv12[66];
        sv12[68] = sp[27] * sv12[38];
        sv12[69] = sp[30] * sv12[40];
        sv12[70] = sv12[68] + sv12[69];
        sv12[71] = sp[33] * sv12[43];
        sv12[72] = sv12[70] + sv12[71];
        sv12[73] = sv12[72] + -1 * sp[37];
        sv12[74] = -1 * sv12[49] * sp[38];
        sv12[75] = sv12[73] * sv12[74];
        sv12[76] = sp[27] * sv12[52];
        sv12[77] = sp[41] * sv12[40];
        sv12[78] = sv12[76] + sv12[77];
        sv12[79] = sv12[78] + sv12[71];
        sv12[80] = sv12[79] + sp[37];
        sv12[81] = -1 * sv12[60] * sp[42];
        sv12[82] = sv12[80] * sv12[81];
        sv12[83] = -1 * sv12[75] + sv12[82];
        sv12[84] = sv12[49] * w[27][0];
        sv12[85] = sv12[60] * w[29][0];
        sv12[86] = sv12[84] + sv12[85];
        sv12[87] = std::pow(sv12[83], 2) / sv12[86];
        sv12[88] = sv12[67] + sv12[87];
        sv12[89] = sv12[88] * w[6][0];
        sv12[90] = w0_c5 + -1 * w1_c5;
        sv12[91] = sv12[90] * w[32][0];
        sv12[92] = sv12[91] / w[2][0];
        sv12[93] = -1 * sv12[89] + sv12[92];
        sv12[94] = sv12[37] + sv12[93];
        sv12[95] = w0_c5 + -1 * w[36][0];
        sv12[96] = sv12[95] * sp[43];
        sv12[97] = sv12[94] + sv12[96];
        sv12[98] = w0_c5 + -1 * w[8][0];
        sv12[99] = sv12[98] + -1 * w44;
        sv12[100] = sv12[99] * w[9][0];
        sv12[101] = sv12[100] / w[7][0];
        sv12[102] = w0_c0 * sv12[101];
        sv12[103] = sv12[102] + sv12[5];
        sv12[104] = sv12[103] + sv12[7];
        sv12[105] = sv12[104] + sv12[9];
        sv12[106] = sv12[105] + -1 * sv12[12];
        sv12[107] = sv12[106] + sv12[15];
        sv12[108] = sv12[107] * (2.0 * w[20][0]);
        sv12[109] = sv12[0] / w[2][0];
        sv12[110] = sv12[108] + sv12[109];
        sv12[111] = w0_c5 + -1 * w[12][0];
        sv12[112] = sv12[111] + -1 * w44;
        sv12[113] = sv12[112] * w[13][0];
        sv12[114] = sv12[113] / w[7][0];
        sv12[115] = w0_c1 * sv12[114];
        sv12[116] = sv12[115] + sv12[24];
        sv12[117] = sv12[116] + sv12[26];
        sv12[118] = sv12[117] + sv12[28];
        sv12[119] = sv12[118] + -1 * sv12[31];
        sv12[120] = sv12[119] + sv12[33];
        sv12[121] = sv12[49] + sv12[60];
        sv12[122] = std::pow(w0_c1, 2) * w[19][0];
        sv12[123] = -1 * w[35][0] + sv12[122] / 2;
        sv12[124] = -1 * sv12[123] / sv12[40];
        sv12[125] = std::exp(-1 * sv12[124]);
        sv12[126] = 1.32934038825 * std::pow(4 + std::pow(sv12[124], 2), -0.75) + sv12[125];
        sv12[127] = 1 / sv12[126] * w[24][0];
        sv12[128] = sv12[121] + -1 * (2 * sv12[127]);
        sv12[129] = sv12[128] * sv12[43];
        sv12[130] = sv12[120] + sv12[129];
        sv12[131] = sv12[130] * (2.0 * w[22][0]);
        sv12[132] = sv12[19] / w[2][0];
        sv12[133] = sv12[131] + sv12[132];
        sv12[134] = sv12[49] * sv12[60];
        sv12[135] = w0_c4 * w[6][0];
        sv12[136] = -1 * sv12[135] + sv12[122] / 2;
        sv12[137] = sv12[136] + -1 * w[35][0];
        sv12[138] = -1 * sv12[137] / sv12[40];
        sv12[139] = std::exp(-1 * sv12[138]);
        sv12[140] = 1.32934038825 * std::pow(4 + std::pow(sv12[138], 2), -0.75) + sv12[139];
        sv12[141] = 1 / sv12[140] * w[24][0];
        sv12[142] = sv12[135] + sv12[122] / 2;
        sv12[143] = sv12[142] + w[35][0];
        sv12[144] = -1 * sv12[143] / sv12[40];
        sv12[145] = std::exp(-1 * sv12[144]);
        sv12[146] = 1.32934038825 * std::pow(4 + std::pow(sv12[144], 2), -0.75) + sv12[145];
        sv12[147] = 1 / sv12[146] * w[25][0];
        sv12[148] = sv12[141] * sv12[147];
        sv12[149] = -1 * sv12[134] + sv12[148];
        sv12[150] = std::pow(w0_c1, 2) * w[30][0];
        sv12[151] = sv12[149] * sv12[150];
        sv12[152] = w0_c2 + -1 * w1_c2;
        sv12[153] = w0_c2 * (1.994010582375 * std::pow(4 + std::pow(w0_c2, 2), -1.75));
        sv12[154] = sv12[153] + sv12[47];
        sv12[155] = sv12[154] * std::pow(1 / sv12[48], 2);
        sv12[156] = sv12[155] * w[24][0];
        sv12[157] = sv12[152] * sv12[156];
        sv12[158] = sv12[157] / w[2][0];
        sv12[159] = -1 * sv12[151] + sv12[158];
        sv12[160] = w0_c3 + -1 * w1_c3;
        sv12[161] = w0_c3 * (1.994010582375 * std::pow(4 + std::pow(w0_c3, 2), -1.75));
        sv12[162] = sv12[161] + sv12[58];
        sv12[163] = sv12[162] * std::pow(1 / sv12[59], 2);
        sv12[164] = sv12[163] * w[25][0];
        sv12[165] = sv12[160] * sv12[164];
        sv12[166] = sv12[165] / w[2][0];
        sv12[167] = -1 * sv12[151] + sv12[166];
        sv12[168] = -1 * sv12[49] + sv12[60];
        sv12[169] = sv12[168] * sp[44];
        sv12[170] = sv12[51] * sp[3];
        sv12[171] = sv12[51] * sp[5];
        sv12[172] = sv12[75] * sp[25];
        sv12[173] = sv12[75] * sp[23];
        sv12[174] = sv12[170] + sv12[172];
        sv12[175] = sv12[173] + sv12[171];
        sv12[176] = sv12[62] * sp[3];
        sv12[177] = sv12[62] * sp[5];
        sv12[178] = sv12[82] * sp[25];
        sv12[179] = sv12[82] * sp[23];
        sv12[180] = sv12[176] + sv12[178];
        sv12[181] = sv12[179] + sv12[177];
        sv12[182] = sv12[97] * sp[83];
        sv12[183] = sv12[110] * sp[83];
        sv12[184] = sv12[133] * sp[83];
        sv12[185] = sv12[159] * sp[83];
        sv12[186] = sv12[167] * sp[83];
        sv12[187] = -1 * sv12[169] * sp[83];
        sv12[188] = -1 * sv12[174] * sp[83];
        sv12[189] = -1 * sv12[175] * sp[83];
        sv12[190] = -1 * sv12[180] * sp[83];
        sv12[191] = -1 * sv12[181] * sp[83];
        const double fw0 = sv12[183] * weights12[iq];
        for (int i = 0; i < 3; ++i)
            BF0[i] += fw0 * FE3_C0_Q12[0][iq][i];
        const double fw1 = sv12[184] * weights12[iq];
        for (int i = 0; i < 3; ++i)
            BF1[i] += fw1 * FE3_C0_Q12[0][iq][i];
        const double fw2 = sv12[189] * weights12[iq];
        for (int i = 0; i < 2; ++i)
            BF2[i] += fw2 * FE3_C0_D01_Q12[0][0][i];
        const double fw3 = sv12[185] * weights12[iq];
        for (int i = 0; i < 3; ++i)
            BF3[i] += fw3 * FE3_C0_Q12[0][iq][i];
        const double fw4 = sv12[188] * weights12[iq];
        for (int i = 0; i < 2; ++i)
            BF4[i] += fw4 * FE3_C0_D01_Q12[0][0][i];
        const double fw5 = sv12[191] * weights12[iq];
        for (int i = 0; i < 2; ++i)
            BF5[i] += fw5 * FE3_C0_D01_Q12[0][0][i];
        const double fw6 = sv12[186] * weights12[iq];
        for (int i = 0; i < 3; ++i)
            BF6[i] += fw6 * FE3_C0_Q12[0][iq][i];
        const double fw7 = sv12[190] * weights12[iq];
        for (int i = 0; i < 2; ++i)
            BF7[i] += fw7 * FE3_C0_D01_Q12[0][0][i];
        const double fw8 = sv12[187] * weights12[iq];
        for (int i = 0; i < 3; ++i)
            BF8[i] += fw8 * FE3_C0_Q12[0][iq][i];
        const double fw9 = sv12[182] * weights12[iq];
        for (int i = 0; i < 3; ++i)
            BF9[i] += fw9 * FE3_C0_Q12[0][iq][i];
    }
    A[0] = -0.5 * sp[85] + -0.5 * sp[84];
    A[1] = 0.5 * sp[85];
    A[2] = 0.5 * sp[84];
    A[3] = -0.5 * sp[87] + -0.5 * sp[86];
    A[4] = 0.5 * sp[87];
    A[5] = 0.5 * sp[86];
    std::fill(A + 6, A + 12, 0.0);
    A[12] = -0.5 * sp[91] + -0.5 * sp[90];
    A[13] = 0.5 * sp[91];
    A[14] = 0.5 * sp[90];
    A[15] = -0.5 * sp[89] + -0.5 * sp[88];
    A[16] = 0.5 * sp[89];
    A[17] = 0.5 * sp[88];
    A[18] = 0.0;
    static const int DM0[2] = { 6, 8 };
    static const int DM1[2] = { 9, 11 };
    for (int i = 0; i < 3; ++i)
        A[i] += BF0[i];
    for (int i = 0; i < 3; ++i)
        A[i + 3] += BF1[i];
    for (int i = 0; i < 2; ++i)
        A[i + 6] += BF2[i];
    for (int i = 0; i < 3; ++i)
        A[i + 6] += BF3[i];
    for (int i = 0; i < 2; ++i)
        A[DM0[i]] += BF4[i];
    for (int i = 0; i < 2; ++i)
        A[i + 9] += BF5[i];
    for (int i = 0; i < 3; ++i)
        A[i + 9] += BF6[i];
    for (int i = 0; i < 2; ++i)
        A[DM1[i]] += BF7[i];
    for (int i = 0; i < 3; ++i)
        A[i + 12] += BF8[i];
    for (int i = 0; i < 3; ++i)
        A[i + 15] += BF9[i];
}


imt_exterior_facet_integral_0_0::imt_exterior_facet_integral_0_0() : ufc::exterior_facet_integral()
{

}

imt_exterior_facet_integral_0_0::~imt_exterior_facet_integral_0_0()
{

}

const std::vector<bool> & imt_exterior_facet_integral_0_0::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, true, true, true, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, true, true, true, false, true, false, false, false, false, false, false, true, false, true, true, true, true, true, true, true, false});
return enabled;
}

void imt_exterior_facet_integral_0_0::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    std::size_t facet,
                                    int cell_orientation) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 6
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 6
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           6
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Quadrature rules
    alignas(32) static const double weights4[4] = { 0.1739274225687268, 0.3260725774312731, 0.3260725774312731, 0.1739274225687268 };
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE29_C0_D01_F_Q4[1][1][2] = { { { -1.0, 1.0 } } };
    alignas(32) static const double FE29_C0_F_Q4[3][4][3] =
        { { { 0.0, 0.9305681557970263, 0.06943184420297369 },
            { 0.0, 0.6699905217924281, 0.3300094782075718 },
            { 0.0, 0.3300094782075719, 0.6699905217924279 },
            { 0.0, 0.06943184420297382, 0.9305681557970262 } },
          { { 0.9305681557970263, 0.0, 0.06943184420297369 },
            { 0.6699905217924281, 0.0, 0.3300094782075718 },
            { 0.3300094782075719, 0.0, 0.669990521792428 },
            { 0.06943184420297382, 0.0, 0.9305681557970262 } },
          { { 0.9305681557970263, 0.06943184420297367, 0.0 },
            { 0.6699905217924281, 0.3300094782075718, 0.0 },
            { 0.3300094782075719, 0.6699905217924281, 0.0 },
            { 0.06943184420297374, 0.9305681557970263, 0.0 } } };
    // Unstructured piecewise computations
    const double w0_d1_c5 = w[0][15] * FE29_C0_D01_F_Q4[0][0][0] + w[0][17] * FE29_C0_D01_F_Q4[0][0][1];
    const double J_c0 = coordinate_dofs[0] * FE29_C0_D01_F_Q4[0][0][0] + coordinate_dofs[2] * FE29_C0_D01_F_Q4[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE29_C0_D01_F_Q4[0][0][0] + coordinate_dofs[5] * FE29_C0_D01_F_Q4[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE29_C0_D01_F_Q4[0][0][0] + coordinate_dofs[4] * FE29_C0_D01_F_Q4[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE29_C0_D01_F_Q4[0][0][0] + coordinate_dofs[3] * FE29_C0_D01_F_Q4[0][0][1];
    double w0_d0_c5 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c5 += w[0][ic + 15] * FE29_C0_D01_F_Q4[0][0][ic];
    const double w0_d1_c2 = w[0][6] * FE29_C0_D01_F_Q4[0][0][0] + w[0][8] * FE29_C0_D01_F_Q4[0][0][1];
    double w0_d0_c2 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c2 += w[0][ic + 6] * FE29_C0_D01_F_Q4[0][0][ic];
    const double w0_d1_c1 = w[0][3] * FE29_C0_D01_F_Q4[0][0][0] + w[0][5] * FE29_C0_D01_F_Q4[0][0][1];
    double w0_d0_c1 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c1 += w[0][ic + 3] * FE29_C0_D01_F_Q4[0][0][ic];
    const double w0_d1_c4 = w[0][12] * FE29_C0_D01_F_Q4[0][0][0] + w[0][14] * FE29_C0_D01_F_Q4[0][0][1];
    double w0_d0_c4 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c4 += w[0][ic + 12] * FE29_C0_D01_F_Q4[0][0][ic];
    const double w0_d1_c3 = w[0][9] * FE29_C0_D01_F_Q4[0][0][0] + w[0][11] * FE29_C0_D01_F_Q4[0][0][1];
    double w0_d0_c3 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c3 += w[0][ic + 9] * FE29_C0_D01_F_Q4[0][0][ic];
    alignas(32) double sp[40];
    sp[0] = J_c0 * J_c3;
    sp[1] = J_c1 * J_c2;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = J_c0 / sp[2];
    sp[4] = w0_d1_c5 * sp[3];
    sp[5] = -1 * J_c1 / sp[2];
    sp[6] = w0_d0_c5 * sp[5];
    sp[7] = sp[4] + sp[6];
    sp[8] = w0_d1_c2 * sp[3];
    sp[9] = w0_d0_c2 * sp[5];
    sp[10] = sp[8] + sp[9];
    sp[11] = w0_d1_c1 * sp[3];
    sp[12] = w0_d0_c1 * sp[5];
    sp[13] = sp[11] + sp[12];
    sp[14] = w0_d1_c4 * sp[3];
    sp[15] = w0_d0_c4 * sp[5];
    sp[16] = sp[14] + sp[15];
    sp[17] = sp[16] * w[6][0];
    sp[18] = w[26][0] / w[6][0];
    sp[19] = w0_d1_c3 * sp[3];
    sp[20] = w0_d0_c3 * sp[5];
    sp[21] = sp[19] + sp[20];
    sp[22] = w[28][0] / w[6][0];
    sp[23] = w[20][0] * w[21][0];
    sp[24] = sp[23] / w[42][0];
    sp[25] = w[22][0] * w[23][0];
    sp[26] = sp[25] / w[42][0];
    sp[27] = w[4][0] * w[38][0];
    sp[28] = w[0][18] * sp[27];
    sp[29] = w[38][0] * w[39][0];
    sp[30] = J_c0 * triangle_reference_facet_jacobian[facet][0][0];
    sp[31] = J_c1 * triangle_reference_facet_jacobian[facet][1][0];
    sp[32] = sp[30] + sp[31];
    sp[33] = sp[32] * sp[32];
    sp[34] = triangle_reference_facet_jacobian[facet][0][0] * J_c2;
    sp[35] = triangle_reference_facet_jacobian[facet][1][0] * J_c3;
    sp[36] = sp[34] + sp[35];
    sp[37] = sp[36] * sp[36];
    sp[38] = sp[33] + sp[37];
    sp[39] = std::sqrt(sp[38]);
    alignas(32) double BF0[3] = {};
    alignas(32) double BF1[3] = {};
    alignas(32) double BF2[3] = {};
    alignas(32) double BF3[3] = {};
    alignas(32) double BF4[3] = {};
    alignas(32) double BF5[1] = {};
    for (int iq = 0; iq < 4; ++iq)
    {
        // Quadrature loop body setup (num_points=4)
        // Unstructured varying computations for num_points=4
        double w0_c2 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c2 += w[0][ic + 6] * FE29_C0_F_Q4[facet][iq][ic];
        double w0_c5 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c5 += w[0][ic + 15] * FE29_C0_F_Q4[facet][iq][ic];
        double w0_c1 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c1 += w[0][ic + 3] * FE29_C0_F_Q4[facet][iq][ic];
        double w0_c3 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c3 += w[0][ic + 9] * FE29_C0_F_Q4[facet][iq][ic];
        double w0_c0 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c0 += w[0][ic] * FE29_C0_F_Q4[facet][iq][ic];
        double w0_c4 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c4 += w[0][ic + 12] * FE29_C0_F_Q4[facet][iq][ic];
        double w1_c4 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w1_c4 += w[1][ic + 12] * FE29_C0_F_Q4[facet][iq][ic];
        alignas(32) double sv4[55];
        sv4[0] = w0_c2 * w[5][0];
        sv4[1] = sp[7] * sv4[0];
        sv4[2] = w0_c5 * w[5][0];
        sv4[3] = sp[10] * sv4[2];
        sv4[4] = sv4[1] + sv4[3];
        sv4[5] = w0_c1 * w[19][0];
        sv4[6] = sp[13] * sv4[5];
        sv4[7] = sv4[4] + sv4[6];
        sv4[8] = sv4[7] + -1 * sp[17];
        sv4[9] = std::exp(-1 * w0_c2);
        sv4[10] = 1.32934038825 * std::pow(4 + std::pow(w0_c2, 2), -0.75) + sv4[9];
        sv4[11] = 1 / sv4[10] * w[24][0];
        sv4[12] = -1 * sv4[11] * sp[18];
        sv4[13] = sv4[8] * sv4[12];
        sv4[14] = w0_c3 * w[5][0];
        sv4[15] = sp[7] * sv4[14];
        sv4[16] = sp[21] * sv4[2];
        sv4[17] = sv4[15] + sv4[16];
        sv4[18] = sv4[17] + sv4[6];
        sv4[19] = sv4[18] + sp[17];
        sv4[20] = std::exp(-1 * w0_c3);
        sv4[21] = 1.32934038825 * std::pow(4 + std::pow(w0_c3, 2), -0.75) + sv4[20];
        sv4[22] = 1 / sv4[21] * w[25][0];
        sv4[23] = -1 * sv4[22] * sp[22];
        sv4[24] = sv4[19] * sv4[23];
        sv4[25] = -1 * sv4[13] + sv4[24];
        sv4[26] = sv4[25] * w[6][0];
        sv4[27] = sv4[26] * w[3][0];
        sv4[28] = w[0][18] + -1 * sv4[27];
        sv4[29] = -1 * w0_c0 + w[40][0];
        sv4[30] = sv4[29] * sp[24];
        sv4[31] = -1 * w0_c1 + w[41][0];
        sv4[32] = sv4[31] * sp[26];
        sv4[33] = w0_c5 * sv4[14];
        sv4[34] = std::pow(w0_c1, 2) * w[19][0];
        sv4[35] = sv4[33] + sv4[34] / 2;
        sv4[36] = sv4[35] + w[35][0];
        sv4[37] = sv4[36] * (-1.0 / w[43][0]);
        sv4[38] = w0_c5 * sv4[0];
        sv4[39] = sv4[38] + sv4[34] / 2;
        sv4[40] = sv4[39] + -1 * w[35][0];
        sv4[41] = sv4[40] * (-1.0 / w[43][0]);
        sv4[42] = w0_c4 + sp[28];
        sv4[43] = sv4[42] + -1 * w[37][0];
        sv4[44] = w0_c4 + -1 * w1_c4;
        sv4[45] = sv4[44] * sp[29];
        sv4[46] = sv4[45] / w[2][0];
        sv4[47] = sv4[43] + sv4[46];
        sv4[48] = sv4[47] * (-1.0 / w[43][0]);
        sv4[49] = sv4[28] * sp[39];
        sv4[50] = -1 * sv4[30] * sp[39];
        sv4[51] = -1 * sv4[32] * sp[39];
        sv4[52] = sv4[37] * sp[39];
        sv4[53] = sv4[41] * sp[39];
        sv4[54] = sv4[48] * sp[39];
        const double fw0 = sv4[50] * weights4[iq];
        for (int i = 0; i < 3; ++i)
            BF0[i] += fw0 * FE29_C0_F_Q4[facet][iq][i];
        const double fw1 = sv4[51] * weights4[iq];
        for (int i = 0; i < 3; ++i)
            BF1[i] += fw1 * FE29_C0_F_Q4[facet][iq][i];
        const double fw2 = sv4[53] * weights4[iq];
        for (int i = 0; i < 3; ++i)
            BF2[i] += fw2 * FE29_C0_F_Q4[facet][iq][i];
        const double fw3 = sv4[52] * weights4[iq];
        for (int i = 0; i < 3; ++i)
            BF3[i] += fw3 * FE29_C0_F_Q4[facet][iq][i];
        const double fw4 = sv4[54] * weights4[iq];
        for (int i = 0; i < 3; ++i)
            BF4[i] += fw4 * FE29_C0_F_Q4[facet][iq][i];
        const double fw5 = sv4[49] * weights4[iq];
        for (int i = 0; i < 1; ++i)
            BF5[i] += fw5;
    }
    std::fill(A, A + 19, 0.0);
    for (int i = 0; i < 3; ++i)
        A[i] += BF0[i];
    for (int i = 0; i < 3; ++i)
        A[i + 3] += BF1[i];
    for (int i = 0; i < 3; ++i)
        A[i + 6] += BF2[i];
    for (int i = 0; i < 3; ++i)
        A[i + 9] += BF3[i];
    for (int i = 0; i < 3; ++i)
        A[i + 12] += BF4[i];
    for (int i = 0; i < 1; ++i)
        A[i + 18] += BF5[i];
}


imt_exterior_facet_integral_0_1::imt_exterior_facet_integral_0_1() : ufc::exterior_facet_integral()
{

}

imt_exterior_facet_integral_0_1::~imt_exterior_facet_integral_0_1()
{

}

const std::vector<bool> & imt_exterior_facet_integral_0_1::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, false, false, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, false, false, false, false, false, false, false, false, false, false, false, true, false, false, false, false, true, true, true, true, false});
return enabled;
}

void imt_exterior_facet_integral_0_1::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    std::size_t facet,
                                    int cell_orientation) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 6
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 3
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           6
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Quadrature rules
    alignas(32) static const double weights4[4] = { 0.1739274225687268, 0.3260725774312731, 0.3260725774312731, 0.1739274225687268 };
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE14_C0_F_Q4[3][4][3] =
        { { { 0.0, 0.9305681557970263, 0.06943184420297369 },
            { 0.0, 0.6699905217924281, 0.3300094782075718 },
            { 0.0, 0.3300094782075719, 0.6699905217924279 },
            { 0.0, 0.06943184420297382, 0.9305681557970262 } },
          { { 0.9305681557970263, 0.0, 0.06943184420297369 },
            { 0.6699905217924281, 0.0, 0.3300094782075718 },
            { 0.3300094782075719, 0.0, 0.669990521792428 },
            { 0.06943184420297382, 0.0, 0.9305681557970262 } },
          { { 0.9305681557970263, 0.06943184420297367, 0.0 },
            { 0.6699905217924281, 0.3300094782075718, 0.0 },
            { 0.3300094782075719, 0.6699905217924281, 0.0 },
            { 0.06943184420297374, 0.9305681557970263, 0.0 } } };
    alignas(32) static const double FE3_C0_D01_F_Q4[1][1][2] = { { { -1.0, 1.0 } } };
    // Unstructured piecewise computations
    const double J_c0 = coordinate_dofs[0] * FE3_C0_D01_F_Q4[0][0][0] + coordinate_dofs[2] * FE3_C0_D01_F_Q4[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE3_C0_D01_F_Q4[0][0][0] + coordinate_dofs[4] * FE3_C0_D01_F_Q4[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE3_C0_D01_F_Q4[0][0][0] + coordinate_dofs[3] * FE3_C0_D01_F_Q4[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE3_C0_D01_F_Q4[0][0][0] + coordinate_dofs[5] * FE3_C0_D01_F_Q4[0][0][1];
    alignas(32) double sp[14];
    sp[0] = w[20][0] * w[21][0];
    sp[1] = sp[0] / w[42][0];
    sp[2] = w[22][0] * w[23][0];
    sp[3] = sp[2] / w[42][0];
    sp[4] = J_c0 * triangle_reference_facet_jacobian[facet][0][0];
    sp[5] = J_c1 * triangle_reference_facet_jacobian[facet][1][0];
    sp[6] = sp[4] + sp[5];
    sp[7] = sp[6] * sp[6];
    sp[8] = triangle_reference_facet_jacobian[facet][0][0] * J_c2;
    sp[9] = triangle_reference_facet_jacobian[facet][1][0] * J_c3;
    sp[10] = sp[8] + sp[9];
    sp[11] = sp[10] * sp[10];
    sp[12] = sp[7] + sp[11];
    sp[13] = std::sqrt(sp[12]);
    alignas(32) double BF0[3] = {};
    alignas(32) double BF1[3] = {};
    alignas(32) double BF2[3] = {};
    alignas(32) double BF3[3] = {};
    for (int iq = 0; iq < 4; ++iq)
    {
        // Quadrature loop body setup (num_points=4)
        // Unstructured varying computations for num_points=4
        double w0_c0 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c0 += w[0][ic] * FE14_C0_F_Q4[facet][iq][ic];
        double w0_c1 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c1 += w[0][ic + 3] * FE14_C0_F_Q4[facet][iq][ic];
        double w0_c5 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c5 += w[0][ic + 15] * FE14_C0_F_Q4[facet][iq][ic];
        double w0_c3 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c3 += w[0][ic + 9] * FE14_C0_F_Q4[facet][iq][ic];
        double w0_c2 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c2 += w[0][ic + 6] * FE14_C0_F_Q4[facet][iq][ic];
        alignas(32) double sv4[19];
        sv4[0] = -1 * w0_c0 + w[40][0];
        sv4[1] = sv4[0] * sp[1];
        sv4[2] = -1 * w0_c1 + w[41][0];
        sv4[3] = sv4[2] * sp[3];
        sv4[4] = w0_c3 * w[5][0];
        sv4[5] = w0_c5 * sv4[4];
        sv4[6] = std::pow(w0_c1, 2) * w[19][0];
        sv4[7] = sv4[5] + sv4[6] / 2;
        sv4[8] = sv4[7] + w[35][0];
        sv4[9] = sv4[8] * (1.0 / w[43][0]);
        sv4[10] = w0_c2 * w[5][0];
        sv4[11] = w0_c5 * sv4[10];
        sv4[12] = sv4[11] + sv4[6] / 2;
        sv4[13] = sv4[12] + -1 * w[35][0];
        sv4[14] = sv4[13] * (1.0 / w[43][0]);
        sv4[15] = -1 * sv4[1] * sp[13];
        sv4[16] = -1 * sv4[3] * sp[13];
        sv4[17] = -1 * sv4[9] * sp[13];
        sv4[18] = -1 * sv4[14] * sp[13];
        const double fw0 = sv4[15] * weights4[iq];
        for (int i = 0; i < 3; ++i)
            BF0[i] += fw0 * FE14_C0_F_Q4[facet][iq][i];
        const double fw1 = sv4[16] * weights4[iq];
        for (int i = 0; i < 3; ++i)
            BF1[i] += fw1 * FE14_C0_F_Q4[facet][iq][i];
        const double fw2 = sv4[18] * weights4[iq];
        for (int i = 0; i < 3; ++i)
            BF2[i] += fw2 * FE14_C0_F_Q4[facet][iq][i];
        const double fw3 = sv4[17] * weights4[iq];
        for (int i = 0; i < 3; ++i)
            BF3[i] += fw3 * FE14_C0_F_Q4[facet][iq][i];
    }
    std::fill(A, A + 19, 0.0);
    for (int i = 0; i < 3; ++i)
        A[i] += BF0[i];
    for (int i = 0; i < 3; ++i)
        A[i + 3] += BF1[i];
    for (int i = 0; i < 3; ++i)
        A[i + 6] += BF2[i];
    for (int i = 0; i < 3; ++i)
        A[i + 9] += BF3[i];
}


imt_exterior_facet_integral_0_otherwise::imt_exterior_facet_integral_0_otherwise() : ufc::exterior_facet_integral()
{

}

imt_exterior_facet_integral_0_otherwise::~imt_exterior_facet_integral_0_otherwise()
{

}

const std::vector<bool> & imt_exterior_facet_integral_0_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, false, false});
return enabled;
}

void imt_exterior_facet_integral_0_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    std::size_t facet,
                                    int cell_orientation) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 6
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 2
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           6
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Quadrature rules
    alignas(32) static const double weights4[4] = { 0.1739274225687268, 0.3260725774312731, 0.3260725774312731, 0.1739274225687268 };
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE3_C0_D01_F_Q4[1][1][2] = { { { -1.0, 1.0 } } };
    alignas(32) static const double FE3_C0_F_Q4[3][4][3] =
        { { { 0.0, 0.9305681557970263, 0.06943184420297369 },
            { 0.0, 0.6699905217924281, 0.3300094782075718 },
            { 0.0, 0.3300094782075719, 0.6699905217924279 },
            { 0.0, 0.06943184420297382, 0.9305681557970262 } },
          { { 0.9305681557970263, 0.0, 0.06943184420297369 },
            { 0.6699905217924281, 0.0, 0.3300094782075718 },
            { 0.3300094782075719, 0.0, 0.669990521792428 },
            { 0.06943184420297382, 0.0, 0.9305681557970262 } },
          { { 0.9305681557970263, 0.06943184420297367, 0.0 },
            { 0.6699905217924281, 0.3300094782075718, 0.0 },
            { 0.3300094782075719, 0.6699905217924281, 0.0 },
            { 0.06943184420297374, 0.9305681557970263, 0.0 } } };
    // Unstructured piecewise computations
    const double J_c0 = coordinate_dofs[0] * FE3_C0_D01_F_Q4[0][0][0] + coordinate_dofs[2] * FE3_C0_D01_F_Q4[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE3_C0_D01_F_Q4[0][0][0] + coordinate_dofs[4] * FE3_C0_D01_F_Q4[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE3_C0_D01_F_Q4[0][0][0] + coordinate_dofs[3] * FE3_C0_D01_F_Q4[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE3_C0_D01_F_Q4[0][0][0] + coordinate_dofs[5] * FE3_C0_D01_F_Q4[0][0][1];
    alignas(32) double sp[14];
    sp[0] = w[20][0] * w[21][0];
    sp[1] = sp[0] / w[42][0];
    sp[2] = w[22][0] * w[23][0];
    sp[3] = sp[2] / w[42][0];
    sp[4] = J_c0 * triangle_reference_facet_jacobian[facet][0][0];
    sp[5] = J_c1 * triangle_reference_facet_jacobian[facet][1][0];
    sp[6] = sp[4] + sp[5];
    sp[7] = sp[6] * sp[6];
    sp[8] = triangle_reference_facet_jacobian[facet][0][0] * J_c2;
    sp[9] = triangle_reference_facet_jacobian[facet][1][0] * J_c3;
    sp[10] = sp[8] + sp[9];
    sp[11] = sp[10] * sp[10];
    sp[12] = sp[7] + sp[11];
    sp[13] = std::sqrt(sp[12]);
    alignas(32) double BF0[3] = {};
    alignas(32) double BF1[3] = {};
    for (int iq = 0; iq < 4; ++iq)
    {
        // Quadrature loop body setup (num_points=4)
        // Unstructured varying computations for num_points=4
        double w0_c0 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c0 += w[0][ic] * FE3_C0_F_Q4[facet][iq][ic];
        double w0_c1 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c1 += w[0][ic + 3] * FE3_C0_F_Q4[facet][iq][ic];
        alignas(32) double sv4[6];
        sv4[0] = -1 * w0_c0 + w[40][0];
        sv4[1] = sv4[0] * sp[1];
        sv4[2] = -1 * w0_c1 + w[41][0];
        sv4[3] = sv4[2] * sp[3];
        sv4[4] = -1 * sv4[1] * sp[13];
        sv4[5] = -1 * sv4[3] * sp[13];
        const double fw0 = sv4[4] * weights4[iq];
        for (int i = 0; i < 3; ++i)
            BF0[i] += fw0 * FE3_C0_F_Q4[facet][iq][i];
        const double fw1 = sv4[5] * weights4[iq];
        for (int i = 0; i < 3; ++i)
            BF1[i] += fw1 * FE3_C0_F_Q4[facet][iq][i];
    }
    std::fill(A, A + 19, 0.0);
    for (int i = 0; i < 3; ++i)
        A[i] += BF0[i];
    for (int i = 0; i < 3; ++i)
        A[i + 3] += BF1[i];
}


imt_cell_integral_1_otherwise::imt_cell_integral_1_otherwise() : ufc::cell_integral()
{

}

imt_cell_integral_1_otherwise::~imt_cell_integral_1_otherwise()
{

}

const std::vector<bool> & imt_cell_integral_1_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, true, true, false, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, true});
return enabled;
}

void imt_cell_integral_1_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 6
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 43
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           6
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Quadrature rules
    alignas(32) static const double weights12[12] = { 0.0254224531851035, 0.0254224531851035, 0.0254224531851035, 0.0583931378631895, 0.0583931378631895, 0.0583931378631895, 0.041425537809187, 0.041425537809187, 0.041425537809187, 0.041425537809187, 0.041425537809187, 0.041425537809187 };
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE3_C0_D01_Q12[1][1][2] = { { { -1.0, 1.0 } } };
    alignas(32) static const double FE3_C0_Q12[1][12][3] =
        { { { 0.06308901449150202, 0.873821971016996, 0.06308901449150202 },
            { 0.06308901449150207, 0.06308901449150207, 0.8738219710169959 },
            { 0.873821971016996, 0.06308901449150202, 0.06308901449150202 },
            { 0.249286745170911, 0.501426509658179, 0.24928674517091 },
            { 0.249286745170911, 0.24928674517091, 0.501426509658179 },
            { 0.50142650965818, 0.24928674517091, 0.24928674517091 },
            { 0.053145049844816, 0.636502499121399, 0.310352451033785 },
            { 0.310352451033785, 0.6365024991213991, 0.05314504984481597 },
            { 0.05314504984481604, 0.3103524510337851, 0.636502499121399 },
            { 0.6365024991213991, 0.310352451033785, 0.05314504984481597 },
            { 0.3103524510337851, 0.05314504984481604, 0.636502499121399 },
            { 0.636502499121399, 0.053145049844816, 0.310352451033785 } } };
    // Unstructured piecewise computations
    const double w0_d1_c5 = w[0][15] * FE3_C0_D01_Q12[0][0][0] + w[0][17] * FE3_C0_D01_Q12[0][0][1];
    const double J_c0 = coordinate_dofs[0] * FE3_C0_D01_Q12[0][0][0] + coordinate_dofs[2] * FE3_C0_D01_Q12[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE3_C0_D01_Q12[0][0][0] + coordinate_dofs[5] * FE3_C0_D01_Q12[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE3_C0_D01_Q12[0][0][0] + coordinate_dofs[4] * FE3_C0_D01_Q12[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE3_C0_D01_Q12[0][0][0] + coordinate_dofs[3] * FE3_C0_D01_Q12[0][0][1];
    double w0_d0_c5 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c5 += w[0][ic + 15] * FE3_C0_D01_Q12[0][0][ic];
    const double w0_d1_c2 = w[0][6] * FE3_C0_D01_Q12[0][0][0] + w[0][8] * FE3_C0_D01_Q12[0][0][1];
    double w0_d0_c2 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c2 += w[0][ic + 6] * FE3_C0_D01_Q12[0][0][ic];
    const double w0_d1_c1 = w[0][3] * FE3_C0_D01_Q12[0][0][0] + w[0][5] * FE3_C0_D01_Q12[0][0][1];
    double w0_d0_c1 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c1 += w[0][ic + 3] * FE3_C0_D01_Q12[0][0][ic];
    const double w0_d1_c4 = w[0][12] * FE3_C0_D01_Q12[0][0][0] + w[0][14] * FE3_C0_D01_Q12[0][0][1];
    double w0_d0_c4 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c4 += w[0][ic + 12] * FE3_C0_D01_Q12[0][0][ic];
    const double w0_d1_c3 = w[0][9] * FE3_C0_D01_Q12[0][0][0] + w[0][11] * FE3_C0_D01_Q12[0][0][1];
    double w0_d0_c3 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c3 += w[0][ic + 9] * FE3_C0_D01_Q12[0][0][ic];
    alignas(32) double sp[93];
    sp[0] = J_c0 * J_c3;
    sp[1] = J_c1 * J_c2;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = J_c0 / sp[2];
    sp[4] = w0_d1_c5 * sp[3];
    sp[5] = -1 * J_c1 / sp[2];
    sp[6] = w0_d0_c5 * sp[5];
    sp[7] = sp[4] + sp[6];
    sp[8] = w0_d1_c2 * sp[3];
    sp[9] = w0_d0_c2 * sp[5];
    sp[10] = sp[8] + sp[9];
    sp[11] = w0_d1_c1 * sp[3];
    sp[12] = w0_d0_c1 * sp[5];
    sp[13] = sp[11] + sp[12];
    sp[14] = w0_d1_c4 * sp[3];
    sp[15] = w0_d0_c4 * sp[5];
    sp[16] = sp[14] + sp[15];
    sp[17] = sp[16] * w[6][0];
    sp[18] = w[26][0] / w[6][0];
    sp[19] = w0_d1_c3 * sp[3];
    sp[20] = w0_d0_c3 * sp[5];
    sp[21] = sp[19] + sp[20];
    sp[22] = w[28][0] / w[6][0];
    sp[23] = sp[7] * w[5][0];
    sp[24] = sp[21] * w[5][0];
    sp[25] = sp[13] * w[19][0];
    sp[26] = sp[3] * w[6][0];
    sp[27] = sp[5] * w[6][0];
    sp[28] = sp[10] * w[5][0];
    sp[29] = J_c3 / sp[2];
    sp[30] = w0_d0_c5 * sp[29];
    sp[31] = -1 * J_c2 / sp[2];
    sp[32] = w0_d1_c5 * sp[31];
    sp[33] = sp[30] + sp[32];
    sp[34] = w0_d0_c2 * sp[29];
    sp[35] = w0_d1_c2 * sp[31];
    sp[36] = sp[34] + sp[35];
    sp[37] = w0_d0_c1 * sp[29];
    sp[38] = w0_d1_c1 * sp[31];
    sp[39] = sp[37] + sp[38];
    sp[40] = w0_d0_c4 * sp[29];
    sp[41] = w0_d1_c4 * sp[31];
    sp[42] = sp[40] + sp[41];
    sp[43] = sp[42] * w[6][0];
    sp[44] = w[27][0] / w[6][0];
    sp[45] = w0_d0_c3 * sp[29];
    sp[46] = w0_d1_c3 * sp[31];
    sp[47] = sp[45] + sp[46];
    sp[48] = w[29][0] / w[6][0];
    sp[49] = sp[33] * w[5][0];
    sp[50] = sp[47] * w[5][0];
    sp[51] = sp[39] * w[19][0];
    sp[52] = sp[31] * w[6][0];
    sp[53] = sp[29] * w[6][0];
    sp[54] = sp[36] * w[5][0];
    sp[55] = w[32][0] / w[2][0];
    sp[56] = w[34][0] / w[4][0];
    sp[57] = w[9][0] / w[7][0];
    sp[58] = w[13][0] / w[7][0];
    sp[59] = w[6][0] / w[31][0];
    sp[60] = sp[3] * sp[3];
    sp[61] = sp[3] * sp[5];
    sp[62] = sp[5] * sp[5];
    sp[63] = sp[31] * sp[31];
    sp[64] = sp[29] * sp[31];
    sp[65] = sp[29] * sp[29];
    sp[66] = sp[60] + sp[63];
    sp[67] = sp[61] + sp[64];
    sp[68] = sp[65] + sp[62];
    sp[69] = w[20][0] * w[21][0];
    sp[70] = sp[66] * sp[69];
    sp[71] = sp[67] * sp[69];
    sp[72] = sp[68] * sp[69];
    sp[73] = w[22][0] * w[23][0];
    sp[74] = sp[66] * sp[73];
    sp[75] = sp[67] * sp[73];
    sp[76] = sp[68] * sp[73];
    sp[77] = sp[66] * w[33][0];
    sp[78] = sp[67] * w[33][0];
    sp[79] = sp[68] * w[33][0];
    sp[80] = std::abs(sp[2]);
    sp[81] = sp[77] * sp[80];
    sp[82] = sp[78] * sp[80];
    sp[83] = sp[79] * sp[80];
    sp[84] = sp[74] * sp[80];
    sp[85] = sp[75] * sp[80];
    sp[86] = sp[76] * sp[80];
    sp[87] = sp[66] * sp[80];
    sp[88] = sp[67] * sp[80];
    sp[89] = sp[68] * sp[80];
    sp[90] = sp[70] * sp[80];
    sp[91] = sp[71] * sp[80];
    sp[92] = sp[72] * sp[80];
    alignas(32) double BF0[3][3] = {};
    alignas(32) double BF1[3][3] = {};
    alignas(32) double BF2[3][3] = {};
    alignas(32) double BF3[3][3] = {};
    alignas(32) double BF4[3][3] = {};
    alignas(32) double BF5[3][3] = {};
    alignas(32) double BF6[3][3] = {};
    alignas(32) double BF7[3][3] = {};
    alignas(32) double TP0[2] = {};
    alignas(32) double TP1[3] = {};
    alignas(32) double TP2[2] = {};
    alignas(32) double TP3[2] = {};
    alignas(32) double TP4[3] = {};
    alignas(32) double TP5[2] = {};
    alignas(32) double TP6[2] = {};
    alignas(32) double TP7[2] = {};
    alignas(32) double TP8[2] = {};
    alignas(32) double TP9[3] = {};
    alignas(32) double TP10[2] = {};
    alignas(32) double BF8[3][3] = {};
    alignas(32) double BF9[3][3] = {};
    alignas(32) double BF10[3][3] = {};
    alignas(32) double BF11[3][3] = {};
    alignas(32) double BF12[3][3] = {};
    alignas(32) double TP11[2] = {};
    alignas(32) double TP12[3] = {};
    alignas(32) double TP13[2] = {};
    alignas(32) double TP14[2] = {};
    alignas(32) double TP15[3] = {};
    alignas(32) double TP16[2] = {};
    alignas(32) double TP17[2] = {};
    alignas(32) double TP18[2] = {};
    alignas(32) double TP19[2] = {};
    alignas(32) double TP20[3] = {};
    alignas(32) double TP21[2] = {};
    alignas(32) double TP22[2] = {};
    alignas(32) double TP23[3] = {};
    alignas(32) double TP24[2] = {};
    alignas(32) double TP25[2] = {};
    alignas(32) double TP26[3] = {};
    alignas(32) double TP27[2] = {};
    alignas(32) double TP28[2] = {};
    alignas(32) double TP29[2] = {};
    alignas(32) double TP30[2] = {};
    alignas(32) double TP31[3] = {};
    alignas(32) double TP32[2] = {};
    alignas(32) double BF13[3][3] = {};
    alignas(32) double BF14[3][3] = {};
    alignas(32) double TP33[2] = {};
    alignas(32) double TP34[3] = {};
    alignas(32) double TP35[2] = {};
    alignas(32) double TP36[2] = {};
    alignas(32) double TP37[3] = {};
    alignas(32) double TP38[2] = {};
    alignas(32) double TP39[2] = {};
    alignas(32) double TP40[2] = {};
    alignas(32) double TP41[2] = {};
    alignas(32) double TP42[3] = {};
    alignas(32) double TP43[2] = {};
    alignas(32) double BF15[3][3] = {};
    alignas(32) double BF16[3][3] = {};
    alignas(32) double BF17[3][3] = {};
    alignas(32) double TP44[3] = {};
    alignas(32) double BF18[3][3] = {};
    alignas(32) double TP45[3] = {};
    alignas(32) double TP46[3] = {};
    alignas(32) double BF19[3][3] = {};
    alignas(32) double TP47[3] = {};
    alignas(32) double TP48[3] = {};
    alignas(32) double BF20[3][3] = {};
    alignas(32) double TP49[3] = {};
    alignas(32) double TP50[3] = {};
    alignas(32) double TP51[3] = {};
    alignas(32) double TP52[3] = {};
    alignas(32) double BF21[3][3] = {};
    alignas(32) double TP53[3] = {};
    for (int iq = 0; iq < 12; ++iq)
    {
        // Quadrature loop body setup (num_points=12)
        // Unstructured varying computations for num_points=12
        double w40 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w40 += w[40][ic] * FE3_C0_Q12[0][iq][ic];
        double w0_c0 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c0 += w[0][ic] * FE3_C0_Q12[0][iq][ic];
        double w0_c1 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c1 += w[0][ic + 3] * FE3_C0_Q12[0][iq][ic];
        double w1_c0 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w1_c0 += w[1][ic] * FE3_C0_Q12[0][iq][ic];
        double w1_c1 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w1_c1 += w[1][ic + 3] * FE3_C0_Q12[0][iq][ic];
        double w0_c2 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c2 += w[0][ic + 6] * FE3_C0_Q12[0][iq][ic];
        double w0_c5 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c5 += w[0][ic + 15] * FE3_C0_Q12[0][iq][ic];
        double w0_c3 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c3 += w[0][ic + 9] * FE3_C0_Q12[0][iq][ic];
        double w0_c4 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c4 += w[0][ic + 12] * FE3_C0_Q12[0][iq][ic];
        double w1_c2 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w1_c2 += w[1][ic + 6] * FE3_C0_Q12[0][iq][ic];
        double w1_c3 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w1_c3 += w[1][ic + 9] * FE3_C0_Q12[0][iq][ic];
        alignas(32) double sv12[705];
        sv12[0] = -1 * w[8][0] + -1 * w40;
        sv12[1] = sv12[0] * w[9][0];
        sv12[2] = sv12[1] / w[7][0];
        sv12[3] = 3.0 * std::pow(w0_c0, 2) * w[10][0];
        sv12[4] = sv12[3] + sv12[2];
        sv12[5] = 5.0 * std::pow(w0_c0, 4) * w[11][0];
        sv12[6] = sv12[4] + sv12[5];
        sv12[7] = w0_c0 * w[17][0];
        sv12[8] = 2.0 * w0_c1 * sv12[7];
        sv12[9] = std::pow(w0_c1, 2) * w[17][0];
        sv12[10] = sv12[6] + -1 * sv12[9];
        sv12[11] = -1 * sv12[8] + w[16][0];
        sv12[12] = 2.0 * w0_c0 * (1.5 * w[18][0]);
        sv12[13] = w0_c1 * sv12[12];
        sv12[14] = 1.5 * w[18][0] * std::pow(w0_c0, 2);
        sv12[15] = sv12[10] + sv12[13];
        sv12[16] = sv12[11] + sv12[14];
        sv12[17] = w0_c0 + -1 * w1_c0;
        sv12[18] = sv12[17] * sv12[15];
        sv12[19] = sv12[17] * sv12[16];
        sv12[20] = w0_c0 * sv12[2];
        sv12[21] = std::pow(w0_c0, 3) * w[10][0];
        sv12[22] = sv12[20] + sv12[21];
        sv12[23] = std::pow(w0_c0, 5) * w[11][0];
        sv12[24] = sv12[22] + sv12[23];
        sv12[25] = w0_c1 * w[16][0];
        sv12[26] = sv12[24] + sv12[25];
        sv12[27] = sv12[7] * std::pow(w0_c1, 2);
        sv12[28] = sv12[26] + -1 * sv12[27];
        sv12[29] = w0_c1 * sv12[14];
        sv12[30] = sv12[28] + sv12[29];
        sv12[31] = sv12[30] + sv12[18];
        sv12[32] = sv12[31] / w[2][0];
        sv12[33] = sv12[19] / w[2][0];
        sv12[34] = w0_c1 + -1 * w1_c1;
        sv12[35] = -1 * w[12][0] + -1 * w40;
        sv12[36] = sv12[35] * w[13][0];
        sv12[37] = sv12[36] / w[7][0];
        sv12[38] = 3.0 * std::pow(w0_c1, 2) * w[14][0];
        sv12[39] = sv12[38] + sv12[37];
        sv12[40] = 5.0 * std::pow(w0_c1, 4) * w[15][0];
        sv12[41] = sv12[39] + sv12[40];
        sv12[42] = 2.0 * w0_c0 * w[17][0];
        sv12[43] = w0_c1 * sv12[42];
        sv12[44] = std::pow(w0_c0, 2) * w[17][0];
        sv12[45] = -1 * sv12[43] + w[16][0];
        sv12[46] = sv12[41] + -1 * sv12[44];
        sv12[47] = 3.0 * std::pow(w0_c0, 2) * (0.5 * w[18][0]);
        sv12[48] = sv12[45] + sv12[47];
        sv12[49] = sv12[34] * sv12[48];
        sv12[50] = sv12[34] * sv12[46];
        sv12[51] = w0_c1 * sv12[37];
        sv12[52] = std::pow(w0_c1, 3) * w[14][0];
        sv12[53] = sv12[51] + sv12[52];
        sv12[54] = std::pow(w0_c1, 5) * w[15][0];
        sv12[55] = sv12[53] + sv12[54];
        sv12[56] = w0_c0 * w[16][0];
        sv12[57] = sv12[55] + sv12[56];
        sv12[58] = w0_c1 * sv12[44];
        sv12[59] = sv12[57] + -1 * sv12[58];
        sv12[60] = 0.5 * w[18][0] * std::pow(w0_c0, 3);
        sv12[61] = sv12[59] + sv12[60];
        sv12[62] = sv12[61] + sv12[50];
        sv12[63] = sv12[49] / w[2][0];
        sv12[64] = sv12[62] / w[2][0];
        sv12[65] = sv12[32] + sv12[63];
        sv12[66] = sv12[64] + sv12[33];
        sv12[67] = w0_c2 * w[5][0];
        sv12[68] = sp[7] * sv12[67];
        sv12[69] = w0_c5 * w[5][0];
        sv12[70] = sp[10] * sv12[69];
        sv12[71] = sv12[68] + sv12[70];
        sv12[72] = w0_c1 * w[19][0];
        sv12[73] = sp[13] * sv12[72];
        sv12[74] = sv12[71] + sv12[73];
        sv12[75] = sv12[74] + -1 * sp[17];
        sv12[76] = std::exp(-1 * w0_c2);
        sv12[77] = 1.32934038825 * std::pow(4 + std::pow(w0_c2, 2), -0.75) + sv12[76];
        sv12[78] = 1 / sv12[77] * w[24][0];
        sv12[79] = -1 * sv12[78] * sp[18];
        sv12[80] = sv12[75] * sv12[79];
        sv12[81] = w0_c3 * w[5][0];
        sv12[82] = sp[7] * sv12[81];
        sv12[83] = sp[21] * sv12[69];
        sv12[84] = sv12[82] + sv12[83];
        sv12[85] = sv12[84] + sv12[73];
        sv12[86] = sv12[85] + sp[17];
        sv12[87] = std::exp(-1 * w0_c3);
        sv12[88] = 1.32934038825 * std::pow(4 + std::pow(w0_c3, 2), -0.75) + sv12[87];
        sv12[89] = 1 / sv12[88] * w[25][0];
        sv12[90] = -1 * sv12[89] * sp[22];
        sv12[91] = sv12[86] * sv12[90];
        sv12[92] = -1 * sv12[80] + sv12[91];
        sv12[93] = sv12[81] * sp[3];
        sv12[94] = sv12[81] * sp[5];
        sv12[95] = sv12[69] * sp[3];
        sv12[96] = sv12[69] * sp[5];
        sv12[97] = sv12[72] * sp[3];
        sv12[98] = sv12[72] * sp[5];
        sv12[99] = sv12[90] * sp[25];
        sv12[100] = sv12[90] * sp[23];
        sv12[101] = sv12[93] * sv12[90];
        sv12[102] = sv12[94] * sv12[90];
        sv12[103] = sv12[90] * sp[24];
        sv12[104] = sv12[95] * sv12[90];
        sv12[105] = sv12[96] * sv12[90];
        sv12[106] = sv12[97] * sv12[90];
        sv12[107] = sv12[98] * sv12[90];
        sv12[108] = sv12[90] * sp[26];
        sv12[109] = sv12[90] * sp[27];
        sv12[110] = -0.75 * (2.0 * w0_c3) * std::pow(4 + std::pow(w0_c3, 2), -1.75);
        sv12[111] = 1.32934038825 * sv12[110] + -1.0 * sv12[87];
        sv12[112] = sv12[111] * (1 / sv12[88]);
        sv12[113] = -1 * sv12[112] / sv12[88];
        sv12[114] = sv12[113] * w[25][0];
        sv12[115] = -1 * sv12[114] * sp[22];
        sv12[116] = sv12[86] * sv12[115];
        sv12[117] = sv12[116] + sv12[100];
        sv12[118] = sv12[67] * sp[3];
        sv12[119] = sv12[67] * sp[5];
        sv12[120] = sv12[79] * sp[25];
        sv12[121] = sv12[118] * sv12[79];
        sv12[122] = sv12[119] * sv12[79];
        sv12[123] = sv12[79] * sp[28];
        sv12[124] = sv12[97] * sv12[79];
        sv12[125] = sv12[98] * sv12[79];
        sv12[126] = -1 * sp[26] * sv12[79];
        sv12[127] = -1 * sp[27] * sv12[79];
        sv12[128] = sv12[79] * sp[23];
        sv12[129] = sv12[95] * sv12[79];
        sv12[130] = sv12[96] * sv12[79];
        sv12[131] = -0.75 * (2.0 * w0_c2) * std::pow(4 + std::pow(w0_c2, 2), -1.75);
        sv12[132] = 1.32934038825 * sv12[131] + -1.0 * sv12[76];
        sv12[133] = sv12[132] * (1 / sv12[77]);
        sv12[134] = -1 * sv12[133] / sv12[77];
        sv12[135] = sv12[134] * w[24][0];
        sv12[136] = -1 * sv12[135] * sp[18];
        sv12[137] = sv12[75] * sv12[136];
        sv12[138] = sv12[137] + sv12[128];
        sv12[139] = -1 * sv12[120] + sv12[99];
        sv12[140] = -1 * sv12[121] + sv12[101];
        sv12[141] = -1 * sv12[122] + sv12[102];
        sv12[142] = -1 * sv12[123] + sv12[103];
        sv12[143] = -1 * sv12[124] + sv12[106];
        sv12[144] = -1 * sv12[125] + sv12[107];
        sv12[145] = -1 * sv12[126] + sv12[108];
        sv12[146] = -1 * sv12[127] + sv12[109];
        sv12[147] = sv12[92] * (2 * sv12[139]);
        sv12[148] = sv12[92] * (2 * sv12[117]);
        sv12[149] = sv12[92] * (2 * sv12[140]);
        sv12[150] = sv12[92] * (2 * sv12[141]);
        sv12[151] = sv12[92] * (2 * sv12[142]);
        sv12[152] = sv12[92] * (2 * sv12[104]);
        sv12[153] = sv12[92] * (2 * sv12[105]);
        sv12[154] = sv12[92] * (2 * sv12[143]);
        sv12[155] = sv12[92] * (2 * sv12[144]);
        sv12[156] = sv12[92] * (2 * sv12[145]);
        sv12[157] = sv12[92] * (2 * sv12[146]);
        sv12[158] = sv12[92] * (2 * (-1 * sv12[138]));
        sv12[159] = sv12[92] * (2 * (-1 * sv12[129]));
        sv12[160] = sv12[92] * (2 * (-1 * sv12[130]));
        sv12[161] = sv12[135] * w[26][0];
        sv12[162] = sv12[114] * w[28][0];
        sv12[163] = sv12[78] * w[26][0];
        sv12[164] = sv12[89] * w[28][0];
        sv12[165] = sv12[163] + sv12[164];
        sv12[166] = std::pow(sv12[92], 2) / sv12[165];
        sv12[167] = sv12[162] * sv12[166];
        sv12[168] = sv12[161] * sv12[166];
        sv12[169] = sv12[148] + -1 * sv12[167];
        sv12[170] = sv12[158] + -1 * sv12[168];
        sv12[171] = sv12[147] / sv12[165];
        sv12[172] = sv12[169] / sv12[165];
        sv12[173] = sv12[149] / sv12[165];
        sv12[174] = sv12[150] / sv12[165];
        sv12[175] = sv12[151] / sv12[165];
        sv12[176] = sv12[152] / sv12[165];
        sv12[177] = sv12[153] / sv12[165];
        sv12[178] = sv12[154] / sv12[165];
        sv12[179] = sv12[155] / sv12[165];
        sv12[180] = sv12[156] / sv12[165];
        sv12[181] = sv12[157] / sv12[165];
        sv12[182] = sv12[170] / sv12[165];
        sv12[183] = sv12[159] / sv12[165];
        sv12[184] = sv12[160] / sv12[165];
        sv12[185] = sp[33] * sv12[67];
        sv12[186] = sp[36] * sv12[69];
        sv12[187] = sv12[185] + sv12[186];
        sv12[188] = sp[39] * sv12[72];
        sv12[189] = sv12[187] + sv12[188];
        sv12[190] = sv12[189] + -1 * sp[43];
        sv12[191] = -1 * sv12[78] * sp[44];
        sv12[192] = sv12[190] * sv12[191];
        sv12[193] = sp[33] * sv12[81];
        sv12[194] = sp[47] * sv12[69];
        sv12[195] = sv12[193] + sv12[194];
        sv12[196] = sv12[195] + sv12[188];
        sv12[197] = sv12[196] + sp[43];
        sv12[198] = -1 * sv12[89] * sp[48];
        sv12[199] = sv12[197] * sv12[198];
        sv12[200] = -1 * sv12[192] + sv12[199];
        sv12[201] = sv12[81] * sp[31];
        sv12[202] = sv12[81] * sp[29];
        sv12[203] = sv12[69] * sp[31];
        sv12[204] = sv12[69] * sp[29];
        sv12[205] = sv12[72] * sp[31];
        sv12[206] = sv12[72] * sp[29];
        sv12[207] = sv12[198] * sp[51];
        sv12[208] = sv12[198] * sp[49];
        sv12[209] = sv12[201] * sv12[198];
        sv12[210] = sv12[202] * sv12[198];
        sv12[211] = sv12[198] * sp[50];
        sv12[212] = sv12[203] * sv12[198];
        sv12[213] = sv12[204] * sv12[198];
        sv12[214] = sv12[205] * sv12[198];
        sv12[215] = sv12[206] * sv12[198];
        sv12[216] = sv12[198] * sp[52];
        sv12[217] = sv12[198] * sp[53];
        sv12[218] = -1 * sv12[114] * sp[48];
        sv12[219] = sv12[197] * sv12[218];
        sv12[220] = sv12[219] + sv12[208];
        sv12[221] = sv12[67] * sp[31];
        sv12[222] = sv12[67] * sp[29];
        sv12[223] = sv12[191] * sp[51];
        sv12[224] = sv12[221] * sv12[191];
        sv12[225] = sv12[222] * sv12[191];
        sv12[226] = sv12[191] * sp[54];
        sv12[227] = sv12[205] * sv12[191];
        sv12[228] = sv12[206] * sv12[191];
        sv12[229] = -1 * sp[52] * sv12[191];
        sv12[230] = -1 * sp[53] * sv12[191];
        sv12[231] = sv12[191] * sp[49];
        sv12[232] = sv12[203] * sv12[191];
        sv12[233] = sv12[204] * sv12[191];
        sv12[234] = -1 * sv12[135] * sp[44];
        sv12[235] = sv12[190] * sv12[234];
        sv12[236] = sv12[235] + sv12[231];
        sv12[237] = -1 * sv12[223] + sv12[207];
        sv12[238] = -1 * sv12[224] + sv12[209];
        sv12[239] = -1 * sv12[225] + sv12[210];
        sv12[240] = -1 * sv12[226] + sv12[211];
        sv12[241] = -1 * sv12[227] + sv12[214];
        sv12[242] = -1 * sv12[228] + sv12[215];
        sv12[243] = -1 * sv12[229] + sv12[216];
        sv12[244] = -1 * sv12[230] + sv12[217];
        sv12[245] = sv12[200] * (2 * sv12[237]);
        sv12[246] = sv12[200] * (2 * sv12[220]);
        sv12[247] = sv12[200] * (2 * sv12[238]);
        sv12[248] = sv12[200] * (2 * sv12[239]);
        sv12[249] = sv12[200] * (2 * sv12[240]);
        sv12[250] = sv12[200] * (2 * sv12[212]);
        sv12[251] = sv12[200] * (2 * sv12[213]);
        sv12[252] = sv12[200] * (2 * sv12[241]);
        sv12[253] = sv12[200] * (2 * sv12[242]);
        sv12[254] = sv12[200] * (2 * sv12[243]);
        sv12[255] = sv12[200] * (2 * sv12[244]);
        sv12[256] = sv12[200] * (2 * (-1 * sv12[236]));
        sv12[257] = sv12[200] * (2 * (-1 * sv12[232]));
        sv12[258] = sv12[200] * (2 * (-1 * sv12[233]));
        sv12[259] = sv12[135] * w[27][0];
        sv12[260] = sv12[114] * w[29][0];
        sv12[261] = sv12[78] * w[27][0];
        sv12[262] = sv12[89] * w[29][0];
        sv12[263] = sv12[261] + sv12[262];
        sv12[264] = std::pow(sv12[200], 2) / sv12[263];
        sv12[265] = sv12[260] * sv12[264];
        sv12[266] = sv12[259] * sv12[264];
        sv12[267] = sv12[246] + -1 * sv12[265];
        sv12[268] = sv12[256] + -1 * sv12[266];
        sv12[269] = sv12[245] / sv12[263];
        sv12[270] = sv12[267] / sv12[263];
        sv12[271] = sv12[247] / sv12[263];
        sv12[272] = sv12[248] / sv12[263];
        sv12[273] = sv12[249] / sv12[263];
        sv12[274] = sv12[250] / sv12[263];
        sv12[275] = sv12[251] / sv12[263];
        sv12[276] = sv12[252] / sv12[263];
        sv12[277] = sv12[253] / sv12[263];
        sv12[278] = sv12[254] / sv12[263];
        sv12[279] = sv12[255] / sv12[263];
        sv12[280] = sv12[268] / sv12[263];
        sv12[281] = sv12[257] / sv12[263];
        sv12[282] = sv12[258] / sv12[263];
        sv12[283] = sv12[171] + sv12[269];
        sv12[284] = sv12[172] + sv12[270];
        sv12[285] = sv12[173] + sv12[271];
        sv12[286] = sv12[174] + sv12[272];
        sv12[287] = sv12[175] + sv12[273];
        sv12[288] = sv12[176] + sv12[274];
        sv12[289] = sv12[177] + sv12[275];
        sv12[290] = sv12[178] + sv12[276];
        sv12[291] = sv12[179] + sv12[277];
        sv12[292] = sv12[180] + sv12[278];
        sv12[293] = sv12[181] + sv12[279];
        sv12[294] = sv12[182] + sv12[280];
        sv12[295] = sv12[183] + sv12[281];
        sv12[296] = sv12[184] + sv12[282];
        sv12[297] = sv12[283] * w[6][0];
        sv12[298] = sv12[284] * w[6][0];
        sv12[299] = sv12[285] * w[6][0];
        sv12[300] = sv12[286] * w[6][0];
        sv12[301] = sv12[287] * w[6][0];
        sv12[302] = sv12[288] * w[6][0];
        sv12[303] = sv12[289] * w[6][0];
        sv12[304] = sv12[290] * w[6][0];
        sv12[305] = sv12[291] * w[6][0];
        sv12[306] = sv12[292] * w[6][0];
        sv12[307] = sv12[293] * w[6][0];
        sv12[308] = sv12[294] * w[6][0];
        sv12[309] = sv12[295] * w[6][0];
        sv12[310] = sv12[296] * w[6][0];
        sv12[311] = -1 * sv12[301] + sp[55];
        sv12[312] = sv12[66] + -1 * sv12[297];
        sv12[313] = sv12[311] + sp[56];
        sv12[314] = w0_c0 * sp[57];
        sv12[315] = w0_c5 + -1 * w[8][0];
        sv12[316] = sv12[315] + -1 * w40;
        sv12[317] = sv12[316] * w[9][0];
        sv12[318] = sv12[317] / w[7][0];
        sv12[319] = sv12[3] + sv12[318];
        sv12[320] = sv12[319] + sv12[5];
        sv12[321] = sv12[320] + -1 * sv12[9];
        sv12[322] = sv12[321] + sv12[13];
        sv12[323] = sv12[322] * (2.0 * w[20][0]);
        sv12[324] = sv12[16] * (2.0 * w[20][0]);
        sv12[325] = sv12[314] * (2.0 * w[20][0]);
        sv12[326] = sv12[323] + 1.0 / w[2][0];
        sv12[327] = w0_c1 * sp[58];
        sv12[328] = w0_c5 + -1 * w[12][0];
        sv12[329] = sv12[328] + -1 * w40;
        sv12[330] = sv12[329] * w[13][0];
        sv12[331] = sv12[330] / w[7][0];
        sv12[332] = sv12[38] + sv12[331];
        sv12[333] = sv12[332] + sv12[40];
        sv12[334] = sv12[333] + -1 * sv12[44];
        sv12[335] = sv12[78] + sv12[89];
        sv12[336] = std::pow(w0_c1, 2) * w[19][0];
        sv12[337] = -1 * w[35][0] + sv12[336] / 2;
        sv12[338] = -1 * sv12[337] / sv12[69];
        sv12[339] = std::exp(-1 * sv12[338]);
        sv12[340] = 1.32934038825 * std::pow(4 + std::pow(sv12[338], 2), -0.75) + sv12[339];
        sv12[341] = 1 / sv12[340] * w[24][0];
        sv12[342] = sv12[335] + -1 * (2 * sv12[341]);
        sv12[343] = sv12[342] * w[19][0];
        sv12[344] = sv12[338] * w[5][0];
        sv12[345] = 2.0 * w0_c1 * w[19][0];
        sv12[346] = -1 * (sv12[345] / 2) / sv12[69];
        sv12[347] = -1 * sv12[344] / sv12[69];
        sv12[348] = 2 * sv12[346] * sv12[338];
        sv12[349] = 2 * sv12[347] * sv12[338];
        sv12[350] = -0.75 * sv12[348] * std::pow(4 + std::pow(sv12[338], 2), -1.75);
        sv12[351] = -0.75 * sv12[349] * std::pow(4 + std::pow(sv12[338], 2), -1.75);
        sv12[352] = -1 * sv12[346] * sv12[339];
        sv12[353] = -1 * sv12[347] * sv12[339];
        sv12[354] = 1.32934038825 * sv12[350] + sv12[352];
        sv12[355] = 1.32934038825 * sv12[351] + sv12[353];
        sv12[356] = sv12[354] * (1 / sv12[340]);
        sv12[357] = sv12[355] * (1 / sv12[340]);
        sv12[358] = -1 * sv12[356] / sv12[340];
        sv12[359] = -1 * sv12[357] / sv12[340];
        sv12[360] = sv12[358] * w[24][0];
        sv12[361] = sv12[359] * w[24][0];
        sv12[362] = -1 * (2 * sv12[360]) * sv12[72];
        sv12[363] = sv12[72] * sv12[114];
        sv12[364] = -1 * (2 * sv12[361]) * sv12[72];
        sv12[365] = sv12[72] * sv12[135];
        sv12[366] = sv12[362] + sv12[343];
        sv12[367] = sv12[334] + sv12[366];
        sv12[368] = sv12[364] + sv12[327];
        sv12[369] = sv12[48] * (2.0 * w[22][0]);
        sv12[370] = sv12[367] * (2.0 * w[22][0]);
        sv12[371] = sv12[363] * (2.0 * w[22][0]);
        sv12[372] = sv12[368] * (2.0 * w[22][0]);
        sv12[373] = sv12[365] * (2.0 * w[22][0]);
        sv12[374] = sv12[370] + 1.0 / w[2][0];
        sv12[375] = sv12[78] * sv12[89];
        sv12[376] = w0_c4 * w[6][0];
        sv12[377] = -1 * sv12[376] + sv12[336] / 2;
        sv12[378] = sv12[377] + -1 * w[35][0];
        sv12[379] = -1 * sv12[378] / sv12[69];
        sv12[380] = std::exp(-1 * sv12[379]);
        sv12[381] = 1.32934038825 * std::pow(4 + std::pow(sv12[379], 2), -0.75) + sv12[380];
        sv12[382] = 1 / sv12[381] * w[24][0];
        sv12[383] = sv12[376] + sv12[336] / 2;
        sv12[384] = sv12[383] + w[35][0];
        sv12[385] = -1 * sv12[384] / sv12[69];
        sv12[386] = std::exp(-1 * sv12[385]);
        sv12[387] = 1.32934038825 * std::pow(4 + std::pow(sv12[385], 2), -0.75) + sv12[386];
        sv12[388] = 1 / sv12[387] * w[25][0];
        sv12[389] = sv12[382] * sv12[388];
        sv12[390] = -1 * sv12[375] + sv12[389];
        sv12[391] = 2.0 * w0_c1 * w[30][0];
        sv12[392] = sv12[390] * sv12[391];
        sv12[393] = sv12[379] * w[5][0];
        sv12[394] = -1 * sv12[393] / sv12[69];
        sv12[395] = -1 * (-1 * w[6][0]) / sv12[69];
        sv12[396] = 2 * sv12[346] * sv12[379];
        sv12[397] = 2 * sv12[394] * sv12[379];
        sv12[398] = 2 * sv12[395] * sv12[379];
        sv12[399] = -0.75 * sv12[396] * std::pow(4 + std::pow(sv12[379], 2), -1.75);
        sv12[400] = -0.75 * sv12[397] * std::pow(4 + std::pow(sv12[379], 2), -1.75);
        sv12[401] = -0.75 * sv12[398] * std::pow(4 + std::pow(sv12[379], 2), -1.75);
        sv12[402] = -1 * sv12[346] * sv12[380];
        sv12[403] = -1 * sv12[394] * sv12[380];
        sv12[404] = -1 * sv12[395] * sv12[380];
        sv12[405] = 1.32934038825 * sv12[399] + sv12[402];
        sv12[406] = 1.32934038825 * sv12[400] + sv12[403];
        sv12[407] = 1.32934038825 * sv12[401] + sv12[404];
        sv12[408] = sv12[405] * (1 / sv12[381]);
        sv12[409] = sv12[406] * (1 / sv12[381]);
        sv12[410] = sv12[407] * (1 / sv12[381]);
        sv12[411] = -1 * sv12[408] / sv12[381];
        sv12[412] = -1 * sv12[409] / sv12[381];
        sv12[413] = -1 * sv12[410] / sv12[381];
        sv12[414] = sv12[411] * w[24][0];
        sv12[415] = sv12[412] * w[24][0];
        sv12[416] = sv12[413] * w[24][0];
        sv12[417] = sv12[414] * sv12[388];
        sv12[418] = sv12[415] * sv12[388];
        sv12[419] = sv12[416] * sv12[388];
        sv12[420] = sv12[385] * w[5][0];
        sv12[421] = -1 * sv12[420] / sv12[69];
        sv12[422] = -1 * w[6][0] / sv12[69];
        sv12[423] = 2 * sv12[346] * sv12[385];
        sv12[424] = 2 * sv12[421] * sv12[385];
        sv12[425] = 2 * sv12[422] * sv12[385];
        sv12[426] = -0.75 * sv12[423] * std::pow(4 + std::pow(sv12[385], 2), -1.75);
        sv12[427] = -0.75 * sv12[424] * std::pow(4 + std::pow(sv12[385], 2), -1.75);
        sv12[428] = -0.75 * sv12[425] * std::pow(4 + std::pow(sv12[385], 2), -1.75);
        sv12[429] = -1 * sv12[346] * sv12[386];
        sv12[430] = -1 * sv12[421] * sv12[386];
        sv12[431] = -1 * sv12[422] * sv12[386];
        sv12[432] = 1.32934038825 * sv12[426] + sv12[429];
        sv12[433] = 1.32934038825 * sv12[427] + sv12[430];
        sv12[434] = 1.32934038825 * sv12[428] + sv12[431];
        sv12[435] = sv12[432] * (1 / sv12[387]);
        sv12[436] = sv12[433] * (1 / sv12[387]);
        sv12[437] = sv12[434] * (1 / sv12[387]);
        sv12[438] = -1 * sv12[435] / sv12[387];
        sv12[439] = -1 * sv12[436] / sv12[387];
        sv12[440] = -1 * sv12[437] / sv12[387];
        sv12[441] = sv12[438] * w[25][0];
        sv12[442] = sv12[439] * w[25][0];
        sv12[443] = sv12[440] * w[25][0];
        sv12[444] = sv12[382] * sv12[441];
        sv12[445] = sv12[382] * sv12[442];
        sv12[446] = sv12[382] * sv12[443];
        sv12[447] = sv12[417] + sv12[444];
        sv12[448] = sv12[418] + sv12[445];
        sv12[449] = sv12[419] + sv12[446];
        sv12[450] = sv12[135] * sv12[89];
        sv12[451] = sv12[78] * sv12[114];
        sv12[452] = std::pow(w0_c1, 2) * w[30][0];
        sv12[453] = sv12[447] * sv12[452];
        sv12[454] = -1 * sv12[451] * sv12[452];
        sv12[455] = sv12[448] * sv12[452];
        sv12[456] = -1 * sv12[450] * sv12[452];
        sv12[457] = sv12[449] * sv12[452];
        sv12[458] = sv12[392] + sv12[453];
        sv12[459] = w0_c2 + -1 * w1_c2;
        sv12[460] = w0_c2 * (1.994010582375 * std::pow(4 + std::pow(w0_c2, 2), -1.75));
        sv12[461] = sv12[460] + sv12[76];
        sv12[462] = 2 * sv12[134] * (1 / sv12[77]);
        sv12[463] = sv12[461] * sv12[462];
        sv12[464] = -1.75 * (2.0 * w0_c2) * std::pow(4 + std::pow(w0_c2, 2), -2.75);
        sv12[465] = w0_c2 * (1.994010582375 * sv12[464]);
        sv12[466] = sv12[465] + 1.994010582375 * std::pow(4 + std::pow(w0_c2, 2), -1.75);
        sv12[467] = sv12[466] + -1.0 * sv12[76];
        sv12[468] = sv12[467] * std::pow(1 / sv12[77], 2);
        sv12[469] = sv12[463] + sv12[468];
        sv12[470] = sv12[469] * w[24][0];
        sv12[471] = sv12[459] * sv12[470];
        sv12[472] = sv12[461] * std::pow(1 / sv12[77], 2);
        sv12[473] = sv12[472] * w[24][0];
        sv12[474] = sv12[471] + sv12[473];
        sv12[475] = sv12[474] / w[2][0];
        sv12[476] = -1 * sv12[456] + sv12[475];
        sv12[477] = w0_c3 + -1 * w1_c3;
        sv12[478] = w0_c3 * (1.994010582375 * std::pow(4 + std::pow(w0_c3, 2), -1.75));
        sv12[479] = sv12[478] + sv12[87];
        sv12[480] = 2 * sv12[113] * (1 / sv12[88]);
        sv12[481] = sv12[479] * sv12[480];
        sv12[482] = -1.75 * (2.0 * w0_c3) * std::pow(4 + std::pow(w0_c3, 2), -2.75);
        sv12[483] = w0_c3 * (1.994010582375 * sv12[482]);
        sv12[484] = sv12[483] + 1.994010582375 * std::pow(4 + std::pow(w0_c3, 2), -1.75);
        sv12[485] = sv12[484] + -1.0 * sv12[87];
        sv12[486] = sv12[485] * std::pow(1 / sv12[88], 2);
        sv12[487] = sv12[481] + sv12[486];
        sv12[488] = sv12[487] * w[25][0];
        sv12[489] = sv12[477] * sv12[488];
        sv12[490] = sv12[479] * std::pow(1 / sv12[88], 2);
        sv12[491] = sv12[490] * w[25][0];
        sv12[492] = sv12[489] + sv12[491];
        sv12[493] = sv12[492] / w[2][0];
        sv12[494] = -1 * sv12[454] + sv12[493];
        sv12[495] = sv12[114] * sp[59];
        sv12[496] = -1 * sv12[135] * sp[59];
        sv12[497] = sv12[120] * sp[3];
        sv12[498] = sv12[120] * sp[5];
        sv12[499] = sv12[121] * sp[3];
        sv12[500] = sv12[121] * sp[5];
        sv12[501] = sv12[122] * sp[3];
        sv12[502] = sv12[122] * sp[5];
        sv12[503] = sv12[123] * sp[3];
        sv12[504] = sv12[123] * sp[5];
        sv12[505] = sv12[124] * sp[3];
        sv12[506] = sv12[124] * sp[5];
        sv12[507] = sv12[125] * sp[3];
        sv12[508] = sv12[125] * sp[5];
        sv12[509] = sv12[126] * sp[3];
        sv12[510] = sv12[126] * sp[5];
        sv12[511] = sv12[127] * sp[3];
        sv12[512] = sv12[127] * sp[5];
        sv12[513] = sv12[138] * sp[3];
        sv12[514] = sv12[138] * sp[5];
        sv12[515] = sv12[129] * sp[3];
        sv12[516] = sv12[129] * sp[5];
        sv12[517] = sv12[130] * sp[3];
        sv12[518] = sv12[130] * sp[5];
        sv12[519] = sv12[223] * sp[31];
        sv12[520] = sv12[223] * sp[29];
        sv12[521] = sv12[224] * sp[31];
        sv12[522] = sv12[224] * sp[29];
        sv12[523] = sv12[225] * sp[31];
        sv12[524] = sv12[225] * sp[29];
        sv12[525] = sv12[226] * sp[31];
        sv12[526] = sv12[226] * sp[29];
        sv12[527] = sv12[227] * sp[31];
        sv12[528] = sv12[227] * sp[29];
        sv12[529] = sv12[228] * sp[31];
        sv12[530] = sv12[228] * sp[29];
        sv12[531] = sv12[229] * sp[31];
        sv12[532] = sv12[229] * sp[29];
        sv12[533] = sv12[230] * sp[31];
        sv12[534] = sv12[230] * sp[29];
        sv12[535] = sv12[236] * sp[31];
        sv12[536] = sv12[236] * sp[29];
        sv12[537] = sv12[232] * sp[31];
        sv12[538] = sv12[232] * sp[29];
        sv12[539] = sv12[233] * sp[31];
        sv12[540] = sv12[233] * sp[29];
        sv12[541] = sv12[497] + sv12[519];
        sv12[542] = sv12[520] + sv12[498];
        sv12[543] = sv12[499] + sv12[521];
        sv12[544] = sv12[522] + sv12[500];
        sv12[545] = sv12[501] + sv12[523];
        sv12[546] = sv12[524] + sv12[502];
        sv12[547] = sv12[503] + sv12[525];
        sv12[548] = sv12[526] + sv12[504];
        sv12[549] = sv12[505] + sv12[527];
        sv12[550] = sv12[528] + sv12[506];
        sv12[551] = sv12[507] + sv12[529];
        sv12[552] = sv12[530] + sv12[508];
        sv12[553] = sv12[509] + sv12[531];
        sv12[554] = sv12[532] + sv12[510];
        sv12[555] = sv12[511] + sv12[533];
        sv12[556] = sv12[534] + sv12[512];
        sv12[557] = sv12[513] + sv12[535];
        sv12[558] = sv12[536] + sv12[514];
        sv12[559] = sv12[515] + sv12[537];
        sv12[560] = sv12[538] + sv12[516];
        sv12[561] = sv12[517] + sv12[539];
        sv12[562] = sv12[540] + sv12[518];
        sv12[563] = sv12[99] * sp[3];
        sv12[564] = sv12[99] * sp[5];
        sv12[565] = sv12[117] * sp[3];
        sv12[566] = sv12[117] * sp[5];
        sv12[567] = sv12[101] * sp[3];
        sv12[568] = sv12[101] * sp[5];
        sv12[569] = sv12[102] * sp[3];
        sv12[570] = sv12[102] * sp[5];
        sv12[571] = sv12[103] * sp[3];
        sv12[572] = sv12[103] * sp[5];
        sv12[573] = sv12[104] * sp[3];
        sv12[574] = sv12[104] * sp[5];
        sv12[575] = sv12[105] * sp[3];
        sv12[576] = sv12[105] * sp[5];
        sv12[577] = sv12[106] * sp[3];
        sv12[578] = sv12[106] * sp[5];
        sv12[579] = sv12[107] * sp[3];
        sv12[580] = sv12[107] * sp[5];
        sv12[581] = sv12[108] * sp[3];
        sv12[582] = sv12[108] * sp[5];
        sv12[583] = sv12[109] * sp[3];
        sv12[584] = sv12[109] * sp[5];
        sv12[585] = sv12[207] * sp[31];
        sv12[586] = sv12[207] * sp[29];
        sv12[587] = sv12[220] * sp[31];
        sv12[588] = sv12[220] * sp[29];
        sv12[589] = sv12[209] * sp[31];
        sv12[590] = sv12[209] * sp[29];
        sv12[591] = sv12[210] * sp[31];
        sv12[592] = sv12[210] * sp[29];
        sv12[593] = sv12[211] * sp[31];
        sv12[594] = sv12[211] * sp[29];
        sv12[595] = sv12[212] * sp[31];
        sv12[596] = sv12[212] * sp[29];
        sv12[597] = sv12[213] * sp[31];
        sv12[598] = sv12[213] * sp[29];
        sv12[599] = sv12[214] * sp[31];
        sv12[600] = sv12[214] * sp[29];
        sv12[601] = sv12[215] * sp[31];
        sv12[602] = sv12[215] * sp[29];
        sv12[603] = sv12[216] * sp[31];
        sv12[604] = sv12[216] * sp[29];
        sv12[605] = sv12[217] * sp[31];
        sv12[606] = sv12[217] * sp[29];
        sv12[607] = sv12[563] + sv12[585];
        sv12[608] = sv12[586] + sv12[564];
        sv12[609] = sv12[565] + sv12[587];
        sv12[610] = sv12[588] + sv12[566];
        sv12[611] = sv12[567] + sv12[589];
        sv12[612] = sv12[590] + sv12[568];
        sv12[613] = sv12[569] + sv12[591];
        sv12[614] = sv12[592] + sv12[570];
        sv12[615] = sv12[571] + sv12[593];
        sv12[616] = sv12[594] + sv12[572];
        sv12[617] = sv12[573] + sv12[595];
        sv12[618] = sv12[596] + sv12[574];
        sv12[619] = sv12[575] + sv12[597];
        sv12[620] = sv12[598] + sv12[576];
        sv12[621] = sv12[577] + sv12[599];
        sv12[622] = sv12[600] + sv12[578];
        sv12[623] = sv12[579] + sv12[601];
        sv12[624] = sv12[602] + sv12[580];
        sv12[625] = sv12[581] + sv12[603];
        sv12[626] = sv12[604] + sv12[582];
        sv12[627] = sv12[583] + sv12[605];
        sv12[628] = sv12[606] + sv12[584];
        sv12[629] = sv12[65] * sp[80];
        sv12[630] = sv12[312] * sp[80];
        sv12[631] = -1 * sv12[298] * sp[80];
        sv12[632] = -1 * sv12[299] * sp[80];
        sv12[633] = -1 * sv12[300] * sp[80];
        sv12[634] = sv12[313] * sp[80];
        sv12[635] = -1 * sv12[302] * sp[80];
        sv12[636] = -1 * sv12[303] * sp[80];
        sv12[637] = -1 * sv12[304] * sp[80];
        sv12[638] = -1 * sv12[305] * sp[80];
        sv12[639] = -1 * sv12[306] * sp[80];
        sv12[640] = -1 * sv12[307] * sp[80];
        sv12[641] = -1 * sv12[308] * sp[80];
        sv12[642] = -1 * sv12[309] * sp[80];
        sv12[643] = -1 * sv12[310] * sp[80];
        sv12[644] = sv12[326] * sp[80];
        sv12[645] = sv12[369] * sp[80];
        sv12[646] = sv12[324] * sp[80];
        sv12[647] = sv12[374] * sp[80];
        sv12[648] = -1 * sv12[458] * sp[80];
        sv12[649] = -1 * sv12[541] * sp[80];
        sv12[650] = -1 * sv12[542] * sp[80];
        sv12[651] = -1 * sv12[607] * sp[80];
        sv12[652] = -1 * sv12[608] * sp[80];
        sv12[653] = sv12[371] * sp[80];
        sv12[654] = -1 * sv12[454] * sp[80];
        sv12[655] = sv12[494] * sp[80];
        sv12[656] = -1 * sv12[495] * sp[80];
        sv12[657] = -1 * sv12[609] * sp[80];
        sv12[658] = -1 * sv12[610] * sp[80];
        sv12[659] = -1 * sv12[543] * sp[80];
        sv12[660] = -1 * sv12[544] * sp[80];
        sv12[661] = -1 * sv12[611] * sp[80];
        sv12[662] = -1 * sv12[612] * sp[80];
        sv12[663] = -1 * sv12[545] * sp[80];
        sv12[664] = -1 * sv12[546] * sp[80];
        sv12[665] = -1 * sv12[613] * sp[80];
        sv12[666] = -1 * sv12[614] * sp[80];
        sv12[667] = sv12[325] * sp[80];
        sv12[668] = sv12[372] * sp[80];
        sv12[669] = -1 * sv12[455] * sp[80];
        sv12[670] = -1 * sv12[547] * sp[80];
        sv12[671] = -1 * sv12[548] * sp[80];
        sv12[672] = -1 * sv12[615] * sp[80];
        sv12[673] = -1 * sv12[616] * sp[80];
        sv12[674] = -1 * sv12[617] * sp[80];
        sv12[675] = -1 * sv12[618] * sp[80];
        sv12[676] = -1 * sv12[619] * sp[80];
        sv12[677] = -1 * sv12[620] * sp[80];
        sv12[678] = -1 * sv12[549] * sp[80];
        sv12[679] = -1 * sv12[550] * sp[80];
        sv12[680] = -1 * sv12[621] * sp[80];
        sv12[681] = -1 * sv12[622] * sp[80];
        sv12[682] = -1 * sv12[551] * sp[80];
        sv12[683] = -1 * sv12[552] * sp[80];
        sv12[684] = -1 * sv12[623] * sp[80];
        sv12[685] = -1 * sv12[624] * sp[80];
        sv12[686] = -1 * sv12[553] * sp[80];
        sv12[687] = -1 * sv12[554] * sp[80];
        sv12[688] = -1 * sv12[625] * sp[80];
        sv12[689] = -1 * sv12[626] * sp[80];
        sv12[690] = -1 * sv12[555] * sp[80];
        sv12[691] = -1 * sv12[556] * sp[80];
        sv12[692] = -1 * sv12[627] * sp[80];
        sv12[693] = -1 * sv12[628] * sp[80];
        sv12[694] = sv12[373] * sp[80];
        sv12[695] = sv12[476] * sp[80];
        sv12[696] = -1 * sv12[456] * sp[80];
        sv12[697] = -1 * sv12[496] * sp[80];
        sv12[698] = -1 * sv12[557] * sp[80];
        sv12[699] = -1 * sv12[558] * sp[80];
        sv12[700] = -1 * sv12[559] * sp[80];
        sv12[701] = -1 * sv12[560] * sp[80];
        sv12[702] = -1 * sv12[561] * sp[80];
        sv12[703] = -1 * sv12[562] * sp[80];
        sv12[704] = -1 * sv12[457] * sp[80];
        const double fw0 = sv12[644] * weights12[iq];
        alignas(32) double TF0[3];
        for (int i = 0; i < 3; ++i)
            TF0[i] = fw0 * FE3_C0_Q12[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF0[i][j] += TF0[i] * FE3_C0_Q12[0][iq][j];
        const double fw1 = sv12[646] * weights12[iq];
        alignas(32) double TF1[3];
        for (int i = 0; i < 3; ++i)
            TF1[i] = fw1 * FE3_C0_Q12[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF1[i][j] += TF1[i] * FE3_C0_Q12[0][iq][j];
        const double fw2 = sv12[667] * weights12[iq];
        alignas(32) double TF2[3];
        for (int i = 0; i < 3; ++i)
            TF2[i] = fw2 * FE3_C0_Q12[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF2[i][j] += TF2[i] * FE3_C0_Q12[0][iq][j];
        const double fw3 = sv12[645] * weights12[iq];
        alignas(32) double TF3[3];
        for (int i = 0; i < 3; ++i)
            TF3[i] = fw3 * FE3_C0_Q12[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF3[i][j] += TF3[i] * FE3_C0_Q12[0][iq][j];
        const double fw4 = sv12[647] * weights12[iq];
        alignas(32) double TF4[3];
        for (int i = 0; i < 3; ++i)
            TF4[i] = fw4 * FE3_C0_Q12[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF4[i][j] += TF4[i] * FE3_C0_Q12[0][iq][j];
        const double fw5 = sv12[694] * weights12[iq];
        alignas(32) double TF5[3];
        for (int i = 0; i < 3; ++i)
            TF5[i] = fw5 * FE3_C0_Q12[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF5[i][j] += TF5[i] * FE3_C0_Q12[0][iq][j];
        const double fw6 = sv12[653] * weights12[iq];
        alignas(32) double TF6[3];
        for (int i = 0; i < 3; ++i)
            TF6[i] = fw6 * FE3_C0_Q12[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF6[i][j] += TF6[i] * FE3_C0_Q12[0][iq][j];
        const double fw7 = sv12[668] * weights12[iq];
        alignas(32) double TF7[3];
        for (int i = 0; i < 3; ++i)
            TF7[i] = fw7 * FE3_C0_Q12[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF7[i][j] += TF7[i] * FE3_C0_Q12[0][iq][j];
        const double fw8 = sv12[683] * weights12[iq];
        for (int j = 0; j < 2; ++j)
            TP0[j] += fw8 * FE3_C0_D01_Q12[0][0][j];
        const double fw9 = sv12[650] * weights12[iq];
        for (int j = 0; j < 3; ++j)
            TP1[j] += fw9 * FE3_C0_Q12[0][iq][j];
        const double fw10 = sv12[679] * weights12[iq];
        for (int j = 0; j < 2; ++j)
            TP2[j] += fw10 * FE3_C0_D01_Q12[0][0][j];
        const double fw11 = sv12[703] * weights12[iq];
        for (int j = 0; j < 2; ++j)
            TP3[j] += fw11 * FE3_C0_D01_Q12[0][0][j];
        const double fw12 = sv12[699] * weights12[iq];
        for (int j = 0; j < 3; ++j)
            TP4[j] += fw12 * FE3_C0_Q12[0][iq][j];
        const double fw13 = sv12[701] * weights12[iq];
        for (int j = 0; j < 2; ++j)
            TP5[j] += fw13 * FE3_C0_D01_Q12[0][0][j];
        const double fw14 = sv12[691] * weights12[iq];
        for (int j = 0; j < 2; ++j)
            TP6[j] += fw14 * FE3_C0_D01_Q12[0][0][j];
        const double fw15 = sv12[687] * weights12[iq];
        for (int j = 0; j < 2; ++j)
            TP7[j] += fw15 * FE3_C0_D01_Q12[0][0][j];
        const double fw16 = sv12[664] * weights12[iq];
        for (int j = 0; j < 2; ++j)
            TP8[j] += fw16 * FE3_C0_D01_Q12[0][0][j];
        const double fw17 = sv12[671] * weights12[iq];
        for (int j = 0; j < 3; ++j)
            TP9[j] += fw17 * FE3_C0_Q12[0][iq][j];
        const double fw18 = sv12[660] * weights12[iq];
        for (int j = 0; j < 2; ++j)
            TP10[j] += fw18 * FE3_C0_D01_Q12[0][0][j];
        const double fw19 = sv12[648] * weights12[iq];
        alignas(32) double TF8[3];
        for (int i = 0; i < 3; ++i)
            TF8[i] = fw19 * FE3_C0_Q12[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF8[i][j] += TF8[i] * FE3_C0_Q12[0][iq][j];
        const double fw20 = sv12[695] * weights12[iq];
        alignas(32) double TF9[3];
        for (int i = 0; i < 3; ++i)
            TF9[i] = fw20 * FE3_C0_Q12[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF9[i][j] += TF9[i] * FE3_C0_Q12[0][iq][j];
        const double fw21 = sv12[654] * weights12[iq];
        alignas(32) double TF10[3];
        for (int i = 0; i < 3; ++i)
            TF10[i] = fw21 * FE3_C0_Q12[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF10[i][j] += TF10[i] * FE3_C0_Q12[0][iq][j];
        const double fw22 = sv12[704] * weights12[iq];
        alignas(32) double TF11[3];
        for (int i = 0; i < 3; ++i)
            TF11[i] = fw22 * FE3_C0_Q12[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF11[i][j] += TF11[i] * FE3_C0_Q12[0][iq][j];
        const double fw23 = sv12[669] * weights12[iq];
        alignas(32) double TF12[3];
        for (int i = 0; i < 3; ++i)
            TF12[i] = fw23 * FE3_C0_Q12[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF12[i][j] += TF12[i] * FE3_C0_Q12[0][iq][j];
        const double fw24 = sv12[682] * weights12[iq];
        for (int j = 0; j < 2; ++j)
            TP11[j] += fw24 * FE3_C0_D01_Q12[0][0][j];
        const double fw25 = sv12[649] * weights12[iq];
        for (int j = 0; j < 3; ++j)
            TP12[j] += fw25 * FE3_C0_Q12[0][iq][j];
        const double fw26 = sv12[678] * weights12[iq];
        for (int j = 0; j < 2; ++j)
            TP13[j] += fw26 * FE3_C0_D01_Q12[0][0][j];
        const double fw27 = sv12[702] * weights12[iq];
        for (int j = 0; j < 2; ++j)
            TP14[j] += fw27 * FE3_C0_D01_Q12[0][0][j];
        const double fw28 = sv12[698] * weights12[iq];
        for (int j = 0; j < 3; ++j)
            TP15[j] += fw28 * FE3_C0_Q12[0][iq][j];
        const double fw29 = sv12[700] * weights12[iq];
        for (int j = 0; j < 2; ++j)
            TP16[j] += fw29 * FE3_C0_D01_Q12[0][0][j];
        const double fw30 = sv12[690] * weights12[iq];
        for (int j = 0; j < 2; ++j)
            TP17[j] += fw30 * FE3_C0_D01_Q12[0][0][j];
        const double fw31 = sv12[686] * weights12[iq];
        for (int j = 0; j < 2; ++j)
            TP18[j] += fw31 * FE3_C0_D01_Q12[0][0][j];
        const double fw32 = sv12[663] * weights12[iq];
        for (int j = 0; j < 2; ++j)
            TP19[j] += fw32 * FE3_C0_D01_Q12[0][0][j];
        const double fw33 = sv12[670] * weights12[iq];
        for (int j = 0; j < 3; ++j)
            TP20[j] += fw33 * FE3_C0_Q12[0][iq][j];
        const double fw34 = sv12[659] * weights12[iq];
        for (int j = 0; j < 2; ++j)
            TP21[j] += fw34 * FE3_C0_D01_Q12[0][0][j];
        const double fw35 = sv12[685] * weights12[iq];
        for (int j = 0; j < 2; ++j)
            TP22[j] += fw35 * FE3_C0_D01_Q12[0][0][j];
        const double fw36 = sv12[652] * weights12[iq];
        for (int j = 0; j < 3; ++j)
            TP23[j] += fw36 * FE3_C0_Q12[0][iq][j];
        const double fw37 = sv12[681] * weights12[iq];
        for (int j = 0; j < 2; ++j)
            TP24[j] += fw37 * FE3_C0_D01_Q12[0][0][j];
        const double fw38 = sv12[677] * weights12[iq];
        for (int j = 0; j < 2; ++j)
            TP25[j] += fw38 * FE3_C0_D01_Q12[0][0][j];
        const double fw39 = sv12[658] * weights12[iq];
        for (int j = 0; j < 3; ++j)
            TP26[j] += fw39 * FE3_C0_Q12[0][iq][j];
        const double fw40 = sv12[675] * weights12[iq];
        for (int j = 0; j < 2; ++j)
            TP27[j] += fw40 * FE3_C0_D01_Q12[0][0][j];
        const double fw41 = sv12[693] * weights12[iq];
        for (int j = 0; j < 2; ++j)
            TP28[j] += fw41 * FE3_C0_D01_Q12[0][0][j];
        const double fw42 = sv12[689] * weights12[iq];
        for (int j = 0; j < 2; ++j)
            TP29[j] += fw42 * FE3_C0_D01_Q12[0][0][j];
        const double fw43 = sv12[666] * weights12[iq];
        for (int j = 0; j < 2; ++j)
            TP30[j] += fw43 * FE3_C0_D01_Q12[0][0][j];
        const double fw44 = sv12[673] * weights12[iq];
        for (int j = 0; j < 3; ++j)
            TP31[j] += fw44 * FE3_C0_Q12[0][iq][j];
        const double fw45 = sv12[662] * weights12[iq];
        for (int j = 0; j < 2; ++j)
            TP32[j] += fw45 * FE3_C0_D01_Q12[0][0][j];
        const double fw46 = sv12[696] * weights12[iq];
        alignas(32) double TF13[3];
        for (int i = 0; i < 3; ++i)
            TF13[i] = fw46 * FE3_C0_Q12[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF13[i][j] += TF13[i] * FE3_C0_Q12[0][iq][j];
        const double fw47 = sv12[655] * weights12[iq];
        alignas(32) double TF14[3];
        for (int i = 0; i < 3; ++i)
            TF14[i] = fw47 * FE3_C0_Q12[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF14[i][j] += TF14[i] * FE3_C0_Q12[0][iq][j];
        const double fw48 = sv12[684] * weights12[iq];
        for (int j = 0; j < 2; ++j)
            TP33[j] += fw48 * FE3_C0_D01_Q12[0][0][j];
        const double fw49 = sv12[651] * weights12[iq];
        for (int j = 0; j < 3; ++j)
            TP34[j] += fw49 * FE3_C0_Q12[0][iq][j];
        const double fw50 = sv12[680] * weights12[iq];
        for (int j = 0; j < 2; ++j)
            TP35[j] += fw50 * FE3_C0_D01_Q12[0][0][j];
        const double fw51 = sv12[676] * weights12[iq];
        for (int j = 0; j < 2; ++j)
            TP36[j] += fw51 * FE3_C0_D01_Q12[0][0][j];
        const double fw52 = sv12[657] * weights12[iq];
        for (int j = 0; j < 3; ++j)
            TP37[j] += fw52 * FE3_C0_Q12[0][iq][j];
        const double fw53 = sv12[674] * weights12[iq];
        for (int j = 0; j < 2; ++j)
            TP38[j] += fw53 * FE3_C0_D01_Q12[0][0][j];
        const double fw54 = sv12[692] * weights12[iq];
        for (int j = 0; j < 2; ++j)
            TP39[j] += fw54 * FE3_C0_D01_Q12[0][0][j];
        const double fw55 = sv12[688] * weights12[iq];
        for (int j = 0; j < 2; ++j)
            TP40[j] += fw55 * FE3_C0_D01_Q12[0][0][j];
        const double fw56 = sv12[665] * weights12[iq];
        for (int j = 0; j < 2; ++j)
            TP41[j] += fw56 * FE3_C0_D01_Q12[0][0][j];
        const double fw57 = sv12[672] * weights12[iq];
        for (int j = 0; j < 3; ++j)
            TP42[j] += fw57 * FE3_C0_Q12[0][iq][j];
        const double fw58 = sv12[661] * weights12[iq];
        for (int j = 0; j < 2; ++j)
            TP43[j] += fw58 * FE3_C0_D01_Q12[0][0][j];
        const double fw59 = sv12[697] * weights12[iq];
        alignas(32) double TF15[3];
        for (int i = 0; i < 3; ++i)
            TF15[i] = fw59 * FE3_C0_Q12[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF15[i][j] += TF15[i] * FE3_C0_Q12[0][iq][j];
        const double fw60 = sv12[656] * weights12[iq];
        alignas(32) double TF16[3];
        for (int i = 0; i < 3; ++i)
            TF16[i] = fw60 * FE3_C0_Q12[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF16[i][j] += TF16[i] * FE3_C0_Q12[0][iq][j];
        const double fw61 = sv12[629] * weights12[iq];
        alignas(32) double TF17[3];
        for (int i = 0; i < 3; ++i)
            TF17[i] = fw61 * FE3_C0_Q12[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF17[i][j] += TF17[i] * FE3_C0_Q12[0][iq][j];
        const double fw62 = sv12[638] * weights12[iq];
        for (int i = 0; i < 3; ++i)
            TP44[i] += fw62 * FE3_C0_Q12[0][iq][i];
        const double fw63 = sv12[630] * weights12[iq];
        alignas(32) double TF18[3];
        for (int i = 0; i < 3; ++i)
            TF18[i] = fw63 * FE3_C0_Q12[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF18[i][j] += TF18[i] * FE3_C0_Q12[0][iq][j];
        const double fw64 = sv12[637] * weights12[iq];
        for (int i = 0; i < 3; ++i)
            TP45[i] += fw64 * FE3_C0_Q12[0][iq][i];
        const double fw65 = sv12[643] * weights12[iq];
        for (int i = 0; i < 3; ++i)
            TP46[i] += fw65 * FE3_C0_Q12[0][iq][i];
        const double fw66 = sv12[641] * weights12[iq];
        alignas(32) double TF19[3];
        for (int i = 0; i < 3; ++i)
            TF19[i] = fw66 * FE3_C0_Q12[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF19[i][j] += TF19[i] * FE3_C0_Q12[0][iq][j];
        const double fw67 = sv12[642] * weights12[iq];
        for (int i = 0; i < 3; ++i)
            TP47[i] += fw67 * FE3_C0_Q12[0][iq][i];
        const double fw68 = sv12[636] * weights12[iq];
        for (int i = 0; i < 3; ++i)
            TP48[i] += fw68 * FE3_C0_Q12[0][iq][i];
        const double fw69 = sv12[631] * weights12[iq];
        alignas(32) double TF20[3];
        for (int i = 0; i < 3; ++i)
            TF20[i] = fw69 * FE3_C0_Q12[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF20[i][j] += TF20[i] * FE3_C0_Q12[0][iq][j];
        const double fw70 = sv12[635] * weights12[iq];
        for (int i = 0; i < 3; ++i)
            TP49[i] += fw70 * FE3_C0_Q12[0][iq][i];
        const double fw71 = sv12[640] * weights12[iq];
        for (int i = 0; i < 3; ++i)
            TP50[i] += fw71 * FE3_C0_Q12[0][iq][i];
        const double fw72 = sv12[639] * weights12[iq];
        for (int i = 0; i < 3; ++i)
            TP51[i] += fw72 * FE3_C0_Q12[0][iq][i];
        const double fw73 = sv12[633] * weights12[iq];
        for (int i = 0; i < 3; ++i)
            TP52[i] += fw73 * FE3_C0_Q12[0][iq][i];
        const double fw74 = sv12[634] * weights12[iq];
        alignas(32) double TF21[3];
        for (int i = 0; i < 3; ++i)
            TF21[i] = fw74 * FE3_C0_Q12[0][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF21[i][j] += TF21[i] * FE3_C0_Q12[0][iq][j];
        const double fw75 = sv12[632] * weights12[iq];
        for (int i = 0; i < 3; ++i)
            TP53[i] += fw75 * FE3_C0_Q12[0][iq][i];
    }
    A[0] = 0.5 * sp[92] + 0.5 * sp[91] + 0.5 * sp[91] + 0.5 * sp[90];
    A[1] = -0.5 * sp[92] + -0.5 * sp[91];
    A[2] = -0.5 * sp[91] + -0.5 * sp[90];
    std::fill(A + 3, A + 19, 0.0);
    A[19] = -0.5 * sp[92] + -0.5 * sp[91];
    A[20] = 0.5 * sp[92];
    A[21] = 0.5 * sp[91];
    std::fill(A + 22, A + 38, 0.0);
    A[38] = -0.5 * sp[91] + -0.5 * sp[90];
    A[39] = 0.5 * sp[91];
    A[40] = 0.5 * sp[90];
    std::fill(A + 41, A + 60, 0.0);
    A[60] = 0.5 * sp[86] + 0.5 * sp[85] + 0.5 * sp[85] + 0.5 * sp[84];
    A[61] = -0.5 * sp[86] + -0.5 * sp[85];
    A[62] = -0.5 * sp[85] + -0.5 * sp[84];
    std::fill(A + 63, A + 79, 0.0);
    A[79] = -0.5 * sp[86] + -0.5 * sp[85];
    A[80] = 0.5 * sp[86];
    A[81] = 0.5 * sp[85];
    std::fill(A + 82, A + 98, 0.0);
    A[98] = -0.5 * sp[85] + -0.5 * sp[84];
    A[99] = 0.5 * sp[85];
    A[100] = 0.5 * sp[84];
    std::fill(A + 101, A + 240, 0.0);
    A[240] = 0.5 * sp[89] + 0.5 * sp[88] + 0.5 * sp[88] + 0.5 * sp[87];
    A[241] = -0.5 * sp[89] + -0.5 * sp[88];
    A[242] = -0.5 * sp[88] + -0.5 * sp[87];
    std::fill(A + 243, A + 259, 0.0);
    A[259] = -0.5 * sp[89] + -0.5 * sp[88];
    A[260] = 0.5 * sp[89];
    A[261] = 0.5 * sp[88];
    std::fill(A + 262, A + 278, 0.0);
    A[278] = -0.5 * sp[88] + -0.5 * sp[87];
    A[279] = 0.5 * sp[88];
    A[280] = 0.5 * sp[87];
    std::fill(A + 281, A + 300, 0.0);
    A[300] = 0.5 * sp[83] + 0.5 * sp[82] + 0.5 * sp[82] + 0.5 * sp[81];
    A[301] = -0.5 * sp[83] + -0.5 * sp[82];
    A[302] = -0.5 * sp[82] + -0.5 * sp[81];
    std::fill(A + 303, A + 319, 0.0);
    A[319] = -0.5 * sp[83] + -0.5 * sp[82];
    A[320] = 0.5 * sp[83];
    A[321] = 0.5 * sp[82];
    std::fill(A + 322, A + 338, 0.0);
    A[338] = -0.5 * sp[82] + -0.5 * sp[81];
    A[339] = 0.5 * sp[82];
    A[340] = 0.5 * sp[81];
    std::fill(A + 341, A + 361, 0.0);
    static const int DM0[2] = { 3, 5 };
    static const int DM1[2] = { 6, 8 };
    static const int DM2[2] = { 12, 14 };
    static const int DM3[2] = { 15, 17 };
    static const int DM4[2] = { 9, 11 };
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * i + j] += BF0[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * i + (j + 3)] += BF1[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * i + (j + 15)] += BF2[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 3) + j] += BF3[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 3) + (j + 3)] += BF4[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 3) + (j + 6)] += BF5[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 3) + (j + 9)] += BF6[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 3) + (j + 15)] += BF7[i][j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 6) + (j + 3)] += FE3_C0_D01_Q12[0][0][i] * TP0[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 6) + (j + 3)] += FE3_C0_D01_Q12[0][0][i] * TP1[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 6) + DM0[j]] += FE3_C0_D01_Q12[0][0][i] * TP2[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 6) + (j + 6)] += FE3_C0_D01_Q12[0][0][i] * TP3[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 6) + (j + 6)] += FE3_C0_D01_Q12[0][0][i] * TP4[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 6) + DM1[j]] += FE3_C0_D01_Q12[0][0][i] * TP5[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 6) + (j + 12)] += FE3_C0_D01_Q12[0][0][i] * TP6[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 6) + DM2[j]] += FE3_C0_D01_Q12[0][0][i] * TP7[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 6) + (j + 15)] += FE3_C0_D01_Q12[0][0][i] * TP8[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 6) + (j + 15)] += FE3_C0_D01_Q12[0][0][i] * TP9[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 6) + DM3[j]] += FE3_C0_D01_Q12[0][0][i] * TP10[j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 6) + (j + 3)] += BF8[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 6) + (j + 6)] += BF9[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 6) + (j + 9)] += BF10[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 6) + (j + 12)] += BF11[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 6) + (j + 15)] += BF12[i][j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * DM1[i] + (j + 3)] += FE3_C0_D01_Q12[0][0][i] * TP11[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * DM1[i] + (j + 3)] += FE3_C0_D01_Q12[0][0][i] * TP12[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * DM1[i] + DM0[j]] += FE3_C0_D01_Q12[0][0][i] * TP13[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * DM1[i] + (j + 6)] += FE3_C0_D01_Q12[0][0][i] * TP14[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * DM1[i] + (j + 6)] += FE3_C0_D01_Q12[0][0][i] * TP15[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * DM1[i] + DM1[j]] += FE3_C0_D01_Q12[0][0][i] * TP16[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * DM1[i] + (j + 12)] += FE3_C0_D01_Q12[0][0][i] * TP17[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * DM1[i] + DM2[j]] += FE3_C0_D01_Q12[0][0][i] * TP18[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * DM1[i] + (j + 15)] += FE3_C0_D01_Q12[0][0][i] * TP19[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * DM1[i] + (j + 15)] += FE3_C0_D01_Q12[0][0][i] * TP20[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * DM1[i] + DM3[j]] += FE3_C0_D01_Q12[0][0][i] * TP21[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 9) + (j + 3)] += FE3_C0_D01_Q12[0][0][i] * TP22[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 9) + (j + 3)] += FE3_C0_D01_Q12[0][0][i] * TP23[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 9) + DM0[j]] += FE3_C0_D01_Q12[0][0][i] * TP24[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 9) + (j + 9)] += FE3_C0_D01_Q12[0][0][i] * TP25[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 9) + (j + 9)] += FE3_C0_D01_Q12[0][0][i] * TP26[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 9) + DM4[j]] += FE3_C0_D01_Q12[0][0][i] * TP27[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 9) + (j + 12)] += FE3_C0_D01_Q12[0][0][i] * TP28[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 9) + DM2[j]] += FE3_C0_D01_Q12[0][0][i] * TP29[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 9) + (j + 15)] += FE3_C0_D01_Q12[0][0][i] * TP30[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 9) + (j + 15)] += FE3_C0_D01_Q12[0][0][i] * TP31[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 9) + DM3[j]] += FE3_C0_D01_Q12[0][0][i] * TP32[j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 9) + (j + 3)] += BF8[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 9) + (j + 6)] += BF13[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 9) + (j + 9)] += BF14[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 9) + (j + 12)] += BF11[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 9) + (j + 15)] += BF12[i][j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * DM4[i] + (j + 3)] += FE3_C0_D01_Q12[0][0][i] * TP33[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * DM4[i] + (j + 3)] += FE3_C0_D01_Q12[0][0][i] * TP34[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * DM4[i] + DM0[j]] += FE3_C0_D01_Q12[0][0][i] * TP35[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * DM4[i] + (j + 9)] += FE3_C0_D01_Q12[0][0][i] * TP36[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * DM4[i] + (j + 9)] += FE3_C0_D01_Q12[0][0][i] * TP37[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * DM4[i] + DM4[j]] += FE3_C0_D01_Q12[0][0][i] * TP38[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * DM4[i] + (j + 12)] += FE3_C0_D01_Q12[0][0][i] * TP39[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * DM4[i] + DM2[j]] += FE3_C0_D01_Q12[0][0][i] * TP40[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * DM4[i] + (j + 15)] += FE3_C0_D01_Q12[0][0][i] * TP41[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * DM4[i] + (j + 15)] += FE3_C0_D01_Q12[0][0][i] * TP42[j];
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * DM4[i] + DM3[j]] += FE3_C0_D01_Q12[0][0][i] * TP43[j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 12) + (j + 6)] += BF15[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 12) + (j + 9)] += BF16[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 15) + j] += BF17[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 15) + (j + 3)] += FE3_C0_D01_Q12[0][0][j] * TP44[i];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 15) + (j + 3)] += BF18[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 15) + DM0[j]] += FE3_C0_D01_Q12[0][0][j] * TP45[i];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 15) + (j + 6)] += FE3_C0_D01_Q12[0][0][j] * TP46[i];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 15) + (j + 6)] += BF19[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 15) + DM1[j]] += FE3_C0_D01_Q12[0][0][j] * TP47[i];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 15) + (j + 9)] += FE3_C0_D01_Q12[0][0][j] * TP48[i];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 15) + (j + 9)] += BF20[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 15) + DM4[j]] += FE3_C0_D01_Q12[0][0][j] * TP49[i];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 15) + (j + 12)] += FE3_C0_D01_Q12[0][0][j] * TP50[i];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 15) + DM2[j]] += FE3_C0_D01_Q12[0][0][j] * TP51[i];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 15) + (j + 15)] += FE3_C0_D01_Q12[0][0][j] * TP52[i];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 15) + (j + 15)] += BF21[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 15) + DM3[j]] += FE3_C0_D01_Q12[0][0][j] * TP53[i];
}


imt_exterior_facet_integral_1_0::imt_exterior_facet_integral_1_0() : ufc::exterior_facet_integral()
{

}

imt_exterior_facet_integral_1_0::~imt_exterior_facet_integral_1_0()
{

}

const std::vector<bool> & imt_exterior_facet_integral_1_0::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, false, true, true, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, true, true, true, false, true, false, false, false, false, false, false, false, true, true, true, true, false});
return enabled;
}

void imt_exterior_facet_integral_1_0::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    std::size_t facet,
                                    int cell_orientation) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 6
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 16
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           6
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Quadrature rules
    alignas(32) static const double weights4[4] = { 0.1739274225687268, 0.3260725774312731, 0.3260725774312731, 0.1739274225687268 };
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE3_C0_D01_F_Q4[1][1][2] = { { { -1.0, 1.0 } } };
    alignas(32) static const double FE3_C0_F_Q4[3][4][3] =
        { { { 0.0, 0.9305681557970263, 0.06943184420297369 },
            { 0.0, 0.6699905217924281, 0.3300094782075718 },
            { 0.0, 0.3300094782075719, 0.6699905217924279 },
            { 0.0, 0.06943184420297382, 0.9305681557970262 } },
          { { 0.9305681557970263, 0.0, 0.06943184420297369 },
            { 0.6699905217924281, 0.0, 0.3300094782075718 },
            { 0.3300094782075719, 0.0, 0.669990521792428 },
            { 0.06943184420297382, 0.0, 0.9305681557970262 } },
          { { 0.9305681557970263, 0.06943184420297367, 0.0 },
            { 0.6699905217924281, 0.3300094782075718, 0.0 },
            { 0.3300094782075719, 0.6699905217924281, 0.0 },
            { 0.06943184420297374, 0.9305681557970263, 0.0 } } };
    alignas(32) static const double PI0[3][3][3] =
        { { { 0.0, 0.0, 0.0 },
            { 0.0, 0.3333333333333333, 0.1666666666666667 },
            { 0.0, 0.1666666666666667, 0.3333333333333331 } },
          { { 0.3333333333333333, 0.0, 0.1666666666666667 },
            { 0.0, 0.0, 0.0 },
            { 0.1666666666666667, 0.0, 0.3333333333333333 } },
          { { 0.3333333333333333, 0.1666666666666667, 0.0 },
            { 0.1666666666666667, 0.3333333333333333, 0.0 },
            { 0.0, 0.0, 0.0 } } };
    alignas(32) static const double PI1[3][3][1] =
        { { { 0.0 },
            { 0.5 },
            { 0.5 } },
          { { 0.5 },
            { 0.0 },
            { 0.5 } },
          { { 0.5 },
            { 0.5 },
            { 0.0 } } };
    alignas(32) static const double PI2[1][1][1] = { { { 1.0 } } };
    // Unstructured piecewise computations
    const double w0_d1_c5 = w[0][15] * FE3_C0_D01_F_Q4[0][0][0] + w[0][17] * FE3_C0_D01_F_Q4[0][0][1];
    const double J_c0 = coordinate_dofs[0] * FE3_C0_D01_F_Q4[0][0][0] + coordinate_dofs[2] * FE3_C0_D01_F_Q4[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE3_C0_D01_F_Q4[0][0][0] + coordinate_dofs[5] * FE3_C0_D01_F_Q4[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE3_C0_D01_F_Q4[0][0][0] + coordinate_dofs[4] * FE3_C0_D01_F_Q4[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE3_C0_D01_F_Q4[0][0][0] + coordinate_dofs[3] * FE3_C0_D01_F_Q4[0][0][1];
    double w0_d0_c5 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c5 += w[0][ic + 15] * FE3_C0_D01_F_Q4[0][0][ic];
    const double w0_d1_c3 = w[0][9] * FE3_C0_D01_F_Q4[0][0][0] + w[0][11] * FE3_C0_D01_F_Q4[0][0][1];
    double w0_d0_c3 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c3 += w[0][ic + 9] * FE3_C0_D01_F_Q4[0][0][ic];
    const double w0_d1_c1 = w[0][3] * FE3_C0_D01_F_Q4[0][0][0] + w[0][5] * FE3_C0_D01_F_Q4[0][0][1];
    double w0_d0_c1 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c1 += w[0][ic + 3] * FE3_C0_D01_F_Q4[0][0][ic];
    const double w0_d1_c4 = w[0][12] * FE3_C0_D01_F_Q4[0][0][0] + w[0][14] * FE3_C0_D01_F_Q4[0][0][1];
    double w0_d0_c4 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c4 += w[0][ic + 12] * FE3_C0_D01_F_Q4[0][0][ic];
    const double w0_d1_c2 = w[0][6] * FE3_C0_D01_F_Q4[0][0][0] + w[0][8] * FE3_C0_D01_F_Q4[0][0][1];
    double w0_d0_c2 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c2 += w[0][ic + 6] * FE3_C0_D01_F_Q4[0][0][ic];
    alignas(32) double sp[52];
    sp[0] = J_c0 * J_c3;
    sp[1] = J_c1 * J_c2;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = J_c0 / sp[2];
    sp[4] = w0_d1_c5 * sp[3];
    sp[5] = -1 * J_c1 / sp[2];
    sp[6] = w0_d0_c5 * sp[5];
    sp[7] = sp[4] + sp[6];
    sp[8] = sp[7] * w[5][0];
    sp[9] = w0_d1_c3 * sp[3];
    sp[10] = w0_d0_c3 * sp[5];
    sp[11] = sp[9] + sp[10];
    sp[12] = sp[11] * w[5][0];
    sp[13] = w0_d1_c1 * sp[3];
    sp[14] = w0_d0_c1 * sp[5];
    sp[15] = sp[13] + sp[14];
    sp[16] = sp[15] * w[19][0];
    sp[17] = sp[3] * w[6][0];
    sp[18] = sp[5] * w[6][0];
    sp[19] = w[28][0] / w[6][0];
    sp[20] = w0_d1_c4 * sp[3];
    sp[21] = w0_d0_c4 * sp[5];
    sp[22] = sp[20] + sp[21];
    sp[23] = sp[22] * w[6][0];
    sp[24] = w0_d1_c2 * sp[3];
    sp[25] = w0_d0_c2 * sp[5];
    sp[26] = sp[24] + sp[25];
    sp[27] = sp[26] * w[5][0];
    sp[28] = w[26][0] / w[6][0];
    sp[29] = w[20][0] * w[21][0];
    sp[30] = sp[29] / w[38][0];
    sp[31] = w[22][0] * w[23][0];
    sp[32] = sp[31] / w[38][0];
    sp[33] = w[4][0] * w[36][0];
    sp[34] = w[36][0] * w[37][0];
    sp[35] = sp[34] / w[2][0];
    sp[36] = sp[33] * (-1.0 / w[39][0]);
    sp[37] = (1.0 + sp[35]) * (-1.0 / w[39][0]);
    sp[38] = J_c0 * triangle_reference_facet_jacobian[facet][0][0];
    sp[39] = J_c1 * triangle_reference_facet_jacobian[facet][1][0];
    sp[40] = sp[38] + sp[39];
    sp[41] = sp[40] * sp[40];
    sp[42] = triangle_reference_facet_jacobian[facet][0][0] * J_c2;
    sp[43] = triangle_reference_facet_jacobian[facet][1][0] * J_c3;
    sp[44] = sp[42] + sp[43];
    sp[45] = sp[44] * sp[44];
    sp[46] = sp[41] + sp[45];
    sp[47] = std::sqrt(sp[46]);
    sp[48] = sp[36] * sp[47];
    sp[49] = -1 * (-1.0 * sp[32]) * sp[47];
    sp[50] = -1 * (-1.0 * sp[30]) * sp[47];
    sp[51] = sp[37] * sp[47];
    alignas(32) double BF0[3][3] = {};
    alignas(32) double BF1[3][3] = {};
    alignas(32) double BF2[3][3] = {};
    alignas(32) double BF3[3][3] = {};
    alignas(32) double TP0[2] = {};
    alignas(32) double TP1[3] = {};
    alignas(32) double TP2[2] = {};
    alignas(32) double TP3[2] = {};
    alignas(32) double TP4[3] = {};
    alignas(32) double TP5[2] = {};
    alignas(32) double TP6[2] = {};
    alignas(32) double TP7[3] = {};
    alignas(32) double TP8[2] = {};
    alignas(32) double TP9[2] = {};
    alignas(32) double TP10[2] = {};
    alignas(32) double TP11[2] = {};
    alignas(32) double TP12[3] = {};
    alignas(32) double TP13[2] = {};
    for (int iq = 0; iq < 4; ++iq)
    {
        // Quadrature loop body setup (num_points=4)
        // Unstructured varying computations for num_points=4
        double w0_c3 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c3 += w[0][ic + 9] * FE3_C0_F_Q4[facet][iq][ic];
        double w0_c5 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c5 += w[0][ic + 15] * FE3_C0_F_Q4[facet][iq][ic];
        double w0_c1 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c1 += w[0][ic + 3] * FE3_C0_F_Q4[facet][iq][ic];
        double w0_c2 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c2 += w[0][ic + 6] * FE3_C0_F_Q4[facet][iq][ic];
        alignas(32) double sv4[128];
        sv4[0] = w0_c3 * w[5][0];
        sv4[1] = sv4[0] * sp[3];
        sv4[2] = sv4[0] * sp[5];
        sv4[3] = w0_c5 * w[5][0];
        sv4[4] = sv4[3] * sp[3];
        sv4[5] = sv4[3] * sp[5];
        sv4[6] = w0_c1 * w[19][0];
        sv4[7] = sv4[6] * sp[3];
        sv4[8] = sv4[6] * sp[5];
        sv4[9] = std::exp(-1 * w0_c3);
        sv4[10] = 1.32934038825 * std::pow(4 + std::pow(w0_c3, 2), -0.75) + sv4[9];
        sv4[11] = 1 / sv4[10] * w[25][0];
        sv4[12] = -1 * sv4[11] * sp[19];
        sv4[13] = sv4[12] * sp[8];
        sv4[14] = sv4[1] * sv4[12];
        sv4[15] = sv4[2] * sv4[12];
        sv4[16] = sv4[12] * sp[12];
        sv4[17] = sv4[4] * sv4[12];
        sv4[18] = sv4[5] * sv4[12];
        sv4[19] = sv4[12] * sp[16];
        sv4[20] = sv4[7] * sv4[12];
        sv4[21] = sv4[8] * sv4[12];
        sv4[22] = sv4[12] * sp[17];
        sv4[23] = sv4[12] * sp[18];
        sv4[24] = sp[7] * sv4[0];
        sv4[25] = sp[11] * sv4[3];
        sv4[26] = sv4[24] + sv4[25];
        sv4[27] = sp[15] * sv4[6];
        sv4[28] = sv4[26] + sv4[27];
        sv4[29] = sv4[28] + sp[23];
        sv4[30] = -0.75 * (2.0 * w0_c3) * std::pow(4 + std::pow(w0_c3, 2), -1.75);
        sv4[31] = 1.32934038825 * sv4[30] + -1.0 * sv4[9];
        sv4[32] = sv4[31] * (1 / sv4[10]);
        sv4[33] = -1 * sv4[32] / sv4[10];
        sv4[34] = sv4[33] * w[25][0];
        sv4[35] = -1 * sv4[34] * sp[19];
        sv4[36] = sv4[29] * sv4[35];
        sv4[37] = sv4[36] + sv4[13];
        sv4[38] = w0_c2 * w[5][0];
        sv4[39] = sv4[38] * sp[3];
        sv4[40] = sv4[38] * sp[5];
        sv4[41] = std::exp(-1 * w0_c2);
        sv4[42] = 1.32934038825 * std::pow(4 + std::pow(w0_c2, 2), -0.75) + sv4[41];
        sv4[43] = 1 / sv4[42] * w[24][0];
        sv4[44] = -1 * sv4[43] * sp[28];
        sv4[45] = sv4[39] * sv4[44];
        sv4[46] = sv4[40] * sv4[44];
        sv4[47] = sv4[44] * sp[27];
        sv4[48] = sv4[44] * sp[16];
        sv4[49] = sv4[7] * sv4[44];
        sv4[50] = sv4[8] * sv4[44];
        sv4[51] = -1 * sp[17] * sv4[44];
        sv4[52] = -1 * sp[18] * sv4[44];
        sv4[53] = sv4[44] * sp[8];
        sv4[54] = sv4[4] * sv4[44];
        sv4[55] = sv4[5] * sv4[44];
        sv4[56] = sp[7] * sv4[38];
        sv4[57] = sp[26] * sv4[3];
        sv4[58] = sv4[56] + sv4[57];
        sv4[59] = sv4[58] + sv4[27];
        sv4[60] = sv4[59] + -1 * sp[23];
        sv4[61] = -0.75 * (2.0 * w0_c2) * std::pow(4 + std::pow(w0_c2, 2), -1.75);
        sv4[62] = 1.32934038825 * sv4[61] + -1.0 * sv4[41];
        sv4[63] = sv4[62] * (1 / sv4[42]);
        sv4[64] = -1 * sv4[63] / sv4[42];
        sv4[65] = sv4[64] * w[24][0];
        sv4[66] = -1 * sv4[65] * sp[28];
        sv4[67] = sv4[60] * sv4[66];
        sv4[68] = sv4[67] + sv4[53];
        sv4[69] = -1 * sv4[45] + sv4[14];
        sv4[70] = -1 * sv4[46] + sv4[15];
        sv4[71] = -1 * sv4[47] + sv4[16];
        sv4[72] = -1 * sv4[48] + sv4[19];
        sv4[73] = -1 * sv4[49] + sv4[20];
        sv4[74] = -1 * sv4[50] + sv4[21];
        sv4[75] = -1 * sv4[51] + sv4[22];
        sv4[76] = -1 * sv4[52] + sv4[23];
        sv4[77] = sv4[37] * w[6][0];
        sv4[78] = sv4[69] * w[6][0];
        sv4[79] = sv4[70] * w[6][0];
        sv4[80] = sv4[71] * w[6][0];
        sv4[81] = sv4[17] * w[6][0];
        sv4[82] = sv4[18] * w[6][0];
        sv4[83] = sv4[72] * w[6][0];
        sv4[84] = sv4[73] * w[6][0];
        sv4[85] = sv4[74] * w[6][0];
        sv4[86] = sv4[75] * w[6][0];
        sv4[87] = sv4[76] * w[6][0];
        sv4[88] = -1 * sv4[68] * w[6][0];
        sv4[89] = -1 * sv4[54] * w[6][0];
        sv4[90] = -1 * sv4[55] * w[6][0];
        sv4[91] = sv4[77] * w[3][0];
        sv4[92] = sv4[78] * w[3][0];
        sv4[93] = sv4[79] * w[3][0];
        sv4[94] = sv4[80] * w[3][0];
        sv4[95] = sv4[81] * w[3][0];
        sv4[96] = sv4[82] * w[3][0];
        sv4[97] = sv4[83] * w[3][0];
        sv4[98] = sv4[84] * w[3][0];
        sv4[99] = sv4[85] * w[3][0];
        sv4[100] = sv4[86] * w[3][0];
        sv4[101] = sv4[87] * w[3][0];
        sv4[102] = sv4[88] * w[3][0];
        sv4[103] = sv4[89] * w[3][0];
        sv4[104] = sv4[90] * w[3][0];
        sv4[105] = 2.0 * w0_c1 * w[19][0];
        sv4[106] = sv4[38] * (-1.0 / w[39][0]);
        sv4[107] = sv4[105] / 2 * (-1.0 / w[39][0]);
        sv4[108] = sv4[3] * (-1.0 / w[39][0]);
        sv4[109] = sv4[0] * (-1.0 / w[39][0]);
        sv4[110] = -1 * sv4[91] * sp[47];
        sv4[111] = -1 * sv4[92] * sp[47];
        sv4[112] = -1 * sv4[93] * sp[47];
        sv4[113] = -1 * sv4[94] * sp[47];
        sv4[114] = -1 * sv4[95] * sp[47];
        sv4[115] = -1 * sv4[96] * sp[47];
        sv4[116] = -1 * sv4[97] * sp[47];
        sv4[117] = -1 * sv4[98] * sp[47];
        sv4[118] = -1 * sv4[99] * sp[47];
        sv4[119] = -1 * sv4[100] * sp[47];
        sv4[120] = -1 * sv4[101] * sp[47];
        sv4[121] = -1 * sv4[102] * sp[47];
        sv4[122] = -1 * sv4[103] * sp[47];
        sv4[123] = -1 * sv4[104] * sp[47];
        sv4[124] = sv4[108] * sp[47];
        sv4[125] = sv4[106] * sp[47];
        sv4[126] = sv4[109] * sp[47];
        sv4[127] = sv4[107] * sp[47];
        const double fw0 = sv4[127] * weights4[iq];
        alignas(32) double TF0[3];
        for (int i = 0; i < 3; ++i)
            TF0[i] = fw0 * FE3_C0_F_Q4[facet][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF0[i][j] += TF0[i] * FE3_C0_F_Q4[facet][iq][j];
        const double fw1 = sv4[124] * weights4[iq];
        alignas(32) double TF1[3];
        for (int i = 0; i < 3; ++i)
            TF1[i] = fw1 * FE3_C0_F_Q4[facet][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF1[i][j] += TF1[i] * FE3_C0_F_Q4[facet][iq][j];
        const double fw2 = sv4[125] * weights4[iq];
        alignas(32) double TF2[3];
        for (int i = 0; i < 3; ++i)
            TF2[i] = fw2 * FE3_C0_F_Q4[facet][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF2[i][j] += TF2[i] * FE3_C0_F_Q4[facet][iq][j];
        const double fw3 = sv4[126] * weights4[iq];
        alignas(32) double TF3[3];
        for (int i = 0; i < 3; ++i)
            TF3[i] = fw3 * FE3_C0_F_Q4[facet][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF3[i][j] += TF3[i] * FE3_C0_F_Q4[facet][iq][j];
        const double fw4 = sv4[118] * weights4[iq];
        for (int j = 0; j < 2; ++j)
            TP0[j] += fw4 * FE3_C0_D01_F_Q4[0][0][j];
        const double fw5 = sv4[116] * weights4[iq];
        for (int j = 0; j < 3; ++j)
            TP1[j] += fw5 * FE3_C0_F_Q4[facet][iq][j];
        const double fw6 = sv4[117] * weights4[iq];
        for (int j = 0; j < 2; ++j)
            TP2[j] += fw6 * FE3_C0_D01_F_Q4[0][0][j];
        const double fw7 = sv4[123] * weights4[iq];
        for (int j = 0; j < 2; ++j)
            TP3[j] += fw7 * FE3_C0_D01_F_Q4[0][0][j];
        const double fw8 = sv4[121] * weights4[iq];
        for (int j = 0; j < 3; ++j)
            TP4[j] += fw8 * FE3_C0_F_Q4[facet][iq][j];
        const double fw9 = sv4[122] * weights4[iq];
        for (int j = 0; j < 2; ++j)
            TP5[j] += fw9 * FE3_C0_D01_F_Q4[0][0][j];
        const double fw10 = sv4[115] * weights4[iq];
        for (int j = 0; j < 2; ++j)
            TP6[j] += fw10 * FE3_C0_D01_F_Q4[0][0][j];
        const double fw11 = sv4[110] * weights4[iq];
        for (int j = 0; j < 3; ++j)
            TP7[j] += fw11 * FE3_C0_F_Q4[facet][iq][j];
        const double fw12 = sv4[114] * weights4[iq];
        for (int j = 0; j < 2; ++j)
            TP8[j] += fw12 * FE3_C0_D01_F_Q4[0][0][j];
        const double fw13 = sv4[120] * weights4[iq];
        for (int j = 0; j < 2; ++j)
            TP9[j] += fw13 * FE3_C0_D01_F_Q4[0][0][j];
        const double fw14 = sv4[119] * weights4[iq];
        for (int j = 0; j < 2; ++j)
            TP10[j] += fw14 * FE3_C0_D01_F_Q4[0][0][j];
        const double fw15 = sv4[112] * weights4[iq];
        for (int j = 0; j < 2; ++j)
            TP11[j] += fw15 * FE3_C0_D01_F_Q4[0][0][j];
        const double fw16 = sv4[113] * weights4[iq];
        for (int j = 0; j < 3; ++j)
            TP12[j] += fw16 * FE3_C0_F_Q4[facet][iq][j];
        const double fw17 = sv4[111] * weights4[iq];
        for (int j = 0; j < 2; ++j)
            TP13[j] += fw17 * FE3_C0_D01_F_Q4[0][0][j];
    }
    A[0] = sp[50] * PI0[facet][0][0];
    A[1] = sp[50] * PI0[facet][0][1];
    A[2] = sp[50] * PI0[facet][0][2];
    std::fill(A + 3, A + 19, 0.0);
    A[19] = sp[50] * PI0[facet][1][0];
    A[20] = sp[50] * PI0[facet][1][1];
    A[21] = sp[50] * PI0[facet][1][2];
    std::fill(A + 22, A + 38, 0.0);
    A[38] = sp[50] * PI0[facet][2][0];
    A[39] = sp[50] * PI0[facet][2][1];
    A[40] = sp[50] * PI0[facet][2][2];
    std::fill(A + 41, A + 60, 0.0);
    A[60] = sp[49] * PI0[facet][0][0];
    A[61] = sp[49] * PI0[facet][0][1];
    A[62] = sp[49] * PI0[facet][0][2];
    std::fill(A + 63, A + 79, 0.0);
    A[79] = sp[49] * PI0[facet][1][0];
    A[80] = sp[49] * PI0[facet][1][1];
    A[81] = sp[49] * PI0[facet][1][2];
    std::fill(A + 82, A + 98, 0.0);
    A[98] = sp[49] * PI0[facet][2][0];
    A[99] = sp[49] * PI0[facet][2][1];
    A[100] = sp[49] * PI0[facet][2][2];
    std::fill(A + 101, A + 240, 0.0);
    A[240] = sp[51] * PI0[facet][0][0];
    A[241] = sp[51] * PI0[facet][0][1];
    A[242] = sp[51] * PI0[facet][0][2];
    std::fill(A + 243, A + 246, 0.0);
    A[246] = sp[48] * PI1[facet][0][0];
    std::fill(A + 247, A + 259, 0.0);
    A[259] = sp[51] * PI0[facet][1][0];
    A[260] = sp[51] * PI0[facet][1][1];
    A[261] = sp[51] * PI0[facet][1][2];
    std::fill(A + 262, A + 265, 0.0);
    A[265] = sp[48] * PI1[facet][1][0];
    std::fill(A + 266, A + 278, 0.0);
    A[278] = sp[51] * PI0[facet][2][0];
    A[279] = sp[51] * PI0[facet][2][1];
    A[280] = sp[51] * PI0[facet][2][2];
    std::fill(A + 281, A + 284, 0.0);
    A[284] = sp[48] * PI1[facet][2][0];
    std::fill(A + 285, A + 360, 0.0);
    A[360] = sp[47] * PI2[0][0][0];
    static const int DM0[2] = { 3, 5 };
    static const int DM1[2] = { 6, 8 };
    static const int DM2[2] = { 9, 11 };
    static const int DM3[2] = { 12, 14 };
    static const int DM4[2] = { 15, 17 };
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 6) + (j + 3)] += BF0[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 6) + (j + 6)] += BF1[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 6) + (j + 15)] += BF2[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 9) + (j + 3)] += BF0[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 9) + (j + 9)] += BF1[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 9) + (j + 15)] += BF3[i][j];
    for (int i = 0; i < 1; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 18) + (j + 3)] += TP0[j];
    for (int i = 0; i < 1; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 18) + (j + 3)] += TP1[j];
    for (int i = 0; i < 1; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 18) + DM0[j]] += TP2[j];
    for (int i = 0; i < 1; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 18) + (j + 6)] += TP3[j];
    for (int i = 0; i < 1; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 18) + (j + 6)] += TP4[j];
    for (int i = 0; i < 1; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 18) + DM1[j]] += TP5[j];
    for (int i = 0; i < 1; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 18) + (j + 9)] += TP6[j];
    for (int i = 0; i < 1; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 18) + (j + 9)] += TP7[j];
    for (int i = 0; i < 1; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 18) + DM2[j]] += TP8[j];
    for (int i = 0; i < 1; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 18) + (j + 12)] += TP9[j];
    for (int i = 0; i < 1; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 18) + DM3[j]] += TP10[j];
    for (int i = 0; i < 1; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 18) + (j + 15)] += TP11[j];
    for (int i = 0; i < 1; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 18) + (j + 15)] += TP12[j];
    for (int i = 0; i < 1; ++i)
        for (int j = 0; j < 2; ++j)
            A[19 * (i + 18) + DM4[j]] += TP13[j];
}


imt_exterior_facet_integral_1_1::imt_exterior_facet_integral_1_1() : ufc::exterior_facet_integral()
{

}

imt_exterior_facet_integral_1_1::~imt_exterior_facet_integral_1_1()
{

}

const std::vector<bool> & imt_exterior_facet_integral_1_1::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, false, false, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, false});
return enabled;
}

void imt_exterior_facet_integral_1_1::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    std::size_t facet,
                                    int cell_orientation) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 6
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 3
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           6
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Quadrature rules
    alignas(32) static const double weights4[4] = { 0.1739274225687268, 0.3260725774312731, 0.3260725774312731, 0.1739274225687268 };
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE18_C0_F_Q4[3][4][3] =
        { { { 0.0, 0.9305681557970263, 0.06943184420297369 },
            { 0.0, 0.6699905217924281, 0.3300094782075718 },
            { 0.0, 0.3300094782075719, 0.6699905217924279 },
            { 0.0, 0.06943184420297382, 0.9305681557970262 } },
          { { 0.9305681557970263, 0.0, 0.06943184420297369 },
            { 0.6699905217924281, 0.0, 0.3300094782075718 },
            { 0.3300094782075719, 0.0, 0.669990521792428 },
            { 0.06943184420297382, 0.0, 0.9305681557970262 } },
          { { 0.9305681557970263, 0.06943184420297367, 0.0 },
            { 0.6699905217924281, 0.3300094782075718, 0.0 },
            { 0.3300094782075719, 0.6699905217924281, 0.0 },
            { 0.06943184420297374, 0.9305681557970263, 0.0 } } };
    alignas(32) static const double FE3_C0_D01_F_Q4[1][1][2] = { { { -1.0, 1.0 } } };
    alignas(32) static const double PI0[3][3][3] =
        { { { 0.0, 0.0, 0.0 },
            { 0.0, 0.3333333333333333, 0.1666666666666667 },
            { 0.0, 0.1666666666666667, 0.3333333333333331 } },
          { { 0.3333333333333333, 0.0, 0.1666666666666667 },
            { 0.0, 0.0, 0.0 },
            { 0.1666666666666667, 0.0, 0.3333333333333333 } },
          { { 0.3333333333333333, 0.1666666666666667, 0.0 },
            { 0.1666666666666667, 0.3333333333333333, 0.0 },
            { 0.0, 0.0, 0.0 } } };
    // Unstructured piecewise computations
    const double J_c0 = coordinate_dofs[0] * FE3_C0_D01_F_Q4[0][0][0] + coordinate_dofs[2] * FE3_C0_D01_F_Q4[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE3_C0_D01_F_Q4[0][0][0] + coordinate_dofs[4] * FE3_C0_D01_F_Q4[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE3_C0_D01_F_Q4[0][0][0] + coordinate_dofs[3] * FE3_C0_D01_F_Q4[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE3_C0_D01_F_Q4[0][0][0] + coordinate_dofs[5] * FE3_C0_D01_F_Q4[0][0][1];
    alignas(32) double sp[16];
    sp[0] = w[20][0] * w[21][0];
    sp[1] = sp[0] / w[38][0];
    sp[2] = w[22][0] * w[23][0];
    sp[3] = sp[2] / w[38][0];
    sp[4] = J_c0 * triangle_reference_facet_jacobian[facet][0][0];
    sp[5] = J_c1 * triangle_reference_facet_jacobian[facet][1][0];
    sp[6] = sp[4] + sp[5];
    sp[7] = sp[6] * sp[6];
    sp[8] = triangle_reference_facet_jacobian[facet][0][0] * J_c2;
    sp[9] = triangle_reference_facet_jacobian[facet][1][0] * J_c3;
    sp[10] = sp[8] + sp[9];
    sp[11] = sp[10] * sp[10];
    sp[12] = sp[7] + sp[11];
    sp[13] = std::sqrt(sp[12]);
    sp[14] = -1 * (-1.0 * sp[1]) * sp[13];
    sp[15] = -1 * (-1.0 * sp[3]) * sp[13];
    alignas(32) double BF0[3][3] = {};
    alignas(32) double BF1[3][3] = {};
    alignas(32) double BF2[3][3] = {};
    alignas(32) double BF3[3][3] = {};
    for (int iq = 0; iq < 4; ++iq)
    {
        // Quadrature loop body setup (num_points=4)
        // Unstructured varying computations for num_points=4
        double w0_c5 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c5 += w[0][ic + 15] * FE18_C0_F_Q4[facet][iq][ic];
        double w0_c2 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c2 += w[0][ic + 6] * FE18_C0_F_Q4[facet][iq][ic];
        double w0_c1 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c1 += w[0][ic + 3] * FE18_C0_F_Q4[facet][iq][ic];
        double w0_c3 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c3 += w[0][ic + 9] * FE18_C0_F_Q4[facet][iq][ic];
        alignas(32) double sv4[12];
        sv4[0] = w0_c5 * w[5][0];
        sv4[1] = w0_c2 * w[5][0];
        sv4[2] = 2.0 * w0_c1 * w[19][0];
        sv4[3] = sv4[2] / 2 * (1.0 / w[39][0]);
        sv4[4] = sv4[0] * (1.0 / w[39][0]);
        sv4[5] = sv4[1] * (1.0 / w[39][0]);
        sv4[6] = w0_c3 * w[5][0];
        sv4[7] = sv4[6] * (1.0 / w[39][0]);
        sv4[8] = -1 * sv4[3] * sp[13];
        sv4[9] = -1 * sv4[4] * sp[13];
        sv4[10] = -1 * sv4[5] * sp[13];
        sv4[11] = -1 * sv4[7] * sp[13];
        const double fw0 = sv4[8] * weights4[iq];
        alignas(32) double TF0[3];
        for (int i = 0; i < 3; ++i)
            TF0[i] = fw0 * FE18_C0_F_Q4[facet][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF0[i][j] += TF0[i] * FE18_C0_F_Q4[facet][iq][j];
        const double fw1 = sv4[9] * weights4[iq];
        alignas(32) double TF1[3];
        for (int i = 0; i < 3; ++i)
            TF1[i] = fw1 * FE18_C0_F_Q4[facet][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF1[i][j] += TF1[i] * FE18_C0_F_Q4[facet][iq][j];
        const double fw2 = sv4[10] * weights4[iq];
        alignas(32) double TF2[3];
        for (int i = 0; i < 3; ++i)
            TF2[i] = fw2 * FE18_C0_F_Q4[facet][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF2[i][j] += TF2[i] * FE18_C0_F_Q4[facet][iq][j];
        const double fw3 = sv4[11] * weights4[iq];
        alignas(32) double TF3[3];
        for (int i = 0; i < 3; ++i)
            TF3[i] = fw3 * FE18_C0_F_Q4[facet][iq][i];
        for (int i = 0; i < 3; ++i)
            for (int j = 0; j < 3; ++j)
                BF3[i][j] += TF3[i] * FE18_C0_F_Q4[facet][iq][j];
    }
    A[0] = sp[14] * PI0[facet][0][0];
    A[1] = sp[14] * PI0[facet][0][1];
    A[2] = sp[14] * PI0[facet][0][2];
    std::fill(A + 3, A + 19, 0.0);
    A[19] = sp[14] * PI0[facet][1][0];
    A[20] = sp[14] * PI0[facet][1][1];
    A[21] = sp[14] * PI0[facet][1][2];
    std::fill(A + 22, A + 38, 0.0);
    A[38] = sp[14] * PI0[facet][2][0];
    A[39] = sp[14] * PI0[facet][2][1];
    A[40] = sp[14] * PI0[facet][2][2];
    std::fill(A + 41, A + 60, 0.0);
    A[60] = sp[15] * PI0[facet][0][0];
    A[61] = sp[15] * PI0[facet][0][1];
    A[62] = sp[15] * PI0[facet][0][2];
    std::fill(A + 63, A + 79, 0.0);
    A[79] = sp[15] * PI0[facet][1][0];
    A[80] = sp[15] * PI0[facet][1][1];
    A[81] = sp[15] * PI0[facet][1][2];
    std::fill(A + 82, A + 98, 0.0);
    A[98] = sp[15] * PI0[facet][2][0];
    A[99] = sp[15] * PI0[facet][2][1];
    A[100] = sp[15] * PI0[facet][2][2];
    std::fill(A + 101, A + 361, 0.0);
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 6) + (j + 3)] += BF0[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 6) + (j + 6)] += BF1[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 6) + (j + 15)] += BF2[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 9) + (j + 3)] += BF0[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 9) + (j + 9)] += BF1[i][j];
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j)
            A[19 * (i + 9) + (j + 15)] += BF3[i][j];
}


imt_exterior_facet_integral_1_otherwise::imt_exterior_facet_integral_1_otherwise() : ufc::exterior_facet_integral()
{

}

imt_exterior_facet_integral_1_otherwise::~imt_exterior_facet_integral_1_otherwise()
{

}

const std::vector<bool> & imt_exterior_facet_integral_1_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, false});
return enabled;
}

void imt_exterior_facet_integral_1_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    std::size_t facet,
                                    int cell_orientation) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 6
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 2
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           6
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE3_C0_D01_F_Q4[1][1][2] = { { { -1.0, 1.0 } } };
    alignas(32) static const double PI0[3][3][3] =
        { { { 0.0, 0.0, 0.0 },
            { 0.0, 0.3333333333333333, 0.1666666666666667 },
            { 0.0, 0.1666666666666667, 0.3333333333333331 } },
          { { 0.3333333333333333, 0.0, 0.1666666666666667 },
            { 0.0, 0.0, 0.0 },
            { 0.1666666666666667, 0.0, 0.3333333333333333 } },
          { { 0.3333333333333333, 0.1666666666666667, 0.0 },
            { 0.1666666666666667, 0.3333333333333333, 0.0 },
            { 0.0, 0.0, 0.0 } } };
    // Unstructured piecewise computations
    const double J_c0 = coordinate_dofs[0] * FE3_C0_D01_F_Q4[0][0][0] + coordinate_dofs[2] * FE3_C0_D01_F_Q4[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE3_C0_D01_F_Q4[0][0][0] + coordinate_dofs[4] * FE3_C0_D01_F_Q4[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE3_C0_D01_F_Q4[0][0][0] + coordinate_dofs[3] * FE3_C0_D01_F_Q4[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE3_C0_D01_F_Q4[0][0][0] + coordinate_dofs[5] * FE3_C0_D01_F_Q4[0][0][1];
    alignas(32) double sp[16];
    sp[0] = w[20][0] * w[21][0];
    sp[1] = sp[0] / w[38][0];
    sp[2] = w[22][0] * w[23][0];
    sp[3] = sp[2] / w[38][0];
    sp[4] = J_c0 * triangle_reference_facet_jacobian[facet][0][0];
    sp[5] = J_c1 * triangle_reference_facet_jacobian[facet][1][0];
    sp[6] = sp[4] + sp[5];
    sp[7] = sp[6] * sp[6];
    sp[8] = triangle_reference_facet_jacobian[facet][0][0] * J_c2;
    sp[9] = triangle_reference_facet_jacobian[facet][1][0] * J_c3;
    sp[10] = sp[8] + sp[9];
    sp[11] = sp[10] * sp[10];
    sp[12] = sp[7] + sp[11];
    sp[13] = std::sqrt(sp[12]);
    sp[14] = -1 * (-1.0 * sp[1]) * sp[13];
    sp[15] = -1 * (-1.0 * sp[3]) * sp[13];
    A[0] = sp[14] * PI0[facet][0][0];
    A[1] = sp[14] * PI0[facet][0][1];
    A[2] = sp[14] * PI0[facet][0][2];
    std::fill(A + 3, A + 19, 0.0);
    A[19] = sp[14] * PI0[facet][1][0];
    A[20] = sp[14] * PI0[facet][1][1];
    A[21] = sp[14] * PI0[facet][1][2];
    std::fill(A + 22, A + 38, 0.0);
    A[38] = sp[14] * PI0[facet][2][0];
    A[39] = sp[14] * PI0[facet][2][1];
    A[40] = sp[14] * PI0[facet][2][2];
    std::fill(A + 41, A + 60, 0.0);
    A[60] = sp[15] * PI0[facet][0][0];
    A[61] = sp[15] * PI0[facet][0][1];
    A[62] = sp[15] * PI0[facet][0][2];
    std::fill(A + 63, A + 79, 0.0);
    A[79] = sp[15] * PI0[facet][1][0];
    A[80] = sp[15] * PI0[facet][1][1];
    A[81] = sp[15] * PI0[facet][1][2];
    std::fill(A + 82, A + 98, 0.0);
    A[98] = sp[15] * PI0[facet][2][0];
    A[99] = sp[15] * PI0[facet][2][1];
    A[100] = sp[15] * PI0[facet][2][2];
    std::fill(A + 101, A + 361, 0.0);
}


imt_cell_integral_2_otherwise::imt_cell_integral_2_otherwise() : ufc::cell_integral()
{

}

imt_cell_integral_2_otherwise::~imt_cell_integral_2_otherwise()
{

}

const std::vector<bool> & imt_cell_integral_2_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({true});
return enabled;
}

void imt_cell_integral_2_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 6
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 2
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           6
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Quadrature rules
    alignas(32) static const double weights12[12] = { 0.0254224531851035, 0.0254224531851035, 0.0254224531851035, 0.0583931378631895, 0.0583931378631895, 0.0583931378631895, 0.041425537809187, 0.041425537809187, 0.041425537809187, 0.041425537809187, 0.041425537809187, 0.041425537809187 };
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE3_C0_D01_Q12[1][1][2] = { { { -1.0, 1.0 } } };
    alignas(32) static const double FE3_C0_Q12[1][12][3] =
        { { { 0.06308901449150202, 0.873821971016996, 0.06308901449150202 },
            { 0.06308901449150207, 0.06308901449150207, 0.8738219710169959 },
            { 0.873821971016996, 0.06308901449150202, 0.06308901449150202 },
            { 0.249286745170911, 0.501426509658179, 0.24928674517091 },
            { 0.249286745170911, 0.24928674517091, 0.501426509658179 },
            { 0.50142650965818, 0.24928674517091, 0.24928674517091 },
            { 0.053145049844816, 0.636502499121399, 0.310352451033785 },
            { 0.310352451033785, 0.6365024991213991, 0.05314504984481597 },
            { 0.05314504984481604, 0.3103524510337851, 0.636502499121399 },
            { 0.6365024991213991, 0.310352451033785, 0.05314504984481597 },
            { 0.3103524510337851, 0.05314504984481604, 0.636502499121399 },
            { 0.636502499121399, 0.053145049844816, 0.310352451033785 } } };
    // Unstructured piecewise computations
    const double J_c0 = coordinate_dofs[0] * FE3_C0_D01_Q12[0][0][0] + coordinate_dofs[2] * FE3_C0_D01_Q12[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE3_C0_D01_Q12[0][0][0] + coordinate_dofs[5] * FE3_C0_D01_Q12[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE3_C0_D01_Q12[0][0][0] + coordinate_dofs[4] * FE3_C0_D01_Q12[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE3_C0_D01_Q12[0][0][0] + coordinate_dofs[3] * FE3_C0_D01_Q12[0][0][1];
    alignas(32) double sp[4];
    sp[0] = J_c0 * J_c3;
    sp[1] = J_c1 * J_c2;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = std::abs(sp[2]);
    alignas(32) double BF0 = {};
    for (int iq = 0; iq < 12; ++iq)
    {
        // Quadrature loop body setup (num_points=12)
        // Unstructured varying computations for num_points=12
        double w0 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0 += w[0][ic] * FE3_C0_Q12[0][iq][ic];
        alignas(32) double sv12[1];
        sv12[0] = std::pow(w0, 2) * sp[3];
        const double fw0 = sv12[0] * weights12[iq];
        BF0 += fw0;
    }
    A[0] = 0.0;
    A[0] += BF0;
}


imt_exterior_facet_integral_3_0::imt_exterior_facet_integral_3_0() : ufc::exterior_facet_integral()
{

}

imt_exterior_facet_integral_3_0::~imt_exterior_facet_integral_3_0()
{

}

const std::vector<bool> & imt_exterior_facet_integral_3_0::enabled_coefficients() const
{
static const std::vector<bool> enabled({true});
return enabled;
}

void imt_exterior_facet_integral_3_0::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    std::size_t facet,
                                    int cell_orientation) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 6
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 1
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           6
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Quadrature rules
    alignas(32) static const double weights4[4] = { 0.1739274225687268, 0.3260725774312731, 0.3260725774312731, 0.1739274225687268 };
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE3_C0_D01_F_Q4[1][1][2] = { { { -1.0, 1.0 } } };
    alignas(32) static const double FE3_C0_F_Q4[3][4][3] =
        { { { 0.0, 0.9305681557970263, 0.06943184420297369 },
            { 0.0, 0.6699905217924281, 0.3300094782075718 },
            { 0.0, 0.3300094782075719, 0.6699905217924279 },
            { 0.0, 0.06943184420297382, 0.9305681557970262 } },
          { { 0.9305681557970263, 0.0, 0.06943184420297369 },
            { 0.6699905217924281, 0.0, 0.3300094782075718 },
            { 0.3300094782075719, 0.0, 0.669990521792428 },
            { 0.06943184420297382, 0.0, 0.9305681557970262 } },
          { { 0.9305681557970263, 0.06943184420297367, 0.0 },
            { 0.6699905217924281, 0.3300094782075718, 0.0 },
            { 0.3300094782075719, 0.6699905217924281, 0.0 },
            { 0.06943184420297374, 0.9305681557970263, 0.0 } } };
    // Unstructured piecewise computations
    const double J_c0 = coordinate_dofs[0] * FE3_C0_D01_F_Q4[0][0][0] + coordinate_dofs[2] * FE3_C0_D01_F_Q4[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE3_C0_D01_F_Q4[0][0][0] + coordinate_dofs[4] * FE3_C0_D01_F_Q4[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE3_C0_D01_F_Q4[0][0][0] + coordinate_dofs[3] * FE3_C0_D01_F_Q4[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE3_C0_D01_F_Q4[0][0][0] + coordinate_dofs[5] * FE3_C0_D01_F_Q4[0][0][1];
    alignas(32) double sp[10];
    sp[0] = J_c0 * triangle_reference_facet_jacobian[facet][0][0];
    sp[1] = J_c1 * triangle_reference_facet_jacobian[facet][1][0];
    sp[2] = sp[0] + sp[1];
    sp[3] = sp[2] * sp[2];
    sp[4] = triangle_reference_facet_jacobian[facet][0][0] * J_c2;
    sp[5] = triangle_reference_facet_jacobian[facet][1][0] * J_c3;
    sp[6] = sp[4] + sp[5];
    sp[7] = sp[6] * sp[6];
    sp[8] = sp[3] + sp[7];
    sp[9] = std::sqrt(sp[8]);
    alignas(32) double BF0 = {};
    for (int iq = 0; iq < 4; ++iq)
    {
        // Quadrature loop body setup (num_points=4)
        // Unstructured varying computations for num_points=4
        double w0_c4 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c4 += w[0][ic + 12] * FE3_C0_F_Q4[facet][iq][ic];
        alignas(32) double sv4[1];
        sv4[0] = w0_c4 * sp[9];
        const double fw0 = sv4[0] * weights4[iq];
        BF0 += fw0;
    }
    A[0] = 0.0;
    A[0] += BF0;
}


imt_cell_integral_4_otherwise::imt_cell_integral_4_otherwise() : ufc::cell_integral()
{

}

imt_cell_integral_4_otherwise::~imt_cell_integral_4_otherwise()
{

}

const std::vector<bool> & imt_cell_integral_4_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({true});
return enabled;
}

void imt_cell_integral_4_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 6
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 1
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           6
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Quadrature rules
    alignas(32) static const double weights12[12] = { 0.0254224531851035, 0.0254224531851035, 0.0254224531851035, 0.0583931378631895, 0.0583931378631895, 0.0583931378631895, 0.041425537809187, 0.041425537809187, 0.041425537809187, 0.041425537809187, 0.041425537809187, 0.041425537809187 };
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE3_C0_D01_Q12[1][1][2] = { { { -1.0, 1.0 } } };
    alignas(32) static const double FE3_C0_Q12[1][12][3] =
        { { { 0.06308901449150202, 0.873821971016996, 0.06308901449150202 },
            { 0.06308901449150207, 0.06308901449150207, 0.8738219710169959 },
            { 0.873821971016996, 0.06308901449150202, 0.06308901449150202 },
            { 0.249286745170911, 0.501426509658179, 0.24928674517091 },
            { 0.249286745170911, 0.24928674517091, 0.501426509658179 },
            { 0.50142650965818, 0.24928674517091, 0.24928674517091 },
            { 0.053145049844816, 0.636502499121399, 0.310352451033785 },
            { 0.310352451033785, 0.6365024991213991, 0.05314504984481597 },
            { 0.05314504984481604, 0.3103524510337851, 0.636502499121399 },
            { 0.6365024991213991, 0.310352451033785, 0.05314504984481597 },
            { 0.3103524510337851, 0.05314504984481604, 0.636502499121399 },
            { 0.636502499121399, 0.053145049844816, 0.310352451033785 } } };
    // Unstructured piecewise computations
    const double J_c0 = coordinate_dofs[0] * FE3_C0_D01_Q12[0][0][0] + coordinate_dofs[2] * FE3_C0_D01_Q12[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE3_C0_D01_Q12[0][0][0] + coordinate_dofs[5] * FE3_C0_D01_Q12[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE3_C0_D01_Q12[0][0][0] + coordinate_dofs[4] * FE3_C0_D01_Q12[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE3_C0_D01_Q12[0][0][0] + coordinate_dofs[3] * FE3_C0_D01_Q12[0][0][1];
    alignas(32) double sp[4];
    sp[0] = J_c0 * J_c3;
    sp[1] = J_c1 * J_c2;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = std::abs(sp[2]);
    alignas(32) double BF0 = {};
    for (int iq = 0; iq < 12; ++iq)
    {
        // Quadrature loop body setup (num_points=12)
        // Unstructured varying computations for num_points=12
        double w0_c5 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c5 += w[0][ic + 15] * FE3_C0_Q12[0][iq][ic];
        alignas(32) double sv12[1];
        sv12[0] = w0_c5 * sp[3];
        const double fw0 = sv12[0] * weights12[iq];
        BF0 += fw0;
    }
    A[0] = 0.0;
    A[0] += BF0;
}


imt_cell_integral_5_otherwise::imt_cell_integral_5_otherwise() : ufc::cell_integral()
{

}

imt_cell_integral_5_otherwise::~imt_cell_integral_5_otherwise()
{

}

const std::vector<bool> & imt_cell_integral_5_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({});
return enabled;
}

void imt_cell_integral_5_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 6
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 2
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           6
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE3_C0_D01_Q12[1][1][2] = { { { -1.0, 1.0 } } };
    // Unstructured piecewise computations
    const double J_c0 = coordinate_dofs[0] * FE3_C0_D01_Q12[0][0][0] + coordinate_dofs[2] * FE3_C0_D01_Q12[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE3_C0_D01_Q12[0][0][0] + coordinate_dofs[5] * FE3_C0_D01_Q12[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE3_C0_D01_Q12[0][0][0] + coordinate_dofs[4] * FE3_C0_D01_Q12[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE3_C0_D01_Q12[0][0][0] + coordinate_dofs[3] * FE3_C0_D01_Q12[0][0][1];
    alignas(32) double sp[4];
    sp[0] = J_c0 * J_c3;
    sp[1] = J_c1 * J_c2;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = std::abs(sp[2]);
    A[0] = 0.08333333333333373 * sp[3];
    A[1] = 0.04166666666666671 * sp[3];
    A[2] = 0.04166666666666671 * sp[3];
    A[3] = 0.04166666666666671 * sp[3];
    A[4] = 0.08333333333333361 * sp[3];
    A[5] = 0.04166666666666665 * sp[3];
    A[6] = 0.04166666666666671 * sp[3];
    A[7] = 0.04166666666666665 * sp[3];
    A[8] = 0.08333333333333359 * sp[3];
}


imt_cell_integral_6_otherwise::imt_cell_integral_6_otherwise() : ufc::cell_integral()
{

}

imt_cell_integral_6_otherwise::~imt_cell_integral_6_otherwise()
{

}

const std::vector<bool> & imt_cell_integral_6_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, true, true, true, true, true, true, true, true, true});
return enabled;
}

void imt_cell_integral_6_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 6
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 5
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           6
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Quadrature rules
    alignas(32) static const double weights12[12] = { 0.0254224531851035, 0.0254224531851035, 0.0254224531851035, 0.0583931378631895, 0.0583931378631895, 0.0583931378631895, 0.041425537809187, 0.041425537809187, 0.041425537809187, 0.041425537809187, 0.041425537809187, 0.041425537809187 };
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE19_C0_D01_Q12[1][1][2] = { { { -1.0, 1.0 } } };
    alignas(32) static const double FE19_C0_Q12[1][12][3] =
        { { { 0.06308901449150202, 0.873821971016996, 0.06308901449150202 },
            { 0.06308901449150207, 0.06308901449150207, 0.8738219710169959 },
            { 0.873821971016996, 0.06308901449150202, 0.06308901449150202 },
            { 0.249286745170911, 0.501426509658179, 0.24928674517091 },
            { 0.249286745170911, 0.24928674517091, 0.501426509658179 },
            { 0.50142650965818, 0.24928674517091, 0.24928674517091 },
            { 0.053145049844816, 0.636502499121399, 0.310352451033785 },
            { 0.310352451033785, 0.6365024991213991, 0.05314504984481597 },
            { 0.05314504984481604, 0.3103524510337851, 0.636502499121399 },
            { 0.6365024991213991, 0.310352451033785, 0.05314504984481597 },
            { 0.3103524510337851, 0.05314504984481604, 0.636502499121399 },
            { 0.636502499121399, 0.053145049844816, 0.310352451033785 } } };
    // Unstructured piecewise computations
    const double w0_d1_c5 = w[0][15] * FE19_C0_D01_Q12[0][0][0] + w[0][17] * FE19_C0_D01_Q12[0][0][1];
    const double J_c0 = coordinate_dofs[0] * FE19_C0_D01_Q12[0][0][0] + coordinate_dofs[2] * FE19_C0_D01_Q12[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE19_C0_D01_Q12[0][0][0] + coordinate_dofs[5] * FE19_C0_D01_Q12[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE19_C0_D01_Q12[0][0][0] + coordinate_dofs[4] * FE19_C0_D01_Q12[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE19_C0_D01_Q12[0][0][0] + coordinate_dofs[3] * FE19_C0_D01_Q12[0][0][1];
    double w0_d0_c5 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c5 += w[0][ic + 15] * FE19_C0_D01_Q12[0][0][ic];
    const double w0_d1_c2 = w[0][6] * FE19_C0_D01_Q12[0][0][0] + w[0][8] * FE19_C0_D01_Q12[0][0][1];
    double w0_d0_c2 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c2 += w[0][ic + 6] * FE19_C0_D01_Q12[0][0][ic];
    const double w0_d1_c1 = w[0][3] * FE19_C0_D01_Q12[0][0][0] + w[0][5] * FE19_C0_D01_Q12[0][0][1];
    double w0_d0_c1 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c1 += w[0][ic + 3] * FE19_C0_D01_Q12[0][0][ic];
    const double w0_d1_c4 = w[0][12] * FE19_C0_D01_Q12[0][0][0] + w[0][14] * FE19_C0_D01_Q12[0][0][1];
    double w0_d0_c4 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c4 += w[0][ic + 12] * FE19_C0_D01_Q12[0][0][ic];
    const double w0_d1_c3 = w[0][9] * FE19_C0_D01_Q12[0][0][0] + w[0][11] * FE19_C0_D01_Q12[0][0][1];
    double w0_d0_c3 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c3 += w[0][ic + 9] * FE19_C0_D01_Q12[0][0][ic];
    alignas(32) double sp[44];
    sp[0] = J_c0 * J_c3;
    sp[1] = J_c1 * J_c2;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = J_c0 / sp[2];
    sp[4] = w0_d1_c5 * sp[3];
    sp[5] = -1 * J_c1 / sp[2];
    sp[6] = w0_d0_c5 * sp[5];
    sp[7] = sp[4] + sp[6];
    sp[8] = w0_d1_c2 * sp[3];
    sp[9] = w0_d0_c2 * sp[5];
    sp[10] = sp[8] + sp[9];
    sp[11] = w0_d1_c1 * sp[3];
    sp[12] = w0_d0_c1 * sp[5];
    sp[13] = sp[11] + sp[12];
    sp[14] = w0_d1_c4 * sp[3];
    sp[15] = w0_d0_c4 * sp[5];
    sp[16] = sp[14] + sp[15];
    sp[17] = sp[16] * w[2][0];
    sp[18] = w[6][0] / w[2][0];
    sp[19] = w0_d1_c3 * sp[3];
    sp[20] = w0_d0_c3 * sp[5];
    sp[21] = sp[19] + sp[20];
    sp[22] = w[8][0] / w[2][0];
    sp[23] = J_c3 / sp[2];
    sp[24] = w0_d0_c5 * sp[23];
    sp[25] = -1 * J_c2 / sp[2];
    sp[26] = w0_d1_c5 * sp[25];
    sp[27] = sp[24] + sp[26];
    sp[28] = w0_d0_c2 * sp[23];
    sp[29] = w0_d1_c2 * sp[25];
    sp[30] = sp[28] + sp[29];
    sp[31] = w0_d0_c1 * sp[23];
    sp[32] = w0_d1_c1 * sp[25];
    sp[33] = sp[31] + sp[32];
    sp[34] = w0_d0_c4 * sp[23];
    sp[35] = w0_d1_c4 * sp[25];
    sp[36] = sp[34] + sp[35];
    sp[37] = sp[36] * w[2][0];
    sp[38] = w[7][0] / w[2][0];
    sp[39] = w0_d0_c3 * sp[23];
    sp[40] = w0_d1_c3 * sp[25];
    sp[41] = sp[39] + sp[40];
    sp[42] = w[9][0] / w[2][0];
    sp[43] = std::abs(sp[2]);
    alignas(32) double BF0[2] = {};
    alignas(32) double BF1[2] = {};
    for (int iq = 0; iq < 12; ++iq)
    {
        // Quadrature loop body setup (num_points=12)
        // Unstructured varying computations for num_points=12
        double w0_c2 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c2 += w[0][ic + 6] * FE19_C0_Q12[0][iq][ic];
        double w0_c5 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c5 += w[0][ic + 15] * FE19_C0_Q12[0][iq][ic];
        double w0_c1 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c1 += w[0][ic + 3] * FE19_C0_Q12[0][iq][ic];
        double w0_c3 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c3 += w[0][ic + 9] * FE19_C0_Q12[0][iq][ic];
        alignas(32) double sv12[50];
        sv12[0] = w0_c2 * w[1][0];
        sv12[1] = sp[7] * sv12[0];
        sv12[2] = w0_c5 * w[1][0];
        sv12[3] = sp[10] * sv12[2];
        sv12[4] = sv12[1] + sv12[3];
        sv12[5] = w0_c1 * w[3][0];
        sv12[6] = sp[13] * sv12[5];
        sv12[7] = sv12[4] + sv12[6];
        sv12[8] = sv12[7] + -1 * sp[17];
        sv12[9] = std::exp(-1 * w0_c2);
        sv12[10] = 1.32934038825 * std::pow(4 + std::pow(w0_c2, 2), -0.75) + sv12[9];
        sv12[11] = 1 / sv12[10] * w[4][0];
        sv12[12] = -1 * sv12[11] * sp[18];
        sv12[13] = sv12[8] * sv12[12];
        sv12[14] = w0_c3 * w[1][0];
        sv12[15] = sp[7] * sv12[14];
        sv12[16] = sp[21] * sv12[2];
        sv12[17] = sv12[15] + sv12[16];
        sv12[18] = sv12[17] + sv12[6];
        sv12[19] = sv12[18] + sp[17];
        sv12[20] = std::exp(-1 * w0_c3);
        sv12[21] = 1.32934038825 * std::pow(4 + std::pow(w0_c3, 2), -0.75) + sv12[20];
        sv12[22] = 1 / sv12[21] * w[5][0];
        sv12[23] = -1 * sv12[22] * sp[22];
        sv12[24] = sv12[19] * sv12[23];
        sv12[25] = sv12[13] + sv12[24];
        sv12[26] = sv12[25] * sp[3];
        sv12[27] = sv12[25] * sp[5];
        sv12[28] = sp[27] * sv12[0];
        sv12[29] = sp[30] * sv12[2];
        sv12[30] = sv12[28] + sv12[29];
        sv12[31] = sp[33] * sv12[5];
        sv12[32] = sv12[30] + sv12[31];
        sv12[33] = sv12[32] + -1 * sp[37];
        sv12[34] = -1 * sv12[11] * sp[38];
        sv12[35] = sv12[33] * sv12[34];
        sv12[36] = sp[27] * sv12[14];
        sv12[37] = sp[41] * sv12[2];
        sv12[38] = sv12[36] + sv12[37];
        sv12[39] = sv12[38] + sv12[31];
        sv12[40] = sv12[39] + sp[37];
        sv12[41] = -1 * sv12[22] * sp[42];
        sv12[42] = sv12[40] * sv12[41];
        sv12[43] = sv12[35] + sv12[42];
        sv12[44] = sv12[43] * sp[25];
        sv12[45] = sv12[43] * sp[23];
        sv12[46] = sv12[26] + sv12[44];
        sv12[47] = sv12[45] + sv12[27];
        sv12[48] = sv12[46] * sp[43];
        sv12[49] = sv12[47] * sp[43];
        const double fw0 = sv12[49] * weights12[iq];
        for (int i = 0; i < 2; ++i)
            BF0[i] += fw0 * FE19_C0_D01_Q12[0][0][i];
        const double fw1 = sv12[48] * weights12[iq];
        for (int i = 0; i < 2; ++i)
            BF1[i] += fw1 * FE19_C0_D01_Q12[0][0][i];
    }
    std::fill(A, A + 3, 0.0);
    static const int DM0[2] = { 0, 2 };
    for (int i = 0; i < 2; ++i)
        A[i] += BF0[i];
    for (int i = 0; i < 2; ++i)
        A[DM0[i]] += BF1[i];
}


imt_exterior_facet_integral_6_0::imt_exterior_facet_integral_6_0() : ufc::exterior_facet_integral()
{

}

imt_exterior_facet_integral_6_0::~imt_exterior_facet_integral_6_0()
{

}

const std::vector<bool> & imt_exterior_facet_integral_6_0::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, true, true, true, true, true, true, false, true, false});
return enabled;
}

void imt_exterior_facet_integral_6_0::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    std::size_t facet,
                                    int cell_orientation) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 6
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 6
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           6
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Quadrature rules
    alignas(32) static const double weights4[4] = { 0.1739274225687268, 0.3260725774312731, 0.3260725774312731, 0.1739274225687268 };
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE19_C0_D01_F_Q4[1][1][2] = { { { -1.0, 1.0 } } };
    alignas(32) static const double FE19_C0_F_Q4[3][4][3] =
        { { { 0.0, 0.9305681557970263, 0.06943184420297369 },
            { 0.0, 0.6699905217924281, 0.3300094782075718 },
            { 0.0, 0.3300094782075719, 0.6699905217924279 },
            { 0.0, 0.06943184420297382, 0.9305681557970262 } },
          { { 0.9305681557970263, 0.0, 0.06943184420297369 },
            { 0.6699905217924281, 0.0, 0.3300094782075718 },
            { 0.3300094782075719, 0.0, 0.669990521792428 },
            { 0.06943184420297382, 0.0, 0.9305681557970262 } },
          { { 0.9305681557970263, 0.06943184420297367, 0.0 },
            { 0.6699905217924281, 0.3300094782075718, 0.0 },
            { 0.3300094782075719, 0.6699905217924281, 0.0 },
            { 0.06943184420297374, 0.9305681557970263, 0.0 } } };
    // Unstructured piecewise computations
    const double w0_d1_c5 = w[0][15] * FE19_C0_D01_F_Q4[0][0][0] + w[0][17] * FE19_C0_D01_F_Q4[0][0][1];
    const double J_c0 = coordinate_dofs[0] * FE19_C0_D01_F_Q4[0][0][0] + coordinate_dofs[2] * FE19_C0_D01_F_Q4[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE19_C0_D01_F_Q4[0][0][0] + coordinate_dofs[5] * FE19_C0_D01_F_Q4[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE19_C0_D01_F_Q4[0][0][0] + coordinate_dofs[4] * FE19_C0_D01_F_Q4[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE19_C0_D01_F_Q4[0][0][0] + coordinate_dofs[3] * FE19_C0_D01_F_Q4[0][0][1];
    double w0_d0_c5 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c5 += w[0][ic + 15] * FE19_C0_D01_F_Q4[0][0][ic];
    const double w0_d1_c2 = w[0][6] * FE19_C0_D01_F_Q4[0][0][0] + w[0][8] * FE19_C0_D01_F_Q4[0][0][1];
    double w0_d0_c2 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c2 += w[0][ic + 6] * FE19_C0_D01_F_Q4[0][0][ic];
    const double w0_d1_c1 = w[0][3] * FE19_C0_D01_F_Q4[0][0][0] + w[0][5] * FE19_C0_D01_F_Q4[0][0][1];
    double w0_d0_c1 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c1 += w[0][ic + 3] * FE19_C0_D01_F_Q4[0][0][ic];
    const double w0_d1_c4 = w[0][12] * FE19_C0_D01_F_Q4[0][0][0] + w[0][14] * FE19_C0_D01_F_Q4[0][0][1];
    double w0_d0_c4 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c4 += w[0][ic + 12] * FE19_C0_D01_F_Q4[0][0][ic];
    const double w0_d1_c3 = w[0][9] * FE19_C0_D01_F_Q4[0][0][0] + w[0][11] * FE19_C0_D01_F_Q4[0][0][1];
    double w0_d0_c3 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c3 += w[0][ic + 9] * FE19_C0_D01_F_Q4[0][0][ic];
    alignas(32) double sp[33];
    sp[0] = J_c0 * J_c3;
    sp[1] = J_c1 * J_c2;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = J_c0 / sp[2];
    sp[4] = w0_d1_c5 * sp[3];
    sp[5] = -1 * J_c1 / sp[2];
    sp[6] = w0_d0_c5 * sp[5];
    sp[7] = sp[4] + sp[6];
    sp[8] = w0_d1_c2 * sp[3];
    sp[9] = w0_d0_c2 * sp[5];
    sp[10] = sp[8] + sp[9];
    sp[11] = w0_d1_c1 * sp[3];
    sp[12] = w0_d0_c1 * sp[5];
    sp[13] = sp[11] + sp[12];
    sp[14] = w0_d1_c4 * sp[3];
    sp[15] = w0_d0_c4 * sp[5];
    sp[16] = sp[14] + sp[15];
    sp[17] = sp[16] * w[2][0];
    sp[18] = w[6][0] / w[2][0];
    sp[19] = w0_d1_c3 * sp[3];
    sp[20] = w0_d0_c3 * sp[5];
    sp[21] = sp[19] + sp[20];
    sp[22] = w[8][0] / w[2][0];
    sp[23] = J_c0 * triangle_reference_facet_jacobian[facet][0][0];
    sp[24] = J_c1 * triangle_reference_facet_jacobian[facet][1][0];
    sp[25] = sp[23] + sp[24];
    sp[26] = sp[25] * sp[25];
    sp[27] = triangle_reference_facet_jacobian[facet][0][0] * J_c2;
    sp[28] = triangle_reference_facet_jacobian[facet][1][0] * J_c3;
    sp[29] = sp[27] + sp[28];
    sp[30] = sp[29] * sp[29];
    sp[31] = sp[26] + sp[30];
    sp[32] = std::sqrt(sp[31]);
    alignas(32) double BF0[3] = {};
    for (int iq = 0; iq < 4; ++iq)
    {
        // Quadrature loop body setup (num_points=4)
        // Unstructured varying computations for num_points=4
        double w0_c2 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c2 += w[0][ic + 6] * FE19_C0_F_Q4[facet][iq][ic];
        double w0_c5 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c5 += w[0][ic + 15] * FE19_C0_F_Q4[facet][iq][ic];
        double w0_c1 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c1 += w[0][ic + 3] * FE19_C0_F_Q4[facet][iq][ic];
        double w0_c3 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c3 += w[0][ic + 9] * FE19_C0_F_Q4[facet][iq][ic];
        alignas(32) double sv4[27];
        sv4[0] = w0_c2 * w[1][0];
        sv4[1] = sp[7] * sv4[0];
        sv4[2] = w0_c5 * w[1][0];
        sv4[3] = sp[10] * sv4[2];
        sv4[4] = sv4[1] + sv4[3];
        sv4[5] = w0_c1 * w[3][0];
        sv4[6] = sp[13] * sv4[5];
        sv4[7] = sv4[4] + sv4[6];
        sv4[8] = sv4[7] + -1 * sp[17];
        sv4[9] = std::exp(-1 * w0_c2);
        sv4[10] = 1.32934038825 * std::pow(4 + std::pow(w0_c2, 2), -0.75) + sv4[9];
        sv4[11] = 1 / sv4[10] * w[4][0];
        sv4[12] = -1 * sv4[11] * sp[18];
        sv4[13] = sv4[8] * sv4[12];
        sv4[14] = w0_c3 * w[1][0];
        sv4[15] = sp[7] * sv4[14];
        sv4[16] = sp[21] * sv4[2];
        sv4[17] = sv4[15] + sv4[16];
        sv4[18] = sv4[17] + sv4[6];
        sv4[19] = sv4[18] + sp[17];
        sv4[20] = std::exp(-1 * w0_c3);
        sv4[21] = 1.32934038825 * std::pow(4 + std::pow(w0_c3, 2), -0.75) + sv4[20];
        sv4[22] = 1 / sv4[21] * w[5][0];
        sv4[23] = -1 * sv4[22] * sp[22];
        sv4[24] = sv4[19] * sv4[23];
        sv4[25] = sv4[13] + sv4[24];
        sv4[26] = sv4[25] * sp[32];
        const double fw0 = sv4[26] * weights4[iq];
        for (int i = 0; i < 3; ++i)
            BF0[i] += fw0 * FE19_C0_F_Q4[facet][iq][i];
    }
    std::fill(A, A + 3, 0.0);
    for (int i = 0; i < 3; ++i)
        A[i] += BF0[i];
}


imt_exterior_facet_integral_6_1::imt_exterior_facet_integral_6_1() : ufc::exterior_facet_integral()
{

}

imt_exterior_facet_integral_6_1::~imt_exterior_facet_integral_6_1()
{

}

const std::vector<bool> & imt_exterior_facet_integral_6_1::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, true, true, true, true, true, true, false, true, false});
return enabled;
}

void imt_exterior_facet_integral_6_1::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    std::size_t facet,
                                    int cell_orientation) const
{
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 6
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 6
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           6
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Quadrature rules
    alignas(32) static const double weights4[4] = { 0.1739274225687268, 0.3260725774312731, 0.3260725774312731, 0.1739274225687268 };
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE19_C0_D01_F_Q4[1][1][2] = { { { -1.0, 1.0 } } };
    alignas(32) static const double FE19_C0_F_Q4[3][4][3] =
        { { { 0.0, 0.9305681557970263, 0.06943184420297369 },
            { 0.0, 0.6699905217924281, 0.3300094782075718 },
            { 0.0, 0.3300094782075719, 0.6699905217924279 },
            { 0.0, 0.06943184420297382, 0.9305681557970262 } },
          { { 0.9305681557970263, 0.0, 0.06943184420297369 },
            { 0.6699905217924281, 0.0, 0.3300094782075718 },
            { 0.3300094782075719, 0.0, 0.669990521792428 },
            { 0.06943184420297382, 0.0, 0.9305681557970262 } },
          { { 0.9305681557970263, 0.06943184420297367, 0.0 },
            { 0.6699905217924281, 0.3300094782075718, 0.0 },
            { 0.3300094782075719, 0.6699905217924281, 0.0 },
            { 0.06943184420297374, 0.9305681557970263, 0.0 } } };
    // Unstructured piecewise computations
    const double w0_d1_c5 = w[0][15] * FE19_C0_D01_F_Q4[0][0][0] + w[0][17] * FE19_C0_D01_F_Q4[0][0][1];
    const double J_c0 = coordinate_dofs[0] * FE19_C0_D01_F_Q4[0][0][0] + coordinate_dofs[2] * FE19_C0_D01_F_Q4[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE19_C0_D01_F_Q4[0][0][0] + coordinate_dofs[5] * FE19_C0_D01_F_Q4[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE19_C0_D01_F_Q4[0][0][0] + coordinate_dofs[4] * FE19_C0_D01_F_Q4[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE19_C0_D01_F_Q4[0][0][0] + coordinate_dofs[3] * FE19_C0_D01_F_Q4[0][0][1];
    double w0_d0_c5 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c5 += w[0][ic + 15] * FE19_C0_D01_F_Q4[0][0][ic];
    const double w0_d1_c2 = w[0][6] * FE19_C0_D01_F_Q4[0][0][0] + w[0][8] * FE19_C0_D01_F_Q4[0][0][1];
    double w0_d0_c2 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c2 += w[0][ic + 6] * FE19_C0_D01_F_Q4[0][0][ic];
    const double w0_d1_c1 = w[0][3] * FE19_C0_D01_F_Q4[0][0][0] + w[0][5] * FE19_C0_D01_F_Q4[0][0][1];
    double w0_d0_c1 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c1 += w[0][ic + 3] * FE19_C0_D01_F_Q4[0][0][ic];
    const double w0_d1_c4 = w[0][12] * FE19_C0_D01_F_Q4[0][0][0] + w[0][14] * FE19_C0_D01_F_Q4[0][0][1];
    double w0_d0_c4 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c4 += w[0][ic + 12] * FE19_C0_D01_F_Q4[0][0][ic];
    const double w0_d1_c3 = w[0][9] * FE19_C0_D01_F_Q4[0][0][0] + w[0][11] * FE19_C0_D01_F_Q4[0][0][1];
    double w0_d0_c3 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c3 += w[0][ic + 9] * FE19_C0_D01_F_Q4[0][0][ic];
    alignas(32) double sp[33];
    sp[0] = J_c0 * J_c3;
    sp[1] = J_c1 * J_c2;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = J_c0 / sp[2];
    sp[4] = w0_d1_c5 * sp[3];
    sp[5] = -1 * J_c1 / sp[2];
    sp[6] = w0_d0_c5 * sp[5];
    sp[7] = sp[4] + sp[6];
    sp[8] = w0_d1_c2 * sp[3];
    sp[9] = w0_d0_c2 * sp[5];
    sp[10] = sp[8] + sp[9];
    sp[11] = w0_d1_c1 * sp[3];
    sp[12] = w0_d0_c1 * sp[5];
    sp[13] = sp[11] + sp[12];
    sp[14] = w0_d1_c4 * sp[3];
    sp[15] = w0_d0_c4 * sp[5];
    sp[16] = sp[14] + sp[15];
    sp[17] = sp[16] * w[2][0];
    sp[18] = w[6][0] / w[2][0];
    sp[19] = w0_d1_c3 * sp[3];
    sp[20] = w0_d0_c3 * sp[5];
    sp[21] = sp[19] + sp[20];
    sp[22] = w[8][0] / w[2][0];
    sp[23] = J_c0 * triangle_reference_facet_jacobian[facet][0][0];
    sp[24] = J_c1 * triangle_reference_facet_jacobian[facet][1][0];
    sp[25] = sp[23] + sp[24];
    sp[26] = sp[25] * sp[25];
    sp[27] = triangle_reference_facet_jacobian[facet][0][0] * J_c2;
    sp[28] = triangle_reference_facet_jacobian[facet][1][0] * J_c3;
    sp[29] = sp[27] + sp[28];
    sp[30] = sp[29] * sp[29];
    sp[31] = sp[26] + sp[30];
    sp[32] = std::sqrt(sp[31]);
    alignas(32) double BF0[3] = {};
    for (int iq = 0; iq < 4; ++iq)
    {
        // Quadrature loop body setup (num_points=4)
        // Unstructured varying computations for num_points=4
        double w0_c2 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c2 += w[0][ic + 6] * FE19_C0_F_Q4[facet][iq][ic];
        double w0_c5 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c5 += w[0][ic + 15] * FE19_C0_F_Q4[facet][iq][ic];
        double w0_c1 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c1 += w[0][ic + 3] * FE19_C0_F_Q4[facet][iq][ic];
        double w0_c3 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c3 += w[0][ic + 9] * FE19_C0_F_Q4[facet][iq][ic];
        alignas(32) double sv4[27];
        sv4[0] = w0_c2 * w[1][0];
        sv4[1] = sp[7] * sv4[0];
        sv4[2] = w0_c5 * w[1][0];
        sv4[3] = sp[10] * sv4[2];
        sv4[4] = sv4[1] + sv4[3];
        sv4[5] = w0_c1 * w[3][0];
        sv4[6] = sp[13] * sv4[5];
        sv4[7] = sv4[4] + sv4[6];
        sv4[8] = sv4[7] + -1 * sp[17];
        sv4[9] = std::exp(-1 * w0_c2);
        sv4[10] = 1.32934038825 * std::pow(4 + std::pow(w0_c2, 2), -0.75) + sv4[9];
        sv4[11] = 1 / sv4[10] * w[4][0];
        sv4[12] = -1 * sv4[11] * sp[18];
        sv4[13] = sv4[8] * sv4[12];
        sv4[14] = w0_c3 * w[1][0];
        sv4[15] = sp[7] * sv4[14];
        sv4[16] = sp[21] * sv4[2];
        sv4[17] = sv4[15] + sv4[16];
        sv4[18] = sv4[17] + sv4[6];
        sv4[19] = sv4[18] + sp[17];
        sv4[20] = std::exp(-1 * w0_c3);
        sv4[21] = 1.32934038825 * std::pow(4 + std::pow(w0_c3, 2), -0.75) + sv4[20];
        sv4[22] = 1 / sv4[21] * w[5][0];
        sv4[23] = -1 * sv4[22] * sp[22];
        sv4[24] = sv4[19] * sv4[23];
        sv4[25] = sv4[13] + sv4[24];
        sv4[26] = -1 * sv4[25] * sp[32];
        const double fw0 = sv4[26] * weights4[iq];
        for (int i = 0; i < 3; ++i)
            BF0[i] += fw0 * FE19_C0_F_Q4[facet][iq][i];
    }
    std::fill(A, A + 3, 0.0);
    for (int i = 0; i < 3; ++i)
        A[i] += BF0[i];
}


imt_form_0::imt_form_0() : ufc::form()
{
    // Do nothing
}

imt_form_0::~imt_form_0()
{
    // Do nothing
}

const char * imt_form_0::signature() const
{
    return "eeb86effc30e49849e24789f9ce77148ff7f3da207fe8d555c42571b1e303486aa00fb0e2f1849642fef404333cd2935610cd0e339202e5599226d5ed8577178";
}

std::size_t imt_form_0::rank() const
{
    return 1;
}

std::size_t imt_form_0::num_coefficients() const
{
    return 45;
}

std::size_t imt_form_0::original_coefficient_position(std::size_t i) const
{
    if (i >= 45)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44};
    return position[i];
}

ufc::finite_element * imt_form_0::create_coordinate_finite_element() const
{
    return new imt_finite_element_1();
}

ufc::dofmap * imt_form_0::create_coordinate_dofmap() const
{
    return new imt_dofmap_1();
}

ufc::coordinate_mapping * imt_form_0::create_coordinate_mapping() const
{
    return new imt_coordinate_mapping_1();
}

ufc::finite_element * imt_form_0::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new imt_finite_element_3();
    case 1:
        return new imt_finite_element_3();
    case 2:
        return new imt_finite_element_3();
    case 3:
        return new imt_finite_element_2();
    case 4:
        return new imt_finite_element_2();
    case 5:
        return new imt_finite_element_2();
    case 6:
        return new imt_finite_element_2();
    case 7:
        return new imt_finite_element_2();
    case 8:
        return new imt_finite_element_2();
    case 9:
        return new imt_finite_element_2();
    case 10:
        return new imt_finite_element_2();
    case 11:
        return new imt_finite_element_2();
    case 12:
        return new imt_finite_element_2();
    case 13:
        return new imt_finite_element_2();
    case 14:
        return new imt_finite_element_2();
    case 15:
        return new imt_finite_element_2();
    case 16:
        return new imt_finite_element_2();
    case 17:
        return new imt_finite_element_2();
    case 18:
        return new imt_finite_element_2();
    case 19:
        return new imt_finite_element_2();
    case 20:
        return new imt_finite_element_2();
    case 21:
        return new imt_finite_element_2();
    case 22:
        return new imt_finite_element_2();
    case 23:
        return new imt_finite_element_2();
    case 24:
        return new imt_finite_element_2();
    case 25:
        return new imt_finite_element_2();
    case 26:
        return new imt_finite_element_2();
    case 27:
        return new imt_finite_element_2();
    case 28:
        return new imt_finite_element_2();
    case 29:
        return new imt_finite_element_2();
    case 30:
        return new imt_finite_element_2();
    case 31:
        return new imt_finite_element_2();
    case 32:
        return new imt_finite_element_2();
    case 33:
        return new imt_finite_element_2();
    case 34:
        return new imt_finite_element_2();
    case 35:
        return new imt_finite_element_2();
    case 36:
        return new imt_finite_element_2();
    case 37:
        return new imt_finite_element_2();
    case 38:
        return new imt_finite_element_2();
    case 39:
        return new imt_finite_element_2();
    case 40:
        return new imt_finite_element_2();
    case 41:
        return new imt_finite_element_2();
    case 42:
        return new imt_finite_element_2();
    case 43:
        return new imt_finite_element_2();
    case 44:
        return new imt_finite_element_2();
    case 45:
        return new imt_finite_element_0();
    default:
        return nullptr;
    }
}

ufc::dofmap * imt_form_0::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new imt_dofmap_3();
    case 1:
        return new imt_dofmap_3();
    case 2:
        return new imt_dofmap_3();
    case 3:
        return new imt_dofmap_2();
    case 4:
        return new imt_dofmap_2();
    case 5:
        return new imt_dofmap_2();
    case 6:
        return new imt_dofmap_2();
    case 7:
        return new imt_dofmap_2();
    case 8:
        return new imt_dofmap_2();
    case 9:
        return new imt_dofmap_2();
    case 10:
        return new imt_dofmap_2();
    case 11:
        return new imt_dofmap_2();
    case 12:
        return new imt_dofmap_2();
    case 13:
        return new imt_dofmap_2();
    case 14:
        return new imt_dofmap_2();
    case 15:
        return new imt_dofmap_2();
    case 16:
        return new imt_dofmap_2();
    case 17:
        return new imt_dofmap_2();
    case 18:
        return new imt_dofmap_2();
    case 19:
        return new imt_dofmap_2();
    case 20:
        return new imt_dofmap_2();
    case 21:
        return new imt_dofmap_2();
    case 22:
        return new imt_dofmap_2();
    case 23:
        return new imt_dofmap_2();
    case 24:
        return new imt_dofmap_2();
    case 25:
        return new imt_dofmap_2();
    case 26:
        return new imt_dofmap_2();
    case 27:
        return new imt_dofmap_2();
    case 28:
        return new imt_dofmap_2();
    case 29:
        return new imt_dofmap_2();
    case 30:
        return new imt_dofmap_2();
    case 31:
        return new imt_dofmap_2();
    case 32:
        return new imt_dofmap_2();
    case 33:
        return new imt_dofmap_2();
    case 34:
        return new imt_dofmap_2();
    case 35:
        return new imt_dofmap_2();
    case 36:
        return new imt_dofmap_2();
    case 37:
        return new imt_dofmap_2();
    case 38:
        return new imt_dofmap_2();
    case 39:
        return new imt_dofmap_2();
    case 40:
        return new imt_dofmap_2();
    case 41:
        return new imt_dofmap_2();
    case 42:
        return new imt_dofmap_2();
    case 43:
        return new imt_dofmap_2();
    case 44:
        return new imt_dofmap_2();
    case 45:
        return new imt_dofmap_0();
    default:
        return nullptr;
    }
}

std::size_t imt_form_0::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_0::max_exterior_facet_subdomain_id() const
{
    return 2;
}

std::size_t imt_form_0::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_0::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_0::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_0::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_0::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_0::max_overlap_subdomain_id() const
{
    return 0;
}

bool imt_form_0::has_cell_integrals() const
{
    return true;
}

bool imt_form_0::has_exterior_facet_integrals() const
{
    return true;
}

bool imt_form_0::has_interior_facet_integrals() const
{
    return false;
}

bool imt_form_0::has_vertex_integrals() const
{
    return false;
}

bool imt_form_0::has_custom_integrals() const
{
    return false;
}

bool imt_form_0::has_cutcell_integrals() const
{
    return false;
}

bool imt_form_0::has_interface_integrals() const
{
    return false;
}

bool imt_form_0::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * imt_form_0::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * imt_form_0::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    switch (subdomain_id)
    {
    case 0:
        return new imt_exterior_facet_integral_0_0();
    case 1:
        return new imt_exterior_facet_integral_0_1();
    default:
        return nullptr;
    }
}

ufc::interior_facet_integral * imt_form_0::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * imt_form_0::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * imt_form_0::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * imt_form_0::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * imt_form_0::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * imt_form_0::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * imt_form_0::create_default_cell_integral() const
{
    return new imt_cell_integral_0_otherwise();
}

ufc::exterior_facet_integral * imt_form_0::create_default_exterior_facet_integral() const
{
    return new imt_exterior_facet_integral_0_otherwise();
}

ufc::interior_facet_integral * imt_form_0::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * imt_form_0::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * imt_form_0::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * imt_form_0::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * imt_form_0::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * imt_form_0::create_default_overlap_integral() const
{
    return nullptr;
}


imt_form_1::imt_form_1() : ufc::form()
{
    // Do nothing
}

imt_form_1::~imt_form_1()
{
    // Do nothing
}

const char * imt_form_1::signature() const
{
    return "ffaeed7268a2e2dd2c078dfaf4ac158395bff5117c5ac39a6127b092606ccee49ef7afe849ae5d48bc8e74b567d8497b4e3c0dae7cd5f013251b0ef013e6cfb5";
}

std::size_t imt_form_1::rank() const
{
    return 2;
}

std::size_t imt_form_1::num_coefficients() const
{
    return 41;
}

std::size_t imt_form_1::original_coefficient_position(std::size_t i) const
{
    if (i >= 41)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 38, 39, 42, 43, 44};
    return position[i];
}

ufc::finite_element * imt_form_1::create_coordinate_finite_element() const
{
    return new imt_finite_element_1();
}

ufc::dofmap * imt_form_1::create_coordinate_dofmap() const
{
    return new imt_dofmap_1();
}

ufc::coordinate_mapping * imt_form_1::create_coordinate_mapping() const
{
    return new imt_coordinate_mapping_1();
}

ufc::finite_element * imt_form_1::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new imt_finite_element_3();
    case 1:
        return new imt_finite_element_3();
    case 2:
        return new imt_finite_element_3();
    case 3:
        return new imt_finite_element_3();
    case 4:
        return new imt_finite_element_2();
    case 5:
        return new imt_finite_element_2();
    case 6:
        return new imt_finite_element_2();
    case 7:
        return new imt_finite_element_2();
    case 8:
        return new imt_finite_element_2();
    case 9:
        return new imt_finite_element_2();
    case 10:
        return new imt_finite_element_2();
    case 11:
        return new imt_finite_element_2();
    case 12:
        return new imt_finite_element_2();
    case 13:
        return new imt_finite_element_2();
    case 14:
        return new imt_finite_element_2();
    case 15:
        return new imt_finite_element_2();
    case 16:
        return new imt_finite_element_2();
    case 17:
        return new imt_finite_element_2();
    case 18:
        return new imt_finite_element_2();
    case 19:
        return new imt_finite_element_2();
    case 20:
        return new imt_finite_element_2();
    case 21:
        return new imt_finite_element_2();
    case 22:
        return new imt_finite_element_2();
    case 23:
        return new imt_finite_element_2();
    case 24:
        return new imt_finite_element_2();
    case 25:
        return new imt_finite_element_2();
    case 26:
        return new imt_finite_element_2();
    case 27:
        return new imt_finite_element_2();
    case 28:
        return new imt_finite_element_2();
    case 29:
        return new imt_finite_element_2();
    case 30:
        return new imt_finite_element_2();
    case 31:
        return new imt_finite_element_2();
    case 32:
        return new imt_finite_element_2();
    case 33:
        return new imt_finite_element_2();
    case 34:
        return new imt_finite_element_2();
    case 35:
        return new imt_finite_element_2();
    case 36:
        return new imt_finite_element_2();
    case 37:
        return new imt_finite_element_2();
    case 38:
        return new imt_finite_element_2();
    case 39:
        return new imt_finite_element_2();
    case 40:
        return new imt_finite_element_2();
    case 41:
        return new imt_finite_element_2();
    case 42:
        return new imt_finite_element_0();
    default:
        return nullptr;
    }
}

ufc::dofmap * imt_form_1::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new imt_dofmap_3();
    case 1:
        return new imt_dofmap_3();
    case 2:
        return new imt_dofmap_3();
    case 3:
        return new imt_dofmap_3();
    case 4:
        return new imt_dofmap_2();
    case 5:
        return new imt_dofmap_2();
    case 6:
        return new imt_dofmap_2();
    case 7:
        return new imt_dofmap_2();
    case 8:
        return new imt_dofmap_2();
    case 9:
        return new imt_dofmap_2();
    case 10:
        return new imt_dofmap_2();
    case 11:
        return new imt_dofmap_2();
    case 12:
        return new imt_dofmap_2();
    case 13:
        return new imt_dofmap_2();
    case 14:
        return new imt_dofmap_2();
    case 15:
        return new imt_dofmap_2();
    case 16:
        return new imt_dofmap_2();
    case 17:
        return new imt_dofmap_2();
    case 18:
        return new imt_dofmap_2();
    case 19:
        return new imt_dofmap_2();
    case 20:
        return new imt_dofmap_2();
    case 21:
        return new imt_dofmap_2();
    case 22:
        return new imt_dofmap_2();
    case 23:
        return new imt_dofmap_2();
    case 24:
        return new imt_dofmap_2();
    case 25:
        return new imt_dofmap_2();
    case 26:
        return new imt_dofmap_2();
    case 27:
        return new imt_dofmap_2();
    case 28:
        return new imt_dofmap_2();
    case 29:
        return new imt_dofmap_2();
    case 30:
        return new imt_dofmap_2();
    case 31:
        return new imt_dofmap_2();
    case 32:
        return new imt_dofmap_2();
    case 33:
        return new imt_dofmap_2();
    case 34:
        return new imt_dofmap_2();
    case 35:
        return new imt_dofmap_2();
    case 36:
        return new imt_dofmap_2();
    case 37:
        return new imt_dofmap_2();
    case 38:
        return new imt_dofmap_2();
    case 39:
        return new imt_dofmap_2();
    case 40:
        return new imt_dofmap_2();
    case 41:
        return new imt_dofmap_2();
    case 42:
        return new imt_dofmap_0();
    default:
        return nullptr;
    }
}

std::size_t imt_form_1::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_1::max_exterior_facet_subdomain_id() const
{
    return 2;
}

std::size_t imt_form_1::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_1::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_1::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_1::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_1::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_1::max_overlap_subdomain_id() const
{
    return 0;
}

bool imt_form_1::has_cell_integrals() const
{
    return true;
}

bool imt_form_1::has_exterior_facet_integrals() const
{
    return true;
}

bool imt_form_1::has_interior_facet_integrals() const
{
    return false;
}

bool imt_form_1::has_vertex_integrals() const
{
    return false;
}

bool imt_form_1::has_custom_integrals() const
{
    return false;
}

bool imt_form_1::has_cutcell_integrals() const
{
    return false;
}

bool imt_form_1::has_interface_integrals() const
{
    return false;
}

bool imt_form_1::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * imt_form_1::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * imt_form_1::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    switch (subdomain_id)
    {
    case 0:
        return new imt_exterior_facet_integral_1_0();
    case 1:
        return new imt_exterior_facet_integral_1_1();
    default:
        return nullptr;
    }
}

ufc::interior_facet_integral * imt_form_1::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * imt_form_1::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * imt_form_1::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * imt_form_1::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * imt_form_1::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * imt_form_1::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * imt_form_1::create_default_cell_integral() const
{
    return new imt_cell_integral_1_otherwise();
}

ufc::exterior_facet_integral * imt_form_1::create_default_exterior_facet_integral() const
{
    return new imt_exterior_facet_integral_1_otherwise();
}

ufc::interior_facet_integral * imt_form_1::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * imt_form_1::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * imt_form_1::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * imt_form_1::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * imt_form_1::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * imt_form_1::create_default_overlap_integral() const
{
    return nullptr;
}


imt_form_2::imt_form_2() : ufc::form()
{
    // Do nothing
}

imt_form_2::~imt_form_2()
{
    // Do nothing
}

const char * imt_form_2::signature() const
{
    return "edb3ce5fd8542174e5a46a4fd1132b2fd7bedebf359cd8520aa4b7a9a019828bc1767e11279516072cdb269920cf227ad491b7e7b07772dce90e356769bba763";
}

std::size_t imt_form_2::rank() const
{
    return 0;
}

std::size_t imt_form_2::num_coefficients() const
{
    return 1;
}

std::size_t imt_form_2::original_coefficient_position(std::size_t i) const
{
    if (i >= 1)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0};
    return position[i];
}

ufc::finite_element * imt_form_2::create_coordinate_finite_element() const
{
    return new imt_finite_element_1();
}

ufc::dofmap * imt_form_2::create_coordinate_dofmap() const
{
    return new imt_dofmap_1();
}

ufc::coordinate_mapping * imt_form_2::create_coordinate_mapping() const
{
    return new imt_coordinate_mapping_1();
}

ufc::finite_element * imt_form_2::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new imt_finite_element_0();
    default:
        return nullptr;
    }
}

ufc::dofmap * imt_form_2::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new imt_dofmap_0();
    default:
        return nullptr;
    }
}

std::size_t imt_form_2::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_2::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_2::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_2::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_2::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_2::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_2::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_2::max_overlap_subdomain_id() const
{
    return 0;
}

bool imt_form_2::has_cell_integrals() const
{
    return true;
}

bool imt_form_2::has_exterior_facet_integrals() const
{
    return false;
}

bool imt_form_2::has_interior_facet_integrals() const
{
    return false;
}

bool imt_form_2::has_vertex_integrals() const
{
    return false;
}

bool imt_form_2::has_custom_integrals() const
{
    return false;
}

bool imt_form_2::has_cutcell_integrals() const
{
    return false;
}

bool imt_form_2::has_interface_integrals() const
{
    return false;
}

bool imt_form_2::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * imt_form_2::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * imt_form_2::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * imt_form_2::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * imt_form_2::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * imt_form_2::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * imt_form_2::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * imt_form_2::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * imt_form_2::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * imt_form_2::create_default_cell_integral() const
{
    return new imt_cell_integral_2_otherwise();
}

ufc::exterior_facet_integral * imt_form_2::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * imt_form_2::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * imt_form_2::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * imt_form_2::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * imt_form_2::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * imt_form_2::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * imt_form_2::create_default_overlap_integral() const
{
    return nullptr;
}


imt_form_3::imt_form_3() : ufc::form()
{
    // Do nothing
}

imt_form_3::~imt_form_3()
{
    // Do nothing
}

const char * imt_form_3::signature() const
{
    return "af7d72858308b26e91f2fe52f3a2233bc0b07cb32334f6778959e98f436fe87135130d0b4bb51442106f62467c9144a809f9b7103811c1cdecf0637567835e5c";
}

std::size_t imt_form_3::rank() const
{
    return 0;
}

std::size_t imt_form_3::num_coefficients() const
{
    return 1;
}

std::size_t imt_form_3::original_coefficient_position(std::size_t i) const
{
    if (i >= 1)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0};
    return position[i];
}

ufc::finite_element * imt_form_3::create_coordinate_finite_element() const
{
    return new imt_finite_element_1();
}

ufc::dofmap * imt_form_3::create_coordinate_dofmap() const
{
    return new imt_dofmap_1();
}

ufc::coordinate_mapping * imt_form_3::create_coordinate_mapping() const
{
    return new imt_coordinate_mapping_1();
}

ufc::finite_element * imt_form_3::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new imt_finite_element_3();
    default:
        return nullptr;
    }
}

ufc::dofmap * imt_form_3::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new imt_dofmap_3();
    default:
        return nullptr;
    }
}

std::size_t imt_form_3::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_3::max_exterior_facet_subdomain_id() const
{
    return 1;
}

std::size_t imt_form_3::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_3::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_3::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_3::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_3::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_3::max_overlap_subdomain_id() const
{
    return 0;
}

bool imt_form_3::has_cell_integrals() const
{
    return false;
}

bool imt_form_3::has_exterior_facet_integrals() const
{
    return true;
}

bool imt_form_3::has_interior_facet_integrals() const
{
    return false;
}

bool imt_form_3::has_vertex_integrals() const
{
    return false;
}

bool imt_form_3::has_custom_integrals() const
{
    return false;
}

bool imt_form_3::has_cutcell_integrals() const
{
    return false;
}

bool imt_form_3::has_interface_integrals() const
{
    return false;
}

bool imt_form_3::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * imt_form_3::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * imt_form_3::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    switch (subdomain_id)
    {
    case 0:
        return new imt_exterior_facet_integral_3_0();
    default:
        return nullptr;
    }
}

ufc::interior_facet_integral * imt_form_3::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * imt_form_3::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * imt_form_3::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * imt_form_3::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * imt_form_3::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * imt_form_3::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * imt_form_3::create_default_cell_integral() const
{
    return nullptr;
}

ufc::exterior_facet_integral * imt_form_3::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * imt_form_3::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * imt_form_3::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * imt_form_3::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * imt_form_3::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * imt_form_3::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * imt_form_3::create_default_overlap_integral() const
{
    return nullptr;
}


imt_form_4::imt_form_4() : ufc::form()
{
    // Do nothing
}

imt_form_4::~imt_form_4()
{
    // Do nothing
}

const char * imt_form_4::signature() const
{
    return "982d0ffc29fc17aaeebd6488ddfcaa688bd39f8e07f41992f2ba54493a505f8ff607063846b0bd1a7abcad95023ef4e1dc8eae93aa41699fdd97e97927956385";
}

std::size_t imt_form_4::rank() const
{
    return 0;
}

std::size_t imt_form_4::num_coefficients() const
{
    return 1;
}

std::size_t imt_form_4::original_coefficient_position(std::size_t i) const
{
    if (i >= 1)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0};
    return position[i];
}

ufc::finite_element * imt_form_4::create_coordinate_finite_element() const
{
    return new imt_finite_element_1();
}

ufc::dofmap * imt_form_4::create_coordinate_dofmap() const
{
    return new imt_dofmap_1();
}

ufc::coordinate_mapping * imt_form_4::create_coordinate_mapping() const
{
    return new imt_coordinate_mapping_1();
}

ufc::finite_element * imt_form_4::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new imt_finite_element_3();
    default:
        return nullptr;
    }
}

ufc::dofmap * imt_form_4::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new imt_dofmap_3();
    default:
        return nullptr;
    }
}

std::size_t imt_form_4::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_4::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_4::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_4::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_4::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_4::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_4::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_4::max_overlap_subdomain_id() const
{
    return 0;
}

bool imt_form_4::has_cell_integrals() const
{
    return true;
}

bool imt_form_4::has_exterior_facet_integrals() const
{
    return false;
}

bool imt_form_4::has_interior_facet_integrals() const
{
    return false;
}

bool imt_form_4::has_vertex_integrals() const
{
    return false;
}

bool imt_form_4::has_custom_integrals() const
{
    return false;
}

bool imt_form_4::has_cutcell_integrals() const
{
    return false;
}

bool imt_form_4::has_interface_integrals() const
{
    return false;
}

bool imt_form_4::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * imt_form_4::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * imt_form_4::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * imt_form_4::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * imt_form_4::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * imt_form_4::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * imt_form_4::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * imt_form_4::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * imt_form_4::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * imt_form_4::create_default_cell_integral() const
{
    return new imt_cell_integral_4_otherwise();
}

ufc::exterior_facet_integral * imt_form_4::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * imt_form_4::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * imt_form_4::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * imt_form_4::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * imt_form_4::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * imt_form_4::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * imt_form_4::create_default_overlap_integral() const
{
    return nullptr;
}


imt_form_5::imt_form_5() : ufc::form()
{
    // Do nothing
}

imt_form_5::~imt_form_5()
{
    // Do nothing
}

const char * imt_form_5::signature() const
{
    return "be6aeb33008b7095d60c7820f33d8adda909d9e32cd469fda469b958aa41ee1638d0e0cc7f311bcad21f0170cea469dbae59eef8817f812bac0be5e8ed3cb4df";
}

std::size_t imt_form_5::rank() const
{
    return 2;
}

std::size_t imt_form_5::num_coefficients() const
{
    return 0;
}

std::size_t imt_form_5::original_coefficient_position(std::size_t i) const
{
    throw std::runtime_error("Invalid original coefficient index.");
    return i;
}

ufc::finite_element * imt_form_5::create_coordinate_finite_element() const
{
    return new imt_finite_element_1();
}

ufc::dofmap * imt_form_5::create_coordinate_dofmap() const
{
    return new imt_dofmap_1();
}

ufc::coordinate_mapping * imt_form_5::create_coordinate_mapping() const
{
    return new imt_coordinate_mapping_1();
}

ufc::finite_element * imt_form_5::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new imt_finite_element_0();
    case 1:
        return new imt_finite_element_0();
    default:
        return nullptr;
    }
}

ufc::dofmap * imt_form_5::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new imt_dofmap_0();
    case 1:
        return new imt_dofmap_0();
    default:
        return nullptr;
    }
}

std::size_t imt_form_5::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_5::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_5::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_5::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_5::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_5::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_5::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_5::max_overlap_subdomain_id() const
{
    return 0;
}

bool imt_form_5::has_cell_integrals() const
{
    return true;
}

bool imt_form_5::has_exterior_facet_integrals() const
{
    return false;
}

bool imt_form_5::has_interior_facet_integrals() const
{
    return false;
}

bool imt_form_5::has_vertex_integrals() const
{
    return false;
}

bool imt_form_5::has_custom_integrals() const
{
    return false;
}

bool imt_form_5::has_cutcell_integrals() const
{
    return false;
}

bool imt_form_5::has_interface_integrals() const
{
    return false;
}

bool imt_form_5::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * imt_form_5::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * imt_form_5::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * imt_form_5::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * imt_form_5::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * imt_form_5::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * imt_form_5::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * imt_form_5::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * imt_form_5::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * imt_form_5::create_default_cell_integral() const
{
    return new imt_cell_integral_5_otherwise();
}

ufc::exterior_facet_integral * imt_form_5::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * imt_form_5::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * imt_form_5::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * imt_form_5::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * imt_form_5::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * imt_form_5::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * imt_form_5::create_default_overlap_integral() const
{
    return nullptr;
}


imt_form_6::imt_form_6() : ufc::form()
{
    // Do nothing
}

imt_form_6::~imt_form_6()
{
    // Do nothing
}

const char * imt_form_6::signature() const
{
    return "d9f74e6df8e9fb4024d9f6f374746842f31d3a1b55da1db8117df3ce7f94ba1c0052a29ea08cad5b0b5b1745f8457480fbf1889fb37387929b2f3f698e8ca28b";
}

std::size_t imt_form_6::rank() const
{
    return 1;
}

std::size_t imt_form_6::num_coefficients() const
{
    return 10;
}

std::size_t imt_form_6::original_coefficient_position(std::size_t i) const
{
    if (i >= 10)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    return position[i];
}

ufc::finite_element * imt_form_6::create_coordinate_finite_element() const
{
    return new imt_finite_element_1();
}

ufc::dofmap * imt_form_6::create_coordinate_dofmap() const
{
    return new imt_dofmap_1();
}

ufc::coordinate_mapping * imt_form_6::create_coordinate_mapping() const
{
    return new imt_coordinate_mapping_1();
}

ufc::finite_element * imt_form_6::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new imt_finite_element_0();
    case 1:
        return new imt_finite_element_3();
    case 2:
        return new imt_finite_element_2();
    case 3:
        return new imt_finite_element_2();
    case 4:
        return new imt_finite_element_2();
    case 5:
        return new imt_finite_element_2();
    case 6:
        return new imt_finite_element_2();
    case 7:
        return new imt_finite_element_2();
    case 8:
        return new imt_finite_element_2();
    case 9:
        return new imt_finite_element_2();
    case 10:
        return new imt_finite_element_2();
    default:
        return nullptr;
    }
}

ufc::dofmap * imt_form_6::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new imt_dofmap_0();
    case 1:
        return new imt_dofmap_3();
    case 2:
        return new imt_dofmap_2();
    case 3:
        return new imt_dofmap_2();
    case 4:
        return new imt_dofmap_2();
    case 5:
        return new imt_dofmap_2();
    case 6:
        return new imt_dofmap_2();
    case 7:
        return new imt_dofmap_2();
    case 8:
        return new imt_dofmap_2();
    case 9:
        return new imt_dofmap_2();
    case 10:
        return new imt_dofmap_2();
    default:
        return nullptr;
    }
}

std::size_t imt_form_6::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_6::max_exterior_facet_subdomain_id() const
{
    return 2;
}

std::size_t imt_form_6::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_6::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_6::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_6::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_6::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t imt_form_6::max_overlap_subdomain_id() const
{
    return 0;
}

bool imt_form_6::has_cell_integrals() const
{
    return true;
}

bool imt_form_6::has_exterior_facet_integrals() const
{
    return true;
}

bool imt_form_6::has_interior_facet_integrals() const
{
    return false;
}

bool imt_form_6::has_vertex_integrals() const
{
    return false;
}

bool imt_form_6::has_custom_integrals() const
{
    return false;
}

bool imt_form_6::has_cutcell_integrals() const
{
    return false;
}

bool imt_form_6::has_interface_integrals() const
{
    return false;
}

bool imt_form_6::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * imt_form_6::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * imt_form_6::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    switch (subdomain_id)
    {
    case 0:
        return new imt_exterior_facet_integral_6_0();
    case 1:
        return new imt_exterior_facet_integral_6_1();
    default:
        return nullptr;
    }
}

ufc::interior_facet_integral * imt_form_6::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * imt_form_6::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * imt_form_6::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * imt_form_6::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * imt_form_6::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * imt_form_6::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * imt_form_6::create_default_cell_integral() const
{
    return new imt_cell_integral_6_otherwise();
}

ufc::exterior_facet_integral * imt_form_6::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * imt_form_6::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * imt_form_6::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * imt_form_6::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * imt_form_6::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * imt_form_6::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * imt_form_6::create_default_overlap_integral() const
{
    return nullptr;
}

